import "./chunk-CS7GAYYL.js";
import "./chunk-EMPPHIFZ.js";
import "./chunk-CBWANTKV.js";
import {
  log_if_contains_state,
  onMount
} from "./chunk-ERDDX4B2.js";
import "./chunk-VLYXU236.js";
import "./chunk-XHAIOOWV.js";
import {
  createSubscriber,
  effect_root,
  equals,
  get,
  getContext,
  hasContext,
  on,
  proxy,
  set,
  setContext,
  state,
  strict_equals,
  tag,
  tag_proxy,
  tick,
  track_reactivity_loss,
  untrack,
  update,
  user_derived,
  user_effect,
  user_pre_effect
} from "./chunk-7N4P4YVR.js";
import {
  true_default
} from "./chunk-KVQYCNYS.js";
import "./chunk-VSOLQFAD.js";
import "./chunk-BUSYA2B4.js";

// node_modules/.deno/runed@0.36.0/node_modules/runed/dist/internal/configurable-globals.js
var defaultWindow = true_default && typeof window !== "undefined" ? window : void 0;
var defaultDocument = true_default && typeof window !== "undefined" ? window.document : void 0;
var defaultNavigator = true_default && typeof window !== "undefined" ? window.navigator : void 0;
var defaultLocation = true_default && typeof window !== "undefined" ? window.location : void 0;

// node_modules/.deno/runed@0.36.0/node_modules/runed/dist/internal/utils/dom.js
function getActiveElement(document2) {
  let activeElement2 = document2.activeElement;
  while (activeElement2?.shadowRoot) {
    const node = activeElement2.shadowRoot.activeElement;
    if (node === activeElement2)
      break;
    else
      activeElement2 = node;
  }
  return activeElement2;
}
function getOwnerDocument(node, fallback = defaultDocument) {
  return node?.ownerDocument ?? fallback;
}
function isOrContainsTarget(node, target) {
  return node === target || node.contains(target);
}

// node_modules/.deno/runed@0.36.0/node_modules/runed/dist/utilities/active-element/active-element.svelte.js
var ActiveElement = class {
  #document;
  #subscribe;
  constructor(options = {}) {
    const { window: window2 = defaultWindow, document: document2 = window2?.document } = options;
    if (strict_equals(window2, void 0)) return;
    this.#document = document2;
    this.#subscribe = createSubscriber((update2) => {
      const cleanupFocusIn = on(window2, "focusin", update2);
      const cleanupFocusOut = on(window2, "focusout", update2);
      return () => {
        cleanupFocusIn();
        cleanupFocusOut();
      };
    });
  }
  get current() {
    this.#subscribe?.();
    if (!this.#document) return null;
    return getActiveElement(this.#document);
  }
};
var activeElement = new ActiveElement();

// node_modules/.deno/runed@0.36.0/node_modules/runed/dist/internal/utils/is.js
function isFunction(value) {
  return typeof value === "function";
}
function isElement(value) {
  return value instanceof Element;
}

// node_modules/.deno/runed@0.36.0/node_modules/runed/dist/utilities/extract/extract.svelte.js
function extract(value, defaultValue) {
  if (isFunction(value)) {
    const getter = value;
    const gotten = getter();
    if (strict_equals(gotten, void 0)) return defaultValue;
    return gotten;
  }
  if (strict_equals(value, void 0)) return defaultValue;
  return value;
}

// node_modules/.deno/runed@0.36.0/node_modules/runed/dist/utilities/animation-frames/animation-frames.svelte.js
var AnimationFrames = class {
  #callback;
  #fpsLimitOption = 0;
  #fpsLimit = tag(user_derived(() => extract(this.#fpsLimitOption) ?? 0), "AnimationFrames.#fpsLimit");
  #previousTimestamp = null;
  #frame = null;
  #fps = tag(state(0), "AnimationFrames.#fps");
  #running = tag(state(false), "AnimationFrames.#running");
  #window = defaultWindow;
  constructor(callback, options = {}) {
    if (options.window) this.#window = options.window;
    this.#fpsLimitOption = options.fpsLimit;
    this.#callback = callback;
    this.start = this.start.bind(this);
    this.stop = this.stop.bind(this);
    this.toggle = this.toggle.bind(this);
    user_effect(() => {
      if (options.immediate ?? true) {
        untrack(this.start);
      }
      return this.stop;
    });
  }
  #loop(timestamp) {
    if (!get(this.#running) || !this.#window) return;
    if (strict_equals(this.#previousTimestamp, null)) {
      this.#previousTimestamp = timestamp;
    }
    const delta = timestamp - this.#previousTimestamp;
    const fps = 1e3 / delta;
    if (get(this.#fpsLimit) && fps > get(this.#fpsLimit)) {
      this.#frame = this.#window.requestAnimationFrame(this.#loop.bind(this));
      return;
    }
    set(this.#fps, fps);
    this.#previousTimestamp = timestamp;
    this.#callback({ delta, timestamp });
    this.#frame = this.#window.requestAnimationFrame(this.#loop.bind(this));
  }
  start() {
    if (!this.#window) return;
    set(this.#running, true);
    this.#previousTimestamp = 0;
    this.#frame = this.#window.requestAnimationFrame(this.#loop.bind(this));
  }
  stop() {
    if (!this.#frame || !this.#window) return;
    set(this.#running, false);
    this.#window.cancelAnimationFrame(this.#frame);
    this.#frame = null;
  }
  toggle() {
    get(this.#running) ? this.stop() : this.start();
  }
  get fps() {
    return !get(this.#running) ? 0 : get(this.#fps);
  }
  get running() {
    return get(this.#running);
  }
};

// node_modules/.deno/runed@0.36.0/node_modules/runed/dist/utilities/context/context.js
var Context = class {
  #name;
  #key;
  /**
   * @param name The name of the context.
   * This is used for generating the context key and error messages.
   */
  constructor(name) {
    this.#name = name;
    this.#key = Symbol(name);
  }
  /**
   * The key used to get and set the context.
   *
   * It is not recommended to use this value directly.
   * Instead, use the methods provided by this class.
   */
  get key() {
    return this.#key;
  }
  /**
   * Checks whether this has been set in the context of a parent component.
   *
   * Must be called during component initialisation.
   */
  exists() {
    return hasContext(this.#key);
  }
  /**
   * Retrieves the context that belongs to the closest parent component.
   *
   * Must be called during component initialisation.
   *
   * @throws An error if the context does not exist.
   */
  get() {
    const context = getContext(this.#key);
    if (context === void 0) {
      throw new Error(`Context "${this.#name}" not found`);
    }
    return context;
  }
  /**
   * Retrieves the context that belongs to the closest parent component,
   * or the given fallback value if the context does not exist.
   *
   * Must be called during component initialisation.
   */
  getOr(fallback) {
    const context = getContext(this.#key);
    if (context === void 0) {
      return fallback;
    }
    return context;
  }
  /**
   * Associates the given value with the current component and returns it.
   *
   * Must be called during component initialisation.
   */
  set(context) {
    return setContext(this.#key, context);
  }
};

// node_modules/.deno/runed@0.36.0/node_modules/runed/dist/utilities/use-debounce/use-debounce.svelte.js
function useDebounce(callback, wait) {
  let context = tag(state(null), "context");
  const wait$ = tag(user_derived(() => extract(wait, 250)), "wait$");
  function debounced(...args) {
    if (get(context)) {
      if (get(context).timeout) {
        clearTimeout(get(context).timeout);
      }
    } else {
      let resolve;
      let reject;
      const promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });
      set(context, { timeout: null, runner: null, promise, resolve, reject }, true);
    }
    get(context).runner = async () => {
      if (!get(context)) return;
      const ctx = get(context);
      set(context, null);
      try {
        ctx.resolve((await track_reactivity_loss(callback.apply(this, args)))());
      } catch (error) {
        ctx.reject(error);
      }
    };
    get(context).timeout = setTimeout(get(context).runner, get(wait$));
    return get(context).promise;
  }
  debounced.cancel = async () => {
    if (!get(context) || strict_equals(get(context).timeout, null)) {
      (await track_reactivity_loss(new Promise((resolve) => setTimeout(resolve, 0))))();
      if (!get(context) || strict_equals(get(context).timeout, null)) return;
    }
    clearTimeout(get(context).timeout);
    get(context).reject("Cancelled");
    set(context, null);
  };
  debounced.runScheduledNow = async () => {
    if (!get(context) || !get(context).timeout) {
      (await track_reactivity_loss(new Promise((resolve) => setTimeout(resolve, 0))))();
      if (!get(context) || !get(context).timeout) return;
    }
    clearTimeout(get(context).timeout);
    get(context).timeout = null;
    (await track_reactivity_loss(get(context).runner?.()))();
  };
  Object.defineProperty(debounced, "pending", {
    enumerable: true,
    get() {
      return !!get(context)?.timeout;
    }
  });
  return debounced;
}

// node_modules/.deno/runed@0.36.0/node_modules/runed/dist/utilities/watch/watch.svelte.js
function runEffect(flush, effect) {
  switch (flush) {
    case "post":
      user_effect(effect);
      break;
    case "pre":
      user_pre_effect(effect);
      break;
  }
}
function runWatcher(sources, flush, effect, options = {}) {
  const { lazy = false } = options;
  let active = !lazy;
  let previousValues = Array.isArray(sources) ? [] : void 0;
  runEffect(flush, () => {
    const values = Array.isArray(sources) ? sources.map((source) => source()) : sources();
    if (!active) {
      active = true;
      previousValues = values;
      return;
    }
    const cleanup = untrack(() => effect(values, previousValues));
    previousValues = values;
    return cleanup;
  });
}
function runWatcherOnce(sources, flush, effect) {
  const cleanupRoot = effect_root(() => {
    let stop = false;
    runWatcher(
      sources,
      flush,
      (values, previousValues) => {
        if (stop) {
          cleanupRoot();
          return;
        }
        const cleanup = effect(values, previousValues);
        stop = true;
        return cleanup;
      },
      // Running the effect immediately just once makes no sense at all.
      // That's just `onMount` with extra steps.
      { lazy: true }
    );
  });
  user_effect(() => {
    return cleanupRoot;
  });
}
function watch(sources, effect, options) {
  runWatcher(sources, "post", effect, options);
}
function watchPre(sources, effect, options) {
  runWatcher(sources, "pre", effect, options);
}
watch.pre = watchPre;
function watchOnce(source, effect) {
  runWatcherOnce(source, "post", effect);
}
function watchOncePre(source, effect) {
  runWatcherOnce(source, "pre", effect);
}
watchOnce.pre = watchOncePre;

// node_modules/.deno/runed@0.36.0/node_modules/runed/dist/internal/utils/function.js
function noop() {
}

// node_modules/.deno/runed@0.36.0/node_modules/runed/dist/utilities/debounced/debounced.svelte.js
var Debounced = class {
  #current = tag(state(), "Debounced.#current");
  #debounceFn;
  /**
   * @param getter A function that returns the state to watch.
   * @param wait The length of time to wait in ms, defaults to 250.
   */
  constructor(getter, wait = 250) {
    set(
      this.#current,
      getter(),
      // immediately set the initial value
      true
    );
    this.cancel = this.cancel.bind(this);
    this.setImmediately = this.setImmediately.bind(this);
    this.updateImmediately = this.updateImmediately.bind(this);
    this.#debounceFn = useDebounce(
      () => {
        set(this.#current, getter(), true);
      },
      wait
    );
    watch(getter, () => {
      this.#debounceFn().catch(noop);
    });
  }
  // isn't the name "current" slightly misleading? it sounds like the latest, raw value
  /**
   * Get the debounced value.
   */
  get current() {
    return get(this.#current);
  }
  /**
   * Whether a timer is currently pending.
   */
  get pending() {
    return this.#debounceFn.pending;
  }
  /**
   * Cancel the latest timer.
   */
  cancel() {
    this.#debounceFn.cancel();
  }
  /**
   * Run the debounced function immediately.
   */
  updateImmediately() {
    return this.#debounceFn.runScheduledNow();
  }
  /**
   * Set the `current` value without waiting.
   */
  setImmediately(v) {
    this.cancel();
    set(this.#current, v, true);
  }
};

// node_modules/.deno/runed@0.36.0/node_modules/runed/dist/utilities/use-mutation-observer/use-mutation-observer.svelte.js
function useMutationObserver(target, callback, options = {}) {
  const { window: window2 = defaultWindow } = options;
  let observer;
  const targets = tag(
    user_derived(() => {
      const value = extract(target);
      return new Set(value ? Array.isArray(value) ? value : [value] : []);
    }),
    "targets"
  );
  const stop = effect_root(() => {
    user_effect(() => {
      if (!get(targets).size || !window2) return;
      observer = new window2.MutationObserver(callback);
      for (const el of get(targets)) observer.observe(el, options);
      return () => {
        observer?.disconnect();
        observer = void 0;
      };
    });
  });
  user_effect(() => {
    return stop;
  });
  return {
    stop,
    takeRecords() {
      return observer?.takeRecords();
    }
  };
}

// node_modules/.deno/runed@0.36.0/node_modules/runed/dist/utilities/use-resize-observer/use-resize-observer.svelte.js
function useResizeObserver(target, callback, options = {}) {
  const { window: window2 = defaultWindow } = options;
  let observer;
  const targets = tag(
    user_derived(() => {
      const value = extract(target);
      return new Set(value ? Array.isArray(value) ? value : [value] : []);
    }),
    "targets"
  );
  const stop = effect_root(() => {
    user_effect(() => {
      if (!get(targets).size || !window2) return;
      observer = new window2.ResizeObserver(callback);
      for (const el of get(targets)) observer.observe(el, options);
      return () => {
        observer?.disconnect();
        observer = void 0;
      };
    });
  });
  user_effect(() => {
    return stop;
  });
  return { stop };
}

// node_modules/.deno/runed@0.36.0/node_modules/runed/dist/utilities/element-rect/element-rect.svelte.js
var ElementRect = class {
  #rect = tag(
    state(proxy({
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    })),
    "ElementRect.#rect"
  );
  constructor(node, options = {}) {
    set(
      this.#rect,
      {
        width: options.initialRect?.width ?? 0,
        height: options.initialRect?.height ?? 0,
        x: options.initialRect?.x ?? 0,
        y: options.initialRect?.y ?? 0,
        top: options.initialRect?.top ?? 0,
        right: options.initialRect?.right ?? 0,
        bottom: options.initialRect?.bottom ?? 0,
        left: options.initialRect?.left ?? 0
      },
      true
    );
    const el = tag(user_derived(() => extract(node)), "el");
    const update2 = () => {
      if (!get(el)) return;
      const rect = get(el).getBoundingClientRect();
      get(this.#rect).width = rect.width;
      get(this.#rect).height = rect.height;
      get(this.#rect).x = rect.x;
      get(this.#rect).y = rect.y;
      get(this.#rect).top = rect.top;
      get(this.#rect).right = rect.right;
      get(this.#rect).bottom = rect.bottom;
      get(this.#rect).left = rect.left;
    };
    useResizeObserver(() => get(el), update2, { window: options.window });
    user_effect(update2);
    useMutationObserver(() => get(el), update2, { attributeFilter: ["style", "class"], window: options.window });
  }
  get x() {
    return get(this.#rect).x;
  }
  get y() {
    return get(this.#rect).y;
  }
  get width() {
    return get(this.#rect).width;
  }
  get height() {
    return get(this.#rect).height;
  }
  get top() {
    return get(this.#rect).top;
  }
  get right() {
    return get(this.#rect).right;
  }
  get bottom() {
    return get(this.#rect).bottom;
  }
  get left() {
    return get(this.#rect).left;
  }
  get current() {
    return get(this.#rect);
  }
};

// node_modules/.deno/runed@0.36.0/node_modules/runed/dist/internal/utils/get.js
function get2(value) {
  if (isFunction(value)) {
    return value();
  }
  return value;
}

// node_modules/.deno/runed@0.36.0/node_modules/runed/dist/utilities/element-size/element-size.svelte.js
var ElementSize = class {
  // no need to use `$state` here since we are using createSubscriber
  #size = { width: 0, height: 0 };
  #observed = false;
  #options;
  #node;
  #window;
  // we use a derived here to extract the width so that if the width doesn't change we don't get a state update
  // which we would get if we would just use a getter since the version of the subscriber will be changing
  #width = tag(
    user_derived(() => {
      get(this.#subscribe)?.();
      return this.getSize().width;
    }),
    "ElementSize.#width"
  );
  // we use a derived here to extract the height so that if the height doesn't change we don't get a state update
  // which we would get if we would just use a getter since the version of the subscriber will be changing
  #height = tag(
    user_derived(() => {
      get(this.#subscribe)?.();
      return this.getSize().height;
    }),
    "ElementSize.#height"
  );
  // we need to use a derived here because the class will be created before the node is bound to the ref
  #subscribe = tag(
    user_derived(() => {
      const node$ = get2(this.#node);
      if (!node$) return;
      return createSubscriber((update2) => {
        if (!this.#window) return;
        const observer = new this.#window.ResizeObserver((entries) => {
          this.#observed = true;
          for (const entry of entries) {
            const boxSize = strict_equals(this.#options.box, "content-box") ? entry.contentBoxSize : entry.borderBoxSize;
            const boxSizeArr = Array.isArray(boxSize) ? boxSize : [boxSize];
            this.#size.width = boxSizeArr.reduce((acc, size) => Math.max(acc, size.inlineSize), 0);
            this.#size.height = boxSizeArr.reduce((acc, size) => Math.max(acc, size.blockSize), 0);
          }
          update2();
        });
        observer.observe(node$);
        return () => {
          this.#observed = false;
          observer.disconnect();
        };
      });
    }),
    "ElementSize.#subscribe"
  );
  constructor(node, options = { box: "border-box" }) {
    this.#window = options.window ?? defaultWindow;
    this.#options = options;
    this.#node = node;
    this.#size = { width: 0, height: 0 };
  }
  calculateSize() {
    const element = get2(this.#node);
    if (!element || !this.#window) {
      return;
    }
    const offsetWidth = element.offsetWidth;
    const offsetHeight = element.offsetHeight;
    if (strict_equals(this.#options.box, "border-box")) {
      return { width: offsetWidth, height: offsetHeight };
    }
    const style = this.#window.getComputedStyle(element);
    const paddingWidth = parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
    const paddingHeight = parseFloat(style.paddingTop) + parseFloat(style.paddingBottom);
    const borderWidth = parseFloat(style.borderLeftWidth) + parseFloat(style.borderRightWidth);
    const borderHeight = parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);
    const contentWidth = offsetWidth - paddingWidth - borderWidth;
    const contentHeight = offsetHeight - paddingHeight - borderHeight;
    return { width: contentWidth, height: contentHeight };
  }
  getSize() {
    return this.#observed ? this.#size : this.calculateSize() ?? this.#size;
  }
  get current() {
    get(this.#subscribe)?.();
    return this.getSize();
  }
  get width() {
    return get(this.#width);
  }
  get height() {
    return get(this.#height);
  }
};

// node_modules/.deno/runed@0.36.0/node_modules/runed/dist/utilities/finite-state-machine/finite-state-machine.svelte.js
function isLifecycleFnMeta(meta) {
  return !!meta && strict_equals(typeof meta, "object") && "to" in meta && "from" in meta && "event" in meta && "args" in meta;
}
var FiniteStateMachine = class {
  #current = tag(state(), "FiniteStateMachine.#current");
  states;
  #timeout = {};
  constructor(initial, states) {
    set(this.#current, initial, true);
    this.states = states;
    this.send = this.send.bind(this);
    this.debounce = this.debounce.bind(this);
    this.#dispatch("_enter", { from: null, to: initial, event: null, args: [] });
  }
  #transition(newState, event, args) {
    const metadata = { from: get(this.#current), to: newState, event, args };
    this.#dispatch("_exit", metadata);
    set(this.#current, newState, true);
    this.#dispatch("_enter", metadata);
  }
  #dispatch(event, ...args) {
    const action = this.states[get(this.#current)]?.[event] ?? this.states["*"]?.[event];
    if (action instanceof Function) {
      if (strict_equals(event, "_enter") || strict_equals(event, "_exit")) {
        if (isLifecycleFnMeta(args[0])) {
          action(args[0]);
        } else {
          console.warn("Invalid metadata passed to lifecycle function of the FSM.");
        }
      } else {
        return action(...args);
      }
    } else if (strict_equals(typeof action, "string")) {
      return action;
    } else if (strict_equals(event, "_enter", false) && strict_equals(event, "_exit", false)) {
      console.warn(...log_if_contains_state("warn", "No action defined for event", event, "in state", get(this.#current)));
    }
  }
  /** Triggers a new event and returns the new state. */
  send(event, ...args) {
    const newState = this.#dispatch(event, ...args);
    if (newState && strict_equals(newState, get(this.#current), false)) {
      this.#transition(newState, event, args);
    }
    return get(this.#current);
  }
  /** Debounces the triggering of an event. */
  async debounce(wait = 500, event, ...args) {
    if (this.#timeout[event]) {
      clearTimeout(this.#timeout[event]);
    }
    return new Promise((resolve) => {
      this.#timeout[event] = setTimeout(
        () => {
          delete this.#timeout[event];
          resolve(this.send(event, ...args));
        },
        wait
      );
    });
  }
  /** The current state. */
  get current() {
    return get(this.#current);
  }
};

// node_modules/.deno/runed@0.36.0/node_modules/runed/dist/utilities/is-focus-within/is-focus-within.svelte.js
var IsFocusWithin = class {
  #node;
  #activeElement;
  constructor(node, options = {}) {
    this.#node = node;
    this.#activeElement = new ActiveElement(options);
  }
  #current = tag(
    user_derived(() => {
      const node = extract(this.#node);
      if (equals(node, null)) return false;
      return node.contains(this.#activeElement.current);
    }),
    "IsFocusWithin.current"
  );
  get current() {
    return get(this.#current);
  }
  set current(value) {
    set(this.#current, value);
  }
};

// node_modules/.deno/runed@0.36.0/node_modules/runed/dist/utilities/use-event-listener/use-event-listener.svelte.js
function useEventListener(_target, _events, handler, options) {
  user_effect(() => {
    const target = extract(_target);
    if (equals(target, null)) return;
    const events = extract(_events);
    if (Array.isArray(events)) {
      for (const event of events) {
        user_effect(() => on(target, event, handler, options));
      }
    } else {
      return on(target, events, handler, options);
    }
  });
}

// node_modules/.deno/runed@0.36.0/node_modules/runed/dist/utilities/is-idle/is-idle.svelte.js
var DEFAULT_EVENTS = ["keypress", "mousemove", "touchmove", "click", "scroll"];
var DEFAULT_OPTIONS = {
  events: DEFAULT_EVENTS,
  initialState: false,
  timeout: 6e4,
  trackLastActive: true
};
var IsIdle = class {
  #current = tag(state(false), "IsIdle.#current");
  #lastActive = tag(state(proxy(Date.now())), "IsIdle.#lastActive");
  constructor(_options) {
    const opts = { ...DEFAULT_OPTIONS, ..._options };
    const window2 = opts.window ?? defaultWindow;
    const document2 = opts.document ?? window2?.document;
    const timeout = tag(user_derived(() => extract(opts.timeout)), "timeout");
    const events = tag(user_derived(() => extract(opts.events)), "events");
    const detectVisibilityChanges = tag(user_derived(() => extract(opts.detectVisibilityChanges)), "detectVisibilityChanges");
    const trackLastActive = tag(user_derived(() => extract(opts.trackLastActive)), "trackLastActive");
    set(this.#current, opts.initialState, true);
    const debouncedReset = useDebounce(
      () => {
        set(this.#current, true);
      },
      () => get(timeout)
    );
    debouncedReset();
    const handleActivity = () => {
      set(this.#current, false);
      if (get(trackLastActive)) {
        set(this.#lastActive, Date.now(), true);
      }
      debouncedReset();
    };
    useEventListener(
      () => window2,
      () => get(events),
      () => {
        handleActivity();
      },
      { passive: true }
    );
    user_effect(() => {
      if (!get(detectVisibilityChanges) || !document2) return;
      useEventListener(document2, ["visibilitychange"], () => {
        if (document2.hidden) return;
        handleActivity();
      });
    });
  }
  get lastActive() {
    return get(this.#lastActive);
  }
  get current() {
    return get(this.#current);
  }
};

// node_modules/.deno/runed@0.36.0/node_modules/runed/dist/utilities/use-intersection-observer/use-intersection-observer.svelte.js
function useIntersectionObserver(target, callback, options = {}) {
  const {
    root,
    rootMargin = "0px",
    threshold = 0.1,
    immediate = true,
    window: window2 = defaultWindow
  } = options;
  let isActive = tag(state(proxy(immediate)), "isActive");
  let observer;
  const targets = tag(
    user_derived(() => {
      const value = extract(target);
      return new Set(value ? Array.isArray(value) ? value : [value] : []);
    }),
    "targets"
  );
  const stop = effect_root(() => {
    user_effect(() => {
      if (!get(targets).size || !get(isActive) || !window2) return;
      observer = new window2.IntersectionObserver(callback, { rootMargin, root: get2(root), threshold });
      for (const el of get(targets)) observer.observe(el);
      return () => {
        observer?.disconnect();
      };
    });
  });
  user_effect(() => {
    return stop;
  });
  return {
    get isActive() {
      return get(isActive);
    },
    stop,
    pause() {
      set(isActive, false);
    },
    resume() {
      set(isActive, true);
    }
  };
}

// node_modules/.deno/runed@0.36.0/node_modules/runed/dist/utilities/is-in-viewport/is-in-viewport.svelte.js
var IsInViewport = class {
  #isInViewport = tag(state(false), "IsInViewport.#isInViewport");
  constructor(node, options) {
    useIntersectionObserver(
      node,
      (intersectionObserverEntries) => {
        let isIntersecting = get(this.#isInViewport);
        let latestTime = 0;
        for (const entry of intersectionObserverEntries) {
          if (entry.time >= latestTime) {
            latestTime = entry.time;
            isIntersecting = entry.isIntersecting;
          }
        }
        set(this.#isInViewport, isIntersecting, true);
      },
      options
    );
  }
  get current() {
    return get(this.#isInViewport);
  }
};

// node_modules/.deno/runed@0.36.0/node_modules/runed/dist/utilities/is-mounted/is-mounted.svelte.js
var IsMounted = class {
  #isMounted = tag(state(false), "IsMounted.#isMounted");
  constructor() {
    user_effect(() => {
      untrack(() => set(this.#isMounted, true));
      return () => {
        set(this.#isMounted, false);
      };
    });
  }
  get current() {
    return get(this.#isMounted);
  }
};

// node_modules/.deno/runed@0.36.0/node_modules/runed/dist/utilities/is-document-visible/is-document-visible.svelte.js
var IsDocumentVisible = class {
  #visible = tag(state(false), "IsDocumentVisible.#visible");
  constructor(options = {}) {
    const window2 = options.window ?? defaultWindow;
    const document2 = options.document ?? window2?.document;
    set(this.#visible, document2 ? !document2.hidden : false, true);
    user_effect(() => {
      if (!document2) return;
      return on(document2, "visibilitychange", () => {
        set(this.#visible, !document2.hidden);
      });
    });
  }
  get current() {
    return get(this.#visible);
  }
};

// node_modules/.deno/runed@0.36.0/node_modules/runed/dist/internal/utils/sleep.js
async function sleep(ms = 0) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

// node_modules/.deno/runed@0.36.0/node_modules/runed/dist/utilities/on-click-outside/on-click-outside.svelte.js
function onClickOutside(container, callback, opts = {}) {
  const {
    window: window2 = defaultWindow,
    immediate = true,
    detectIframe = false
  } = opts;
  const document2 = opts.document ?? window2?.document;
  const node = tag(user_derived(() => extract(container)), "node");
  const nodeOwnerDocument = tag(user_derived(() => getOwnerDocument(get(node), document2)), "nodeOwnerDocument");
  let enabled = tag(state(proxy(immediate)), "enabled");
  let pointerDownIntercepted = false;
  let removeClickListener = noop;
  let removeListeners = noop;
  const handleClickOutside = useDebounce(
    (e) => {
      if (!get(node) || !get(nodeOwnerDocument)) {
        removeClickListener();
        return;
      }
      if (strict_equals(pointerDownIntercepted, true) || !isValidEvent(e, get(node), get(nodeOwnerDocument))) {
        removeClickListener();
        return;
      }
      if (strict_equals(e.pointerType, "touch")) {
        removeClickListener();
        removeClickListener = on(get(nodeOwnerDocument), "click", () => callback(e), { once: true });
      } else {
        callback(e);
      }
    },
    10
  );
  function addListeners() {
    if (!get(nodeOwnerDocument) || !window2 || !get(node)) return noop;
    const events = [
      /**
       * CAPTURE INTERACTION START
       * Mark the pointerdown event as intercepted to indicate that an interaction
       * has started. This helps in distinguishing between valid and invalid events.
       */
      on(
        get(nodeOwnerDocument),
        "pointerdown",
        (e) => {
          if (isValidEvent(e, get(node), get(nodeOwnerDocument))) {
            pointerDownIntercepted = true;
          }
        },
        { capture: true }
      ),
      /**
       * BUBBLE INTERACTION START
       * Mark the pointerdown event as non-intercepted. Debounce `handleClickOutside` to
       * avoid prematurely checking if other events were intercepted.
       */
      on(get(nodeOwnerDocument), "pointerdown", (e) => {
        pointerDownIntercepted = false;
        handleClickOutside(e);
      })
    ];
    if (detectIframe) {
      events.push(
        /**
         * DETECT IFRAME INTERACTIONS
         *
         * We add a blur event listener to the window to detect when the user
         * interacts with an iframe. If the active element is an iframe and it
         * is not a descendant of the container, we call the callback function.
         */
        on(window2, "blur", async (e) => {
          (await track_reactivity_loss(sleep()))();
          const activeElement2 = getActiveElement(get(nodeOwnerDocument));
          if (strict_equals(activeElement2?.tagName, "IFRAME") && !isOrContainsTarget(get(node), activeElement2)) {
            callback(e);
          }
        })
      );
    }
    return () => {
      for (const event of events) {
        event();
      }
    };
  }
  function cleanup() {
    pointerDownIntercepted = false;
    handleClickOutside.cancel();
    removeClickListener();
    removeListeners();
  }
  watch([() => get(enabled), () => get(node)], ([enabled$, node$]) => {
    if (enabled$ && node$) {
      removeListeners();
      removeListeners = addListeners();
    } else {
      cleanup();
    }
  });
  user_effect(() => {
    return () => {
      cleanup();
    };
  });
  return {
    /** Stop listening for click events outside the container. */
    stop: () => set(enabled, false),
    /** Start listening for click events outside the container. */
    start: () => set(enabled, true),
    /** Whether the click outside handler is currently enabled or not. */
    get enabled() {
      return get(enabled);
    }
  };
}
function isValidEvent(e, container, defaultDocument2) {
  if ("button" in e && e.button > 0) return false;
  const target = e.target;
  if (!isElement(target)) return false;
  const ownerDocument = getOwnerDocument(target, defaultDocument2);
  if (!ownerDocument) return false;
  if (strict_equals(target, container)) {
    const rect = container.getBoundingClientRect();
    const wasInsideClick = rect.top <= e.clientY && e.clientY <= rect.top + rect.height && rect.left <= e.clientX && e.clientX <= rect.left + rect.width;
    return !wasInsideClick;
  }
  return ownerDocument.documentElement.contains(target) && !isOrContainsTarget(container, target);
}

// node_modules/.deno/runed@0.36.0/node_modules/runed/dist/utilities/persisted-state/persisted-state.svelte.js
function getStorage(storageType, window2) {
  switch (storageType) {
    case "local":
      return window2.localStorage;
    case "session":
      return window2.sessionStorage;
  }
}
function proxy2(value, root, proxies, subscribe, update2, serialize) {
  if (strict_equals(value, null) || strict_equals(typeof value, "object", false)) {
    return value;
  }
  const proto = Object.getPrototypeOf(value);
  if (strict_equals(proto, null, false) && strict_equals(proto, Object.prototype, false) && !Array.isArray(value)) {
    return value;
  }
  let p = proxies.get(value);
  if (!p) {
    p = new Proxy(value, {
      get: (target, property) => {
        subscribe?.();
        return proxy2(Reflect.get(target, property), root, proxies, subscribe, update2, serialize);
      },
      set: (target, property, value2) => {
        update2?.();
        Reflect.set(target, property, value2);
        serialize(root);
        return true;
      }
    });
    proxies.set(value, p);
  }
  return p;
}
var PersistedState = class {
  #current;
  #key;
  #serializer;
  #storage;
  #subscribe;
  #update;
  #proxies = /* @__PURE__ */ new WeakMap();
  constructor(key, initialValue, options = {}) {
    const {
      storage: storageType = "local",
      serializer = { serialize: JSON.stringify, deserialize: JSON.parse },
      syncTabs = true
    } = options;
    const window2 = "window" in options ? options.window : defaultWindow;
    this.#current = initialValue;
    this.#key = key;
    this.#serializer = serializer;
    if (strict_equals(window2, void 0)) return;
    const storage = getStorage(storageType, window2);
    this.#storage = storage;
    const existingValue = storage.getItem(key);
    if (strict_equals(existingValue, null, false)) {
      this.#current = this.#deserialize(existingValue);
    } else {
      this.#serialize(initialValue);
    }
    this.#subscribe = createSubscriber((update2) => {
      this.#update = update2;
      const cleanup = syncTabs && strict_equals(storageType, "local") ? on(window2, "storage", this.#handleStorageEvent) : null;
      return () => {
        cleanup?.();
        this.#update = void 0;
      };
    });
  }
  get current() {
    this.#subscribe?.();
    const storageItem = this.#storage?.getItem(this.#key);
    const root = storageItem ? this.#deserialize(storageItem) : this.#current;
    return proxy2(root, root, this.#proxies, this.#subscribe?.bind(this), this.#update?.bind(this), this.#serialize.bind(this));
  }
  set current(newValue) {
    this.#serialize(newValue);
    this.#update?.();
  }
  #handleStorageEvent = (event) => {
    if (strict_equals(event.key, this.#key, false) || strict_equals(event.newValue, null)) return;
    this.#current = this.#deserialize(event.newValue);
    this.#update?.();
  };
  #deserialize(value) {
    try {
      return this.#serializer.deserialize(value);
    } catch (error) {
      console.error(...log_if_contains_state("error", `Error when parsing "${value}" from persisted store "${this.#key}"`, error));
      return;
    }
  }
  #serialize(value) {
    try {
      if (equals(value, void 0, false)) {
        this.#storage?.setItem(this.#key, this.#serializer.serialize(value));
      }
    } catch (error) {
      console.error(...log_if_contains_state("error", `Error when writing value from persisted store "${this.#key}" to ${this.#storage}`, error));
    }
  }
};

// node_modules/.deno/runed@0.36.0/node_modules/runed/dist/utilities/pressed-keys/pressed-keys.svelte.js
var modifierKeys = ["meta", "control", "alt", "shift"];
var PressedKeys = class {
  #pressedKeys = tag(state(proxy([])), "PressedKeys.#pressedKeys");
  #subscribe;
  constructor(options = {}) {
    const { window: window2 = defaultWindow } = options;
    this.has = this.has.bind(this);
    if (!window2) return;
    this.#subscribe = createSubscriber((update2) => {
      const keydown = on(window2, "keydown", (e) => {
        const key = e.key.toLowerCase();
        if (!get(this.#pressedKeys).includes(key)) {
          get(this.#pressedKeys).push(key);
        }
        update2();
      });
      const keyup = on(window2, "keyup", (e) => {
        const key = e.key.toLowerCase();
        if (modifierKeys.includes(key)) {
          set(this.#pressedKeys, get(this.#pressedKeys).filter((k) => modifierKeys.includes(k)), true);
        }
        set(this.#pressedKeys, get(this.#pressedKeys).filter((k) => strict_equals(k, key, false)), true);
        update2();
      });
      const blur = on(window2, "blur", () => {
        set(this.#pressedKeys, [], true);
        update2();
      });
      const visibilityChange = on(document, "visibilitychange", () => {
        if (strict_equals(document.visibilityState, "hidden")) {
          set(this.#pressedKeys, [], true);
          update2();
        }
      });
      return () => {
        keydown();
        keyup();
        blur();
        visibilityChange();
      };
    });
  }
  has(...keys) {
    this.#subscribe?.();
    const normalizedKeys = keys.map((key) => key.toLowerCase());
    return normalizedKeys.every((key) => get(this.#pressedKeys).includes(key));
  }
  get all() {
    this.#subscribe?.();
    return get(this.#pressedKeys);
  }
  /**
   * Registers a callback to execute when specified key combination is pressed.
   *
   * @param keys - Array or single string of keys to monitor
   * @param callback - Function to execute when the key combination is matched
   */
  onKeys(keys, callback) {
    this.#subscribe?.();
    const keysToMonitor = Array.isArray(keys) ? keys : [keys];
    watch(() => this.all, () => {
      if (this.has(...keysToMonitor)) {
        callback();
      }
    });
  }
};

// node_modules/.deno/runed@0.36.0/node_modules/runed/dist/utilities/previous/previous.svelte.js
var Previous = class {
  #previousCallback = () => void 0;
  #previous = tag(user_derived(() => this.#previousCallback()), "Previous.#previous");
  constructor(getter, initialValue) {
    let actualPrevious = void 0;
    if (strict_equals(initialValue, void 0, false)) actualPrevious = initialValue;
    this.#previousCallback = () => {
      try {
        return actualPrevious;
      } finally {
        actualPrevious = getter();
      }
    };
  }
  get current() {
    return get(this.#previous);
  }
};

// node_modules/.deno/runed@0.36.0/node_modules/runed/dist/utilities/resource/resource.svelte.js
function debounce(fn, delay) {
  let timeoutId;
  let lastResolve = null;
  return (...args) => {
    return new Promise((resolve) => {
      if (lastResolve) {
        lastResolve(void 0);
      }
      lastResolve = resolve;
      clearTimeout(timeoutId);
      timeoutId = setTimeout(
        async () => {
          const result = (await track_reactivity_loss(fn(...args)))();
          if (lastResolve) {
            lastResolve(result);
            lastResolve = null;
          }
        },
        delay
      );
    });
  };
}
function throttle(fn, delay) {
  let lastRun = 0;
  let lastPromise = null;
  return (...args) => {
    const now = Date.now();
    if (lastRun && now - lastRun < delay) {
      return lastPromise ?? Promise.resolve(void 0);
    }
    lastRun = now;
    lastPromise = fn(...args);
    return lastPromise;
  };
}
function runResource(source, fetcher, options = {}, effectFn) {
  const {
    lazy = false,
    once = false,
    initialValue,
    debounce: debounceTime,
    throttle: throttleTime
  } = options;
  let current = tag(state(proxy(initialValue)), "current");
  let loading = tag(state(false), "loading");
  let error = tag(state(void 0), "error");
  let cleanupFns = tag(state(proxy([])), "cleanupFns");
  const runCleanup = () => {
    get(cleanupFns).forEach((fn) => fn());
    set(cleanupFns, [], true);
  };
  const onCleanup2 = (fn) => {
    set(cleanupFns, [...get(cleanupFns), fn], true);
  };
  const baseFetcher = async (value, previousValue, refetching = false) => {
    try {
      set(loading, true);
      set(error, void 0);
      runCleanup();
      const controller = new AbortController();
      onCleanup2(() => controller.abort());
      const result = (await track_reactivity_loss(fetcher(value, previousValue, {
        data: get(current),
        refetching,
        onCleanup: onCleanup2,
        signal: controller.signal
      })))();
      set(current, result, true);
      return result;
    } catch (e) {
      if (!(e instanceof DOMException && strict_equals(e.name, "AbortError"))) {
        set(error, e, true);
      }
      return void 0;
    } finally {
      set(loading, false);
    }
  };
  const runFetcher = debounceTime ? debounce(baseFetcher, debounceTime) : throttleTime ? throttle(baseFetcher, throttleTime) : baseFetcher;
  const sources = Array.isArray(source) ? source : [source];
  let prevValues;
  effectFn(
    (values, previousValues) => {
      if (once && prevValues) {
        return;
      }
      prevValues = values;
      runFetcher(Array.isArray(source) ? values : values[0], Array.isArray(source) ? previousValues : previousValues?.[0]);
    },
    { lazy }
  );
  return {
    get current() {
      return get(current);
    },
    get loading() {
      return get(loading);
    },
    get error() {
      return get(error);
    },
    mutate: (value) => {
      set(current, value, true);
    },
    refetch: (info) => {
      const values = sources.map((s) => s());
      return runFetcher(Array.isArray(source) ? values : values[0], Array.isArray(source) ? values : values[0], info ?? true);
    }
  };
}
function resource(source, fetcher, options) {
  return runResource(source, fetcher, options, (fn, options2) => {
    const sources = Array.isArray(source) ? source : [source];
    const getters = () => sources.map((s) => s());
    watch(
      getters,
      (values, previousValues) => {
        fn(values, previousValues ?? []);
      },
      options2
    );
  });
}
function resourcePre(source, fetcher, options) {
  return runResource(source, fetcher, options, (fn, options2) => {
    const sources = Array.isArray(source) ? source : [source];
    const getter = () => sources.map((s) => s());
    watch.pre(
      getter,
      (values, previousValues) => {
        fn(values, previousValues ?? []);
      },
      options2
    );
  });
}
resource.pre = resourcePre;

// node_modules/.deno/runed@0.36.0/node_modules/runed/dist/utilities/scroll-state/scroll-state.svelte.js
var ARRIVED_STATE_THRESHOLD_PIXELS = 1;
var ScrollState = class {
  #options;
  #element = tag(user_derived(() => extract(this.#options.element)), "ScrollState.element");
  get element() {
    return get(this.#element);
  }
  set element(value) {
    set(this.#element, value);
  }
  #idle = tag(user_derived(() => extract(this.#options?.idle, 200)), "ScrollState.idle");
  get idle() {
    return get(this.#idle);
  }
  set idle(value) {
    set(this.#idle, value);
  }
  #offset = tag(user_derived(() => extract(this.#options.offset, { left: 0, right: 0, top: 0, bottom: 0 })), "ScrollState.offset");
  get offset() {
    return get(this.#offset);
  }
  set offset(value) {
    set(this.#offset, value);
  }
  #onScroll = tag(user_derived(() => this.#options.onScroll ?? noop), "ScrollState.onScroll");
  get onScroll() {
    return get(this.#onScroll);
  }
  set onScroll(value) {
    set(this.#onScroll, value);
  }
  #onStop = tag(user_derived(() => this.#options.onStop ?? noop), "ScrollState.onStop");
  get onStop() {
    return get(this.#onStop);
  }
  set onStop(value) {
    set(this.#onStop, value);
  }
  #eventListenerOptions = tag(user_derived(() => this.#options.eventListenerOptions ?? { capture: false, passive: true }), "ScrollState.eventListenerOptions");
  get eventListenerOptions() {
    return get(this.#eventListenerOptions);
  }
  set eventListenerOptions(value) {
    set(this.#eventListenerOptions, value);
  }
  #behavior = tag(user_derived(() => extract(this.#options.behavior, "auto")), "ScrollState.behavior");
  get behavior() {
    return get(this.#behavior);
  }
  set behavior(value) {
    set(this.#behavior, value);
  }
  #onError = tag(
    user_derived(() => this.#options.onError ?? ((e) => {
      console.error(...log_if_contains_state("error", e));
    })),
    "ScrollState.onError"
  );
  get onError() {
    return get(this.#onError);
  }
  set onError(value) {
    set(this.#onError, value);
  }
  #internalX = tag(state(0), "ScrollState.internalX");
  get internalX() {
    return get(this.#internalX);
  }
  set internalX(value) {
    set(this.#internalX, value, true);
  }
  #internalY = tag(state(0), "ScrollState.internalY");
  get internalY() {
    return get(this.#internalY);
  }
  set internalY(value) {
    set(this.#internalY, value, true);
  }
  #x = tag(user_derived(() => this.internalX), "ScrollState.#x");
  get x() {
    return get(this.#x);
  }
  set x(v) {
    this.scrollTo(v, void 0);
  }
  #y = tag(user_derived(() => this.internalY), "ScrollState.#y");
  get y() {
    return get(this.#y);
  }
  set y(v) {
    this.scrollTo(void 0, v);
  }
  #isScrolling = tag(state(false), "ScrollState.isScrolling");
  get isScrolling() {
    return get(this.#isScrolling);
  }
  set isScrolling(value) {
    set(this.#isScrolling, value, true);
  }
  #arrived = tag(state(proxy({ left: true, right: false, top: true, bottom: false })), "ScrollState.arrived");
  get arrived() {
    return get(this.#arrived);
  }
  set arrived(value) {
    set(this.#arrived, value, true);
  }
  #directions = tag(state(proxy({ left: false, right: false, top: false, bottom: false })), "ScrollState.directions");
  get directions() {
    return get(this.#directions);
  }
  set directions(value) {
    set(this.#directions, value, true);
  }
  #progress = tag(state(proxy({ x: 0, y: 0 })), "ScrollState.progress");
  get progress() {
    return get(this.#progress);
  }
  set progress(value) {
    set(this.#progress, value, true);
  }
  constructor(options) {
    this.#options = options;
    useEventListener(() => this.element, "scroll", this.#onScrollHandler, this.eventListenerOptions);
    useEventListener(() => this.element, "scrollend", (e) => this.onScrollEnd(e), this.eventListenerOptions);
    onMount(() => {
      this.setArrivedState();
    });
    new AnimationFrames(() => this.setArrivedState());
  }
  /**
   * Updates direction and edge arrival states based on the current scroll position.
   * Takes into account writing mode, flex direction, and RTL layouts.
   */
  setArrivedState = () => {
    if (!window || !this.element) return;
    const el = this.element?.document?.documentElement || this.element?.documentElement || this.element;
    const { display, flexDirection, direction } = getComputedStyle(el);
    const directionMultiplier = strict_equals(direction, "rtl") ? -1 : 1;
    const scrollLeft = el.scrollLeft;
    if (strict_equals(scrollLeft, this.internalX, false)) {
      this.directions.left = scrollLeft < this.internalX;
      this.directions.right = scrollLeft > this.internalX;
    }
    const left = scrollLeft * directionMultiplier <= (this.offset.left || 0);
    const right = scrollLeft * directionMultiplier + el.clientWidth >= el.scrollWidth - (this.offset.right || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;
    if (strict_equals(display, "flex") && strict_equals(flexDirection, "row-reverse")) {
      this.arrived.left = right;
      this.arrived.right = left;
    } else {
      this.arrived.left = left;
      this.arrived.right = right;
    }
    this.internalX = scrollLeft;
    let scrollTop = el.scrollTop;
    if (strict_equals(this.element, window.document) && !scrollTop) scrollTop = window.document.body.scrollTop;
    if (strict_equals(scrollTop, this.internalY, false)) {
      this.directions.top = scrollTop < this.internalY;
      this.directions.bottom = scrollTop > this.internalY;
    }
    const top = scrollTop <= (this.offset.top || 0);
    const bottom = scrollTop + el.clientHeight >= el.scrollHeight - (this.offset.bottom || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;
    if (strict_equals(display, "flex") && strict_equals(flexDirection, "column-reverse")) {
      this.arrived.top = bottom;
      this.arrived.bottom = top;
    } else {
      this.arrived.top = top;
      this.arrived.bottom = bottom;
    }
    const height = el.scrollHeight - (this.offset.bottom || 0);
    this.progress.y = scrollTop / (height - el.clientHeight) * 100;
    const width = el.scrollWidth - (this.offset.left || 0);
    this.progress.x = Math.abs(scrollLeft / (width - el.clientWidth) * 100);
    this.internalY = scrollTop;
  };
  #onScrollHandler = (e) => {
    if (!window) return;
    this.setArrivedState();
    this.isScrolling = true;
    this.onScrollEndDebounced(e);
    this.onScroll(e);
  };
  /**
   * Programmatically scroll to a specific position.
   */
  scrollTo(x, y) {
    if (!window) return;
    (this.element instanceof Document ? window.document.body : this.element)?.scrollTo({ top: y ?? this.y, left: x ?? this.x, behavior: this.behavior });
    const scrollContainer = this.element?.document?.documentElement || this.element?.documentElement || this.element;
    if (equals(x, null, false)) this.internalX = scrollContainer.scrollLeft;
    if (equals(y, null, false)) this.internalY = scrollContainer.scrollTop;
  }
  /**
   * Scrolls to the top of the element.
   */
  scrollToTop() {
    this.scrollTo(void 0, 0);
  }
  /**
   * Scrolls to the bottom of the element.
   */
  scrollToBottom() {
    if (!window) return;
    const scrollContainer = this.element?.document?.documentElement || this.element?.documentElement || this.element;
    if (!scrollContainer) return;
    this.scrollTo(void 0, scrollContainer.scrollHeight);
  }
  onScrollEnd = (e) => {
    if (!this.isScrolling) return;
    this.isScrolling = false;
    this.directions.left = false;
    this.directions.right = false;
    this.directions.top = false;
    this.directions.bottom = false;
    this.onStop(e);
  };
  onScrollEndDebounced = useDebounce(this.onScrollEnd, () => this.idle);
};

// node_modules/.deno/runed@0.36.0/node_modules/runed/dist/utilities/state-history/state-history.svelte.js
var StateHistory = class {
  #redoStack = tag(state(proxy([])), "StateHistory.#redoStack");
  #ignoreUpdate = false;
  #set;
  #log = tag(state(proxy([])), "StateHistory.log");
  get log() {
    return get(this.#log);
  }
  set log(value) {
    set(this.#log, value, true);
  }
  #canUndo = tag(user_derived(() => this.log.length > 1), "StateHistory.canUndo");
  get canUndo() {
    return get(this.#canUndo);
  }
  set canUndo(value) {
    set(this.#canUndo, value);
  }
  #canRedo = tag(user_derived(() => get(this.#redoStack).length > 0), "StateHistory.canRedo");
  get canRedo() {
    return get(this.#canRedo);
  }
  set canRedo(value) {
    set(this.#canRedo, value);
  }
  constructor(value, set2, options) {
    set(this.#redoStack, [], true);
    this.#set = set2;
    this.undo = this.undo.bind(this);
    this.redo = this.redo.bind(this);
    const addEvent = (event) => {
      this.log.push(event);
      const capacity$ = get2(options?.capacity);
      if (capacity$ && this.log.length > capacity$) {
        this.log = this.log.slice(-capacity$);
      }
    };
    watch(() => get2(value), (v) => {
      if (this.#ignoreUpdate) {
        this.#ignoreUpdate = false;
        return;
      }
      addEvent({ snapshot: v, timestamp: (/* @__PURE__ */ new Date()).getTime() });
      set(this.#redoStack, [], true);
    });
    watch(() => get2(options?.capacity), (c) => {
      if (!c) return;
      this.log = this.log.slice(-c);
    });
  }
  undo() {
    const [prev, curr] = this.log.slice(-2);
    if (!curr || !prev) return;
    this.#ignoreUpdate = true;
    get(this.#redoStack).push(curr);
    this.log.pop();
    this.#set(prev.snapshot);
  }
  redo() {
    const nextEvent = get(this.#redoStack).pop();
    if (!nextEvent) return;
    this.#ignoreUpdate = true;
    this.log.push(nextEvent);
    this.#set(nextEvent.snapshot);
  }
  clear() {
    this.log = [];
    set(this.#redoStack, [], true);
  }
};

// node_modules/.deno/runed@0.36.0/node_modules/runed/dist/utilities/textarea-autosize/textarea-autosize.svelte.js
var stylesToCopy = [
  "box-sizing",
  "width",
  "padding-top",
  "padding-right",
  "padding-bottom",
  "padding-left",
  "border-top-width",
  "border-right-width",
  "border-bottom-width",
  "border-left-width",
  "font-family",
  "font-size",
  "font-weight",
  "font-style",
  "letter-spacing",
  "text-indent",
  "text-transform",
  "line-height",
  "word-spacing",
  "word-wrap",
  "word-break",
  "white-space"
];
var TextareaAutosize = class {
  #options;
  #resizeTimeout = null;
  #hiddenTextarea = null;
  #element = tag(user_derived(() => extract(this.#options.element)), "TextareaAutosize.element");
  get element() {
    return get(this.#element);
  }
  set element(value) {
    set(this.#element, value);
  }
  #input = tag(user_derived(() => extract(this.#options.input)), "TextareaAutosize.input");
  get input() {
    return get(this.#input);
  }
  set input(value) {
    set(this.#input, value);
  }
  #styleProp = tag(user_derived(() => extract(this.#options.styleProp, "height")), "TextareaAutosize.styleProp");
  get styleProp() {
    return get(this.#styleProp);
  }
  set styleProp(value) {
    set(this.#styleProp, value);
  }
  #maxHeight = tag(user_derived(() => extract(this.#options.maxHeight, void 0)), "TextareaAutosize.maxHeight");
  get maxHeight() {
    return get(this.#maxHeight);
  }
  set maxHeight(value) {
    set(this.#maxHeight, value);
  }
  #textareaHeight = tag(state(0), "TextareaAutosize.textareaHeight");
  get textareaHeight() {
    return get(this.#textareaHeight);
  }
  set textareaHeight(value) {
    set(this.#textareaHeight, value, true);
  }
  #textareaOldWidth = tag(state(0), "TextareaAutosize.textareaOldWidth");
  get textareaOldWidth() {
    return get(this.#textareaOldWidth);
  }
  set textareaOldWidth(value) {
    set(this.#textareaOldWidth, value, true);
  }
  constructor(options) {
    this.#options = options;
    this.#createHiddenTextarea();
    watch([() => this.input, () => this.element], () => {
      tick().then(() => this.triggerResize());
    });
    watch(() => this.textareaHeight, () => options?.onResize?.());
    useResizeObserver(() => this.element, ([entry]) => {
      if (!entry) return;
      const { contentRect } = entry;
      if (strict_equals(this.textareaOldWidth, contentRect.width)) return;
      this.textareaOldWidth = contentRect.width;
      this.triggerResize();
    });
    user_effect(() => {
      return () => {
        if (this.#hiddenTextarea) {
          this.#hiddenTextarea.remove();
          this.#hiddenTextarea = null;
        }
        if (this.#resizeTimeout) {
          window.cancelAnimationFrame(this.#resizeTimeout);
          this.#resizeTimeout = null;
        }
      };
    });
  }
  // Copy all the styles that affect text layout
  #createHiddenTextarea() {
    if (strict_equals(typeof window, "undefined")) return;
    this.#hiddenTextarea = document.createElement("textarea");
    const style = this.#hiddenTextarea.style;
    style.visibility = "hidden";
    style.position = "absolute";
    style.overflow = "hidden";
    style.height = "0";
    style.top = "0";
    style.left = "-9999px";
    document.body.appendChild(this.#hiddenTextarea);
  }
  #copyStyles() {
    if (!this.element || !this.#hiddenTextarea) return;
    const computed = window.getComputedStyle(this.element);
    for (const style of stylesToCopy) {
      this.#hiddenTextarea.style.setProperty(style, computed.getPropertyValue(style));
    }
    this.#hiddenTextarea.style.width = `${this.element.clientWidth}px`;
  }
  /**
   * Recomputes the required height based on current content and applies it
   * to the textarea. If `maxHeight` is exceeded, vertical scrolling is enabled.
   */
  triggerResize = () => {
    if (!this.element || !this.#hiddenTextarea) return;
    this.#copyStyles();
    this.#hiddenTextarea.value = this.input || "";
    const scrollHeight = this.#hiddenTextarea.scrollHeight;
    let newHeight = scrollHeight;
    if (this.maxHeight && newHeight > this.maxHeight) {
      newHeight = this.maxHeight;
      this.element.style.overflowY = "auto";
    } else {
      this.element.style.overflowY = "hidden";
    }
    if (strict_equals(this.textareaHeight, newHeight, false)) {
      this.textareaHeight = newHeight;
      this.element.style[this.styleProp] = `${newHeight}px`;
    }
  };
};

// node_modules/.deno/runed@0.36.0/node_modules/runed/dist/utilities/use-throttle/use-throttle.svelte.js
function useThrottle(callback, interval = 250) {
  let lastCall = 0;
  let timeout = tag(state(void 0), "timeout");
  let resolve = null;
  let reject = null;
  let promise = null;
  function reset() {
    set(timeout, void 0);
    promise = null;
    resolve = null;
    reject = null;
  }
  function throttled(...args) {
    return untrack(() => {
      const now = Date.now();
      const intervalValue = strict_equals(typeof interval, "function") ? interval() : interval;
      const nextAllowedTime = lastCall + intervalValue;
      if (!promise) {
        promise = new Promise((res, rej) => {
          resolve = res;
          reject = rej;
        });
      }
      if (now < nextAllowedTime) {
        if (!get(timeout)) {
          set(
            timeout,
            setTimeout(
              async () => {
                try {
                  const result = (await track_reactivity_loss(callback.apply(this, args)))();
                  resolve?.(result);
                } catch (error) {
                  reject?.(error);
                } finally {
                  clearTimeout(get(timeout));
                  reset();
                  lastCall = Date.now();
                }
              },
              nextAllowedTime - now
            ),
            true
          );
        }
        return promise;
      }
      if (get(timeout)) {
        clearTimeout(get(timeout));
        set(timeout, void 0);
      }
      lastCall = now;
      try {
        const result = callback.apply(this, args);
        resolve?.(result);
      } catch (error) {
        reject?.(error);
      } finally {
        reset();
      }
      return promise;
    });
  }
  throttled.cancel = async () => {
    if (get(timeout)) {
      if (strict_equals(get(timeout), void 0)) {
        (await track_reactivity_loss(new Promise((resolve2) => setTimeout(resolve2, 0))))();
        if (strict_equals(get(timeout), void 0)) return;
      }
      clearTimeout(get(timeout));
      reject?.("Cancelled");
      reset();
    }
  };
  Object.defineProperty(throttled, "pending", {
    enumerable: true,
    get() {
      return !!get(timeout);
    }
  });
  return throttled;
}

// node_modules/.deno/runed@0.36.0/node_modules/runed/dist/utilities/throttled/throttled.svelte.js
var Throttled = class {
  #current = tag(state(), "Throttled.#current");
  #throttleFn;
  constructor(getter, wait = 250) {
    set(
      this.#current,
      getter(),
      // Immediately set the initial value
      true
    );
    this.#throttleFn = useThrottle(
      () => {
        set(this.#current, getter(), true);
      },
      wait
    );
    watch(getter, () => {
      this.#throttleFn()?.catch(noop);
    });
  }
  get current() {
    return get(this.#current);
  }
  cancel() {
    this.#throttleFn.cancel();
  }
  setImmediately(v) {
    this.cancel();
    set(this.#current, v, true);
  }
};

// node_modules/.deno/runed@0.36.0/node_modules/runed/dist/utilities/use-geolocation/use-geolocation.svelte.js
function useGeolocation(options = {}) {
  const {
    enableHighAccuracy = true,
    maximumAge = 3e4,
    timeout = 27e3,
    immediate = true,
    navigator = defaultNavigator
  } = options;
  const isSupported = Boolean(navigator);
  let error = tag(state(null), "error");
  let position = tag_proxy(
    proxy({
      timestamp: 0,
      coords: {
        accuracy: 0,
        latitude: Number.POSITIVE_INFINITY,
        longitude: Number.POSITIVE_INFINITY,
        altitude: null,
        altitudeAccuracy: null,
        heading: null,
        speed: null
      }
    }),
    "position"
  );
  let isPaused = tag(state(false), "isPaused");
  function updatePosition(_position) {
    set(error, null);
    position.timestamp = _position.timestamp;
    position.coords.accuracy = _position.coords.accuracy;
    position.coords.altitude = _position.coords.altitude;
    position.coords.altitudeAccuracy = _position.coords.altitudeAccuracy;
    position.coords.heading = _position.coords.heading;
    position.coords.latitude = _position.coords.latitude;
    position.coords.longitude = _position.coords.longitude;
    position.coords.speed = _position.coords.speed;
  }
  let watcher;
  function resume() {
    if (!navigator) return;
    watcher = navigator.geolocation.watchPosition(updatePosition, (err) => set(error, err), { enableHighAccuracy, maximumAge, timeout });
    set(isPaused, false);
  }
  function pause() {
    if (watcher && navigator) {
      navigator.geolocation.clearWatch(watcher);
    }
    set(isPaused, true);
  }
  user_effect(() => {
    if (immediate) resume();
    return () => pause();
  });
  return {
    get isSupported() {
      return isSupported;
    },
    position,
    get error() {
      return get(error);
    },
    get isPaused() {
      return get(isPaused);
    },
    resume,
    pause
  };
}

// node_modules/.deno/runed@0.36.0/node_modules/runed/dist/utilities/use-interval/use-interval.svelte.js
function useInterval(delay, options = {}) {
  const { immediate = true, immediateCallback = false, callback } = options;
  let intervalId = tag(state(null), "intervalId");
  let counter = tag(state(0), "counter");
  const delay$ = tag(user_derived(() => extract(delay)), "delay$");
  const isActive = tag(user_derived(() => strict_equals(get(intervalId), null, false)), "isActive");
  function runCallback() {
    update(counter);
    callback?.(get(counter));
  }
  function createInterval() {
    set(intervalId, setInterval(runCallback, get(delay$)), true);
  }
  const pause = () => {
    if (strict_equals(get(intervalId), null)) return;
    clearInterval(get(intervalId));
    set(intervalId, null);
  };
  const resume = () => {
    if (strict_equals(get(intervalId), null, false)) return;
    if (immediateCallback) runCallback();
    createInterval();
  };
  if (immediate) {
    resume();
  }
  watch(() => get(delay$), () => {
    if (!get(isActive)) return;
    pause();
    createInterval();
  });
  user_effect(() => pause);
  return {
    pause,
    resume,
    reset: () => set(counter, 0),
    get isActive() {
      return get(isActive);
    },
    get counter() {
      return get(counter);
    }
  };
}

// node_modules/.deno/runed@0.36.0/node_modules/runed/dist/utilities/bool-attr/bool-attr.js
function boolAttr(value) {
  return value ? "" : void 0;
}

// node_modules/.deno/runed@0.36.0/node_modules/runed/dist/utilities/on-cleanup/on-cleanup.svelte.js
function onCleanup(cb) {
  user_effect(() => {
    return () => {
      cb();
    };
  });
}
export {
  ActiveElement,
  AnimationFrames,
  Context,
  Debounced,
  ElementRect,
  ElementSize,
  FiniteStateMachine,
  IsDocumentVisible,
  IsFocusWithin,
  IsIdle,
  IsInViewport,
  IsMounted,
  PersistedState,
  PressedKeys,
  Previous,
  ScrollState,
  StateHistory,
  TextareaAutosize,
  Throttled,
  activeElement,
  boolAttr,
  extract,
  isLifecycleFnMeta,
  onCleanup,
  onClickOutside,
  resource,
  resourcePre,
  useDebounce,
  useEventListener,
  useGeolocation,
  useIntersectionObserver,
  useInterval,
  useMutationObserver,
  useResizeObserver,
  useThrottle,
  watch,
  watchOnce
};
//# sourceMappingURL=runed.js.map
