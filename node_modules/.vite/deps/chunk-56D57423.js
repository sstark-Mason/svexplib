import {
  require_path
} from "./chunk-BIZQ5KI4.js";
import {
  is_reserved,
  is_void
} from "./chunk-CF22RCOR.js";
import {
  HYDRATION_END,
  HYDRATION_START,
  HYDRATION_START_ELSE,
  IGNORABLE_RUNTIME_WARNINGS,
  NAMESPACE_MATHML,
  NAMESPACE_SVG
} from "./chunk-75PMGCXJ.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/util/iteratorProxy.js
var require_iteratorProxy = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/util/iteratorProxy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    function iteratorProxy() {
      var values = this;
      var index2 = 0;
      var iter = {
        "@@iterator": function iterator() {
          return iter;
        },
        next: function next2() {
          if (index2 < values.length) {
            var value = values[index2];
            index2 = index2 + 1;
            return {
              done: false,
              value
            };
          } else {
            return {
              done: true
            };
          }
        }
      };
      return iter;
    }
    var _default = exports.default = iteratorProxy;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/util/iterationDecorator.js
var require_iterationDecorator = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/util/iterationDecorator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = iterationDecorator;
    var _iteratorProxy = _interopRequireDefault(require_iteratorProxy());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function iterationDecorator(collection, entries) {
      if (typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol") {
        Object.defineProperty(collection, Symbol.iterator, {
          value: _iteratorProxy.default.bind(entries)
        });
      }
      return collection;
    }
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/ariaPropsMap.js
var require_ariaPropsMap = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/ariaPropsMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    function _slicedToArray(r, e2) {
      return _arrayWithHoles(r) || _iterableToArrayLimit(r, e2) || _unsupportedIterableToArray(r, e2) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e2 = 0, n = Array(a); e2 < a; e2++) n[e2] = r[e2];
      return n;
    }
    function _iterableToArrayLimit(r, l2) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e2, n, i, u2, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l2) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e2 = i.call(t)).done) && (a.push(e2.value), a.length !== l2); f = true) ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t.return && (u2 = t.return(), Object(u2) !== u2)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(r) {
      if (Array.isArray(r)) return r;
    }
    var properties = [["aria-activedescendant", {
      "type": "id"
    }], ["aria-atomic", {
      "type": "boolean"
    }], ["aria-autocomplete", {
      "type": "token",
      "values": ["inline", "list", "both", "none"]
    }], ["aria-braillelabel", {
      "type": "string"
    }], ["aria-brailleroledescription", {
      "type": "string"
    }], ["aria-busy", {
      "type": "boolean"
    }], ["aria-checked", {
      "type": "tristate"
    }], ["aria-colcount", {
      type: "integer"
    }], ["aria-colindex", {
      type: "integer"
    }], ["aria-colspan", {
      type: "integer"
    }], ["aria-controls", {
      "type": "idlist"
    }], ["aria-current", {
      type: "token",
      values: ["page", "step", "location", "date", "time", true, false]
    }], ["aria-describedby", {
      "type": "idlist"
    }], ["aria-description", {
      "type": "string"
    }], ["aria-details", {
      "type": "id"
    }], ["aria-disabled", {
      "type": "boolean"
    }], ["aria-dropeffect", {
      "type": "tokenlist",
      "values": ["copy", "execute", "link", "move", "none", "popup"]
    }], ["aria-errormessage", {
      "type": "id"
    }], ["aria-expanded", {
      "type": "boolean",
      "allowundefined": true
    }], ["aria-flowto", {
      "type": "idlist"
    }], ["aria-grabbed", {
      "type": "boolean",
      "allowundefined": true
    }], ["aria-haspopup", {
      "type": "token",
      "values": [false, true, "menu", "listbox", "tree", "grid", "dialog"]
    }], ["aria-hidden", {
      "type": "boolean",
      "allowundefined": true
    }], ["aria-invalid", {
      "type": "token",
      "values": ["grammar", false, "spelling", true]
    }], ["aria-keyshortcuts", {
      type: "string"
    }], ["aria-label", {
      "type": "string"
    }], ["aria-labelledby", {
      "type": "idlist"
    }], ["aria-level", {
      "type": "integer"
    }], ["aria-live", {
      "type": "token",
      "values": ["assertive", "off", "polite"]
    }], ["aria-modal", {
      type: "boolean"
    }], ["aria-multiline", {
      "type": "boolean"
    }], ["aria-multiselectable", {
      "type": "boolean"
    }], ["aria-orientation", {
      "type": "token",
      "values": ["vertical", "undefined", "horizontal"]
    }], ["aria-owns", {
      "type": "idlist"
    }], ["aria-placeholder", {
      type: "string"
    }], ["aria-posinset", {
      "type": "integer"
    }], ["aria-pressed", {
      "type": "tristate"
    }], ["aria-readonly", {
      "type": "boolean"
    }], ["aria-relevant", {
      "type": "tokenlist",
      "values": ["additions", "all", "removals", "text"]
    }], ["aria-required", {
      "type": "boolean"
    }], ["aria-roledescription", {
      type: "string"
    }], ["aria-rowcount", {
      type: "integer"
    }], ["aria-rowindex", {
      type: "integer"
    }], ["aria-rowspan", {
      type: "integer"
    }], ["aria-selected", {
      "type": "boolean",
      "allowundefined": true
    }], ["aria-setsize", {
      "type": "integer"
    }], ["aria-sort", {
      "type": "token",
      "values": ["ascending", "descending", "none", "other"]
    }], ["aria-valuemax", {
      "type": "number"
    }], ["aria-valuemin", {
      "type": "number"
    }], ["aria-valuenow", {
      "type": "number"
    }], ["aria-valuetext", {
      "type": "string"
    }]];
    var ariaPropsMap = {
      entries: function entries() {
        return properties;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        for (var _i = 0, _properties = properties; _i < _properties.length; _i++) {
          var _properties$_i = _slicedToArray(_properties[_i], 2), key2 = _properties$_i[0], values = _properties$_i[1];
          fn.call(thisArg, values, key2, properties);
        }
      },
      get: function get2(key2) {
        var item = properties.filter(function(tuple) {
          return tuple[0] === key2 ? true : false;
        })[0];
        return item && item[1];
      },
      has: function has(key2) {
        return !!ariaPropsMap.get(key2);
      },
      keys: function keys2() {
        return properties.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key2 = _ref2[0];
          return key2;
        });
      },
      values: function values() {
        return properties.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = exports.default = (0, _iterationDecorator.default)(ariaPropsMap, ariaPropsMap.entries());
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/domMap.js
var require_domMap = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/domMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    function _slicedToArray(r, e2) {
      return _arrayWithHoles(r) || _iterableToArrayLimit(r, e2) || _unsupportedIterableToArray(r, e2) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e2 = 0, n = Array(a); e2 < a; e2++) n[e2] = r[e2];
      return n;
    }
    function _iterableToArrayLimit(r, l2) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e2, n, i, u2, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l2) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e2 = i.call(t)).done) && (a.push(e2.value), a.length !== l2); f = true) ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t.return && (u2 = t.return(), Object(u2) !== u2)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(r) {
      if (Array.isArray(r)) return r;
    }
    var dom = [["a", {
      reserved: false
    }], ["abbr", {
      reserved: false
    }], ["acronym", {
      reserved: false
    }], ["address", {
      reserved: false
    }], ["applet", {
      reserved: false
    }], ["area", {
      reserved: false
    }], ["article", {
      reserved: false
    }], ["aside", {
      reserved: false
    }], ["audio", {
      reserved: false
    }], ["b", {
      reserved: false
    }], ["base", {
      reserved: true
    }], ["bdi", {
      reserved: false
    }], ["bdo", {
      reserved: false
    }], ["big", {
      reserved: false
    }], ["blink", {
      reserved: false
    }], ["blockquote", {
      reserved: false
    }], ["body", {
      reserved: false
    }], ["br", {
      reserved: false
    }], ["button", {
      reserved: false
    }], ["canvas", {
      reserved: false
    }], ["caption", {
      reserved: false
    }], ["center", {
      reserved: false
    }], ["cite", {
      reserved: false
    }], ["code", {
      reserved: false
    }], ["col", {
      reserved: true
    }], ["colgroup", {
      reserved: true
    }], ["content", {
      reserved: false
    }], ["data", {
      reserved: false
    }], ["datalist", {
      reserved: false
    }], ["dd", {
      reserved: false
    }], ["del", {
      reserved: false
    }], ["details", {
      reserved: false
    }], ["dfn", {
      reserved: false
    }], ["dialog", {
      reserved: false
    }], ["dir", {
      reserved: false
    }], ["div", {
      reserved: false
    }], ["dl", {
      reserved: false
    }], ["dt", {
      reserved: false
    }], ["em", {
      reserved: false
    }], ["embed", {
      reserved: false
    }], ["fieldset", {
      reserved: false
    }], ["figcaption", {
      reserved: false
    }], ["figure", {
      reserved: false
    }], ["font", {
      reserved: false
    }], ["footer", {
      reserved: false
    }], ["form", {
      reserved: false
    }], ["frame", {
      reserved: false
    }], ["frameset", {
      reserved: false
    }], ["h1", {
      reserved: false
    }], ["h2", {
      reserved: false
    }], ["h3", {
      reserved: false
    }], ["h4", {
      reserved: false
    }], ["h5", {
      reserved: false
    }], ["h6", {
      reserved: false
    }], ["head", {
      reserved: true
    }], ["header", {
      reserved: false
    }], ["hgroup", {
      reserved: false
    }], ["hr", {
      reserved: false
    }], ["html", {
      reserved: true
    }], ["i", {
      reserved: false
    }], ["iframe", {
      reserved: false
    }], ["img", {
      reserved: false
    }], ["input", {
      reserved: false
    }], ["ins", {
      reserved: false
    }], ["kbd", {
      reserved: false
    }], ["keygen", {
      reserved: false
    }], ["label", {
      reserved: false
    }], ["legend", {
      reserved: false
    }], ["li", {
      reserved: false
    }], ["link", {
      reserved: true
    }], ["main", {
      reserved: false
    }], ["map", {
      reserved: false
    }], ["mark", {
      reserved: false
    }], ["marquee", {
      reserved: false
    }], ["menu", {
      reserved: false
    }], ["menuitem", {
      reserved: false
    }], ["meta", {
      reserved: true
    }], ["meter", {
      reserved: false
    }], ["nav", {
      reserved: false
    }], ["noembed", {
      reserved: true
    }], ["noscript", {
      reserved: true
    }], ["object", {
      reserved: false
    }], ["ol", {
      reserved: false
    }], ["optgroup", {
      reserved: false
    }], ["option", {
      reserved: false
    }], ["output", {
      reserved: false
    }], ["p", {
      reserved: false
    }], ["param", {
      reserved: true
    }], ["picture", {
      reserved: true
    }], ["pre", {
      reserved: false
    }], ["progress", {
      reserved: false
    }], ["q", {
      reserved: false
    }], ["rp", {
      reserved: false
    }], ["rt", {
      reserved: false
    }], ["rtc", {
      reserved: false
    }], ["ruby", {
      reserved: false
    }], ["s", {
      reserved: false
    }], ["samp", {
      reserved: false
    }], ["script", {
      reserved: true
    }], ["section", {
      reserved: false
    }], ["select", {
      reserved: false
    }], ["small", {
      reserved: false
    }], ["source", {
      reserved: true
    }], ["spacer", {
      reserved: false
    }], ["span", {
      reserved: false
    }], ["strike", {
      reserved: false
    }], ["strong", {
      reserved: false
    }], ["style", {
      reserved: true
    }], ["sub", {
      reserved: false
    }], ["summary", {
      reserved: false
    }], ["sup", {
      reserved: false
    }], ["table", {
      reserved: false
    }], ["tbody", {
      reserved: false
    }], ["td", {
      reserved: false
    }], ["textarea", {
      reserved: false
    }], ["tfoot", {
      reserved: false
    }], ["th", {
      reserved: false
    }], ["thead", {
      reserved: false
    }], ["time", {
      reserved: false
    }], ["title", {
      reserved: true
    }], ["tr", {
      reserved: false
    }], ["track", {
      reserved: true
    }], ["tt", {
      reserved: false
    }], ["u", {
      reserved: false
    }], ["ul", {
      reserved: false
    }], ["var", {
      reserved: false
    }], ["video", {
      reserved: false
    }], ["wbr", {
      reserved: false
    }], ["xmp", {
      reserved: false
    }]];
    var domMap = {
      entries: function entries() {
        return dom;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        for (var _i = 0, _dom = dom; _i < _dom.length; _i++) {
          var _dom$_i = _slicedToArray(_dom[_i], 2), key2 = _dom$_i[0], values = _dom$_i[1];
          fn.call(thisArg, values, key2, dom);
        }
      },
      get: function get2(key2) {
        var item = dom.filter(function(tuple) {
          return tuple[0] === key2 ? true : false;
        })[0];
        return item && item[1];
      },
      has: function has(key2) {
        return !!domMap.get(key2);
      },
      keys: function keys2() {
        return dom.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key2 = _ref2[0];
          return key2;
        });
      },
      values: function values() {
        return dom.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = exports.default = (0, _iterationDecorator.default)(domMap, domMap.entries());
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/commandRole.js
var require_commandRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/commandRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var commandRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget"]]
    };
    var _default = exports.default = commandRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/compositeRole.js
var require_compositeRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/compositeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var compositeRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-disabled": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget"]]
    };
    var _default = exports.default = compositeRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/inputRole.js
var require_inputRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/inputRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var inputRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null
      },
      relatedConcepts: [{
        concept: {
          name: "input"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget"]]
    };
    var _default = exports.default = inputRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/landmarkRole.js
var require_landmarkRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/landmarkRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var landmarkRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = landmarkRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/rangeRole.js
var require_rangeRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/rangeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var rangeRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-valuemax": null,
        "aria-valuemin": null,
        "aria-valuenow": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = exports.default = rangeRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/roletypeRole.js
var require_roletypeRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/roletypeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var roletypeRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [],
      prohibitedProps: [],
      props: {
        "aria-atomic": null,
        "aria-busy": null,
        "aria-controls": null,
        "aria-current": null,
        "aria-describedby": null,
        "aria-details": null,
        "aria-dropeffect": null,
        "aria-flowto": null,
        "aria-grabbed": null,
        "aria-hidden": null,
        "aria-keyshortcuts": null,
        "aria-label": null,
        "aria-labelledby": null,
        "aria-live": null,
        "aria-owns": null,
        "aria-relevant": null,
        "aria-roledescription": null
      },
      relatedConcepts: [{
        concept: {
          name: "role"
        },
        module: "XHTML"
      }, {
        concept: {
          name: "type"
        },
        module: "Dublin Core"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: []
    };
    var _default = exports.default = roletypeRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/sectionRole.js
var require_sectionRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/sectionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var sectionRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "frontmatter"
        },
        module: "DTB"
      }, {
        concept: {
          name: "level"
        },
        module: "DTB"
      }, {
        concept: {
          name: "level"
        },
        module: "SMIL"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = exports.default = sectionRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/sectionheadRole.js
var require_sectionheadRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/sectionheadRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var sectionheadRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = exports.default = sectionheadRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/selectRole.js
var require_selectRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/selectRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var selectRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"], ["roletype", "structure", "section", "group"]]
    };
    var _default = exports.default = selectRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/structureRole.js
var require_structureRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/structureRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var structureRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype"]]
    };
    var _default = exports.default = structureRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/widgetRole.js
var require_widgetRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/widgetRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var widgetRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype"]]
    };
    var _default = exports.default = widgetRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/windowRole.js
var require_windowRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/abstract/windowRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var windowRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-modal": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype"]]
    };
    var _default = exports.default = windowRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/ariaAbstractRoles.js
var require_ariaAbstractRoles = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/ariaAbstractRoles.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _commandRole = _interopRequireDefault(require_commandRole());
    var _compositeRole = _interopRequireDefault(require_compositeRole());
    var _inputRole = _interopRequireDefault(require_inputRole());
    var _landmarkRole = _interopRequireDefault(require_landmarkRole());
    var _rangeRole = _interopRequireDefault(require_rangeRole());
    var _roletypeRole = _interopRequireDefault(require_roletypeRole());
    var _sectionRole = _interopRequireDefault(require_sectionRole());
    var _sectionheadRole = _interopRequireDefault(require_sectionheadRole());
    var _selectRole = _interopRequireDefault(require_selectRole());
    var _structureRole = _interopRequireDefault(require_structureRole());
    var _widgetRole = _interopRequireDefault(require_widgetRole());
    var _windowRole = _interopRequireDefault(require_windowRole());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    var ariaAbstractRoles = [["command", _commandRole.default], ["composite", _compositeRole.default], ["input", _inputRole.default], ["landmark", _landmarkRole.default], ["range", _rangeRole.default], ["roletype", _roletypeRole.default], ["section", _sectionRole.default], ["sectionhead", _sectionheadRole.default], ["select", _selectRole.default], ["structure", _structureRole.default], ["widget", _widgetRole.default], ["window", _windowRole.default]];
    var _default = exports.default = ariaAbstractRoles;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/alertRole.js
var require_alertRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/alertRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var alertRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-atomic": "true",
        "aria-live": "assertive"
      },
      relatedConcepts: [{
        concept: {
          name: "alert"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = alertRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/alertdialogRole.js
var require_alertdialogRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/alertdialogRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var alertdialogRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "alert"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "alert"], ["roletype", "window", "dialog"]]
    };
    var _default = exports.default = alertdialogRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/applicationRole.js
var require_applicationRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/applicationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var applicationRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "Device Independence Delivery Unit"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = exports.default = applicationRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/articleRole.js
var require_articleRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/articleRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var articleRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          name: "article"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "document"]]
    };
    var _default = exports.default = articleRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/bannerRole.js
var require_bannerRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/bannerRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var bannerRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          constraints: ["scoped to the body element"],
          name: "header"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = bannerRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/blockquoteRole.js
var require_blockquoteRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/blockquoteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var blockquoteRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "blockquote"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = blockquoteRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/buttonRole.js
var require_buttonRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/buttonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var buttonRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-pressed": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "button"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "type",
            value: "image"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "type",
            value: "reset"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "type",
            value: "submit"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          name: "button"
        },
        module: "HTML"
      }, {
        concept: {
          name: "trigger"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command"]]
    };
    var _default = exports.default = buttonRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/captionRole.js
var require_captionRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/captionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var captionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "caption"
        },
        module: "HTML"
      }],
      requireContextRole: ["figure", "grid", "table"],
      requiredContextRole: ["figure", "grid", "table"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = captionRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/cellRole.js
var require_cellRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/cellRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var cellRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-colindex": null,
        "aria-colspan": null,
        "aria-rowindex": null,
        "aria-rowspan": null
      },
      relatedConcepts: [{
        concept: {
          constraints: ["ancestor table element has table role"],
          name: "td"
        },
        module: "HTML"
      }],
      requireContextRole: ["row"],
      requiredContextRole: ["row"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = cellRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/checkboxRole.js
var require_checkboxRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/checkboxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var checkboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-checked": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "checkbox"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          name: "option"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input"]]
    };
    var _default = exports.default = checkboxRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/codeRole.js
var require_codeRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/codeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var codeRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "code"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = codeRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/columnheaderRole.js
var require_columnheaderRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/columnheaderRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var columnheaderRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-sort": null
      },
      relatedConcepts: [{
        concept: {
          name: "th"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "scope",
            value: "col"
          }],
          name: "th"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "scope",
            value: "colgroup"
          }],
          name: "th"
        },
        module: "HTML"
      }],
      requireContextRole: ["row"],
      requiredContextRole: ["row"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "cell"], ["roletype", "structure", "section", "cell", "gridcell"], ["roletype", "widget", "gridcell"], ["roletype", "structure", "sectionhead"]]
    };
    var _default = exports.default = columnheaderRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/comboboxRole.js
var require_comboboxRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/comboboxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var comboboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-autocomplete": null,
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-expanded": "false",
        "aria-haspopup": "listbox"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "email"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "search"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "tel"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "text"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "url"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "list"
          }, {
            name: "type",
            value: "url"
          }],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "multiple"
          }, {
            constraints: ["undefined"],
            name: "size"
          }],
          constraints: ["the multiple attribute is not set and the size attribute does not have a value greater than 1"],
          name: "select"
        },
        module: "HTML"
      }, {
        concept: {
          name: "select"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-controls": null,
        "aria-expanded": "false"
      },
      superClass: [["roletype", "widget", "input"]]
    };
    var _default = exports.default = comboboxRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/complementaryRole.js
var require_complementaryRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/complementaryRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var complementaryRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          constraints: ["scoped to the body element", "scoped to the main element"],
          name: "aside"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-label"
          }],
          constraints: ["scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "aside"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-labelledby"
          }],
          constraints: ["scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "aside"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = complementaryRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/contentinfoRole.js
var require_contentinfoRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/contentinfoRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var contentinfoRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          constraints: ["scoped to the body element"],
          name: "footer"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = contentinfoRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/definitionRole.js
var require_definitionRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/definitionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var definitionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "dd"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = definitionRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/deletionRole.js
var require_deletionRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/deletionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var deletionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "del"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = deletionRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/dialogRole.js
var require_dialogRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/dialogRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var dialogRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "dialog"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "window"]]
    };
    var _default = exports.default = dialogRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/directoryRole.js
var require_directoryRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/directoryRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var directoryRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        module: "DAISY Guide"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "list"]]
    };
    var _default = exports.default = directoryRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/documentRole.js
var require_documentRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/documentRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var documentRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "Device Independence Delivery Unit"
        }
      }, {
        concept: {
          name: "html"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = exports.default = documentRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/emphasisRole.js
var require_emphasisRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/emphasisRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var emphasisRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "em"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = emphasisRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/feedRole.js
var require_feedRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/feedRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var feedRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["article"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "list"]]
    };
    var _default = exports.default = feedRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/figureRole.js
var require_figureRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/figureRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var figureRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "figure"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = figureRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/formRole.js
var require_formRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/formRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var formRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-label"
          }],
          name: "form"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-labelledby"
          }],
          name: "form"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "name"
          }],
          name: "form"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = formRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/genericRole.js
var require_genericRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/genericRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var genericRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "a"
        },
        module: "HTML"
      }, {
        concept: {
          name: "area"
        },
        module: "HTML"
      }, {
        concept: {
          name: "aside"
        },
        module: "HTML"
      }, {
        concept: {
          name: "b"
        },
        module: "HTML"
      }, {
        concept: {
          name: "bdo"
        },
        module: "HTML"
      }, {
        concept: {
          name: "body"
        },
        module: "HTML"
      }, {
        concept: {
          name: "data"
        },
        module: "HTML"
      }, {
        concept: {
          name: "div"
        },
        module: "HTML"
      }, {
        concept: {
          constraints: ["scoped to the main element", "scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "footer"
        },
        module: "HTML"
      }, {
        concept: {
          constraints: ["scoped to the main element", "scoped to a sectioning content element", "scoped to a sectioning root element other than body"],
          name: "header"
        },
        module: "HTML"
      }, {
        concept: {
          name: "hgroup"
        },
        module: "HTML"
      }, {
        concept: {
          name: "i"
        },
        module: "HTML"
      }, {
        concept: {
          name: "pre"
        },
        module: "HTML"
      }, {
        concept: {
          name: "q"
        },
        module: "HTML"
      }, {
        concept: {
          name: "samp"
        },
        module: "HTML"
      }, {
        concept: {
          name: "section"
        },
        module: "HTML"
      }, {
        concept: {
          name: "small"
        },
        module: "HTML"
      }, {
        concept: {
          name: "span"
        },
        module: "HTML"
      }, {
        concept: {
          name: "u"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = exports.default = genericRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/gridRole.js
var require_gridRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/gridRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var gridRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-multiselectable": null,
        "aria-readonly": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["row"], ["row", "rowgroup"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"], ["roletype", "structure", "section", "table"]]
    };
    var _default = exports.default = gridRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/gridcellRole.js
var require_gridcellRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/gridcellRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var gridcellRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-selected": null
      },
      relatedConcepts: [{
        concept: {
          constraints: ["ancestor table element has grid role", "ancestor table element has treegrid role"],
          name: "td"
        },
        module: "HTML"
      }],
      requireContextRole: ["row"],
      requiredContextRole: ["row"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "cell"], ["roletype", "widget"]]
    };
    var _default = exports.default = gridcellRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/groupRole.js
var require_groupRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/groupRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var groupRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-disabled": null
      },
      relatedConcepts: [{
        concept: {
          name: "details"
        },
        module: "HTML"
      }, {
        concept: {
          name: "fieldset"
        },
        module: "HTML"
      }, {
        concept: {
          name: "optgroup"
        },
        module: "HTML"
      }, {
        concept: {
          name: "address"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = groupRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/headingRole.js
var require_headingRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/headingRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var headingRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-level": "2"
      },
      relatedConcepts: [{
        concept: {
          name: "h1"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h2"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h3"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h4"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h5"
        },
        module: "HTML"
      }, {
        concept: {
          name: "h6"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-level": "2"
      },
      superClass: [["roletype", "structure", "sectionhead"]]
    };
    var _default = exports.default = headingRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/imgRole.js
var require_imgRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/imgRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var imgRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "alt"
          }],
          name: "img"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "alt"
          }],
          name: "img"
        },
        module: "HTML"
      }, {
        concept: {
          name: "imggroup"
        },
        module: "DTB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = imgRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/insertionRole.js
var require_insertionRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/insertionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var insertionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "ins"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = insertionRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/linkRole.js
var require_linkRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/linkRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var linkRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "href"
          }],
          name: "a"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "href"
          }],
          name: "area"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command"]]
    };
    var _default = exports.default = linkRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/listRole.js
var require_listRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/listRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var listRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "menu"
        },
        module: "HTML"
      }, {
        concept: {
          name: "ol"
        },
        module: "HTML"
      }, {
        concept: {
          name: "ul"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["listitem"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = listRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/listboxRole.js
var require_listboxRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/listboxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var listboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-invalid": null,
        "aria-multiselectable": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-orientation": "vertical"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: [">1"],
            name: "size"
          }],
          constraints: ["the size attribute value is greater than 1"],
          name: "select"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "multiple"
          }],
          name: "select"
        },
        module: "HTML"
      }, {
        concept: {
          name: "datalist"
        },
        module: "HTML"
      }, {
        concept: {
          name: "list"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "select"
        },
        module: "XForms"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["option", "group"], ["option"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    };
    var _default = exports.default = listboxRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/listitemRole.js
var require_listitemRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/listitemRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var listitemRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-level": null,
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          constraints: ["direct descendant of ol", "direct descendant of ul", "direct descendant of menu"],
          name: "li"
        },
        module: "HTML"
      }, {
        concept: {
          name: "item"
        },
        module: "XForms"
      }],
      requireContextRole: ["directory", "list"],
      requiredContextRole: ["directory", "list"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = listitemRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/logRole.js
var require_logRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/logRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var logRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-live": "polite"
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = logRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/mainRole.js
var require_mainRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/mainRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var mainRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "main"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = mainRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/markRole.js
var require_markRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/markRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var markRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: [],
      props: {
        "aria-braillelabel": null,
        "aria-brailleroledescription": null,
        "aria-description": null
      },
      relatedConcepts: [{
        concept: {
          name: "mark"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = markRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/marqueeRole.js
var require_marqueeRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/marqueeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var marqueeRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = marqueeRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/mathRole.js
var require_mathRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/mathRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var mathRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "math"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = mathRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/menuRole.js
var require_menuRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/menuRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var menuRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": "vertical"
      },
      relatedConcepts: [{
        concept: {
          name: "MENU"
        },
        module: "JAPI"
      }, {
        concept: {
          name: "list"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "select"
        },
        module: "XForms"
      }, {
        concept: {
          name: "sidebar"
        },
        module: "DTB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["menuitem", "group"], ["menuitemradio", "group"], ["menuitemcheckbox", "group"], ["menuitem"], ["menuitemcheckbox"], ["menuitemradio"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    };
    var _default = exports.default = menuRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/menubarRole.js
var require_menubarRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/menubarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var menubarRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": "horizontal"
      },
      relatedConcepts: [{
        concept: {
          name: "toolbar"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["menuitem", "group"], ["menuitemradio", "group"], ["menuitemcheckbox", "group"], ["menuitem"], ["menuitemcheckbox"], ["menuitemradio"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select", "menu"], ["roletype", "structure", "section", "group", "select", "menu"]]
    };
    var _default = exports.default = menubarRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/menuitemRole.js
var require_menuitemRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/menuitemRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var menuitemRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          name: "MENU_ITEM"
        },
        module: "JAPI"
      }, {
        concept: {
          name: "listitem"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "option"
        },
        module: "ARIA"
      }],
      requireContextRole: ["group", "menu", "menubar"],
      requiredContextRole: ["group", "menu", "menubar"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command"]]
    };
    var _default = exports.default = menuitemRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/menuitemcheckboxRole.js
var require_menuitemcheckboxRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/menuitemcheckboxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var menuitemcheckboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "menuitem"
        },
        module: "ARIA"
      }],
      requireContextRole: ["group", "menu", "menubar"],
      requiredContextRole: ["group", "menu", "menubar"],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input", "checkbox"], ["roletype", "widget", "command", "menuitem"]]
    };
    var _default = exports.default = menuitemcheckboxRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/menuitemradioRole.js
var require_menuitemradioRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/menuitemradioRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var menuitemradioRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "menuitem"
        },
        module: "ARIA"
      }],
      requireContextRole: ["group", "menu", "menubar"],
      requiredContextRole: ["group", "menu", "menubar"],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input", "checkbox", "menuitemcheckbox"], ["roletype", "widget", "command", "menuitem", "menuitemcheckbox"], ["roletype", "widget", "input", "radio"]]
    };
    var _default = exports.default = menuitemradioRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/meterRole.js
var require_meterRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/meterRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var meterRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-valuetext": null,
        "aria-valuemax": "100",
        "aria-valuemin": "0"
      },
      relatedConcepts: [{
        concept: {
          name: "meter"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-valuenow": null
      },
      superClass: [["roletype", "structure", "range"]]
    };
    var _default = exports.default = meterRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/navigationRole.js
var require_navigationRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/navigationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var navigationRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "nav"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = navigationRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/noneRole.js
var require_noneRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/noneRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var noneRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: []
    };
    var _default = exports.default = noneRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/noteRole.js
var require_noteRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/noteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var noteRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = noteRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/optionRole.js
var require_optionRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/optionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var optionRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-checked": null,
        "aria-posinset": null,
        "aria-setsize": null,
        "aria-selected": "false"
      },
      relatedConcepts: [{
        concept: {
          name: "item"
        },
        module: "XForms"
      }, {
        concept: {
          name: "listitem"
        },
        module: "ARIA"
      }, {
        concept: {
          name: "option"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-selected": "false"
      },
      superClass: [["roletype", "widget", "input"]]
    };
    var _default = exports.default = optionRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/paragraphRole.js
var require_paragraphRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/paragraphRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var paragraphRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "p"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = paragraphRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/presentationRole.js
var require_presentationRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/presentationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var presentationRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "alt",
            value: ""
          }],
          name: "img"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = exports.default = presentationRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/progressbarRole.js
var require_progressbarRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/progressbarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var progressbarRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-valuetext": null
      },
      relatedConcepts: [{
        concept: {
          name: "progress"
        },
        module: "HTML"
      }, {
        concept: {
          name: "status"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "range"], ["roletype", "widget"]]
    };
    var _default = exports.default = progressbarRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/radioRole.js
var require_radioRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/radioRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var radioRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-checked": null,
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "radio"
          }],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input"]]
    };
    var _default = exports.default = radioRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/radiogroupRole.js
var require_radiogroupRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/radiogroupRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var radiogroupRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null
      },
      relatedConcepts: [{
        concept: {
          name: "list"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["radio"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    };
    var _default = exports.default = radiogroupRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/regionRole.js
var require_regionRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/regionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var regionRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-label"
          }],
          name: "section"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["set"],
            name: "aria-labelledby"
          }],
          name: "section"
        },
        module: "HTML"
      }, {
        concept: {
          name: "Device Independence Glossart perceivable unit"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = regionRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/rowRole.js
var require_rowRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/rowRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var rowRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-colindex": null,
        "aria-expanded": null,
        "aria-level": null,
        "aria-posinset": null,
        "aria-rowindex": null,
        "aria-selected": null,
        "aria-setsize": null
      },
      relatedConcepts: [{
        concept: {
          name: "tr"
        },
        module: "HTML"
      }],
      requireContextRole: ["grid", "rowgroup", "table", "treegrid"],
      requiredContextRole: ["grid", "rowgroup", "table", "treegrid"],
      requiredOwnedElements: [["cell"], ["columnheader"], ["gridcell"], ["rowheader"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "group"], ["roletype", "widget"]]
    };
    var _default = exports.default = rowRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/rowgroupRole.js
var require_rowgroupRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/rowgroupRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var rowgroupRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "tbody"
        },
        module: "HTML"
      }, {
        concept: {
          name: "tfoot"
        },
        module: "HTML"
      }, {
        concept: {
          name: "thead"
        },
        module: "HTML"
      }],
      requireContextRole: ["grid", "table", "treegrid"],
      requiredContextRole: ["grid", "table", "treegrid"],
      requiredOwnedElements: [["row"]],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = exports.default = rowgroupRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/rowheaderRole.js
var require_rowheaderRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/rowheaderRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var rowheaderRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-sort": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "scope",
            value: "row"
          }],
          name: "th"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            name: "scope",
            value: "rowgroup"
          }],
          name: "th"
        },
        module: "HTML"
      }],
      requireContextRole: ["row", "rowgroup"],
      requiredContextRole: ["row", "rowgroup"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "cell"], ["roletype", "structure", "section", "cell", "gridcell"], ["roletype", "widget", "gridcell"], ["roletype", "structure", "sectionhead"]]
    };
    var _default = exports.default = rowheaderRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/scrollbarRole.js
var require_scrollbarRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/scrollbarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var scrollbarRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-valuetext": null,
        "aria-orientation": "vertical",
        "aria-valuemax": "100",
        "aria-valuemin": "0"
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-controls": null,
        "aria-valuenow": null
      },
      superClass: [["roletype", "structure", "range"], ["roletype", "widget"]]
    };
    var _default = exports.default = scrollbarRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/searchRole.js
var require_searchRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/searchRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var searchRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = searchRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/searchboxRole.js
var require_searchboxRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/searchboxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var searchboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "search"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "input", "textbox"]]
    };
    var _default = exports.default = searchboxRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/separatorRole.js
var require_separatorRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/separatorRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var separatorRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-orientation": "horizontal",
        "aria-valuemax": "100",
        "aria-valuemin": "0",
        "aria-valuenow": null,
        "aria-valuetext": null
      },
      relatedConcepts: [{
        concept: {
          name: "hr"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure"]]
    };
    var _default = exports.default = separatorRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/sliderRole.js
var require_sliderRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/sliderRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var sliderRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-haspopup": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-valuetext": null,
        "aria-orientation": "horizontal",
        "aria-valuemax": "100",
        "aria-valuemin": "0"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "range"
          }],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-valuenow": null
      },
      superClass: [["roletype", "widget", "input"], ["roletype", "structure", "range"]]
    };
    var _default = exports.default = sliderRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/spinbuttonRole.js
var require_spinbuttonRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/spinbuttonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var spinbuttonRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-valuetext": null,
        "aria-valuenow": "0"
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            name: "type",
            value: "number"
          }],
          name: "input"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"], ["roletype", "widget", "input"], ["roletype", "structure", "range"]]
    };
    var _default = exports.default = spinbuttonRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/statusRole.js
var require_statusRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/statusRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var statusRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-atomic": "true",
        "aria-live": "polite"
      },
      relatedConcepts: [{
        concept: {
          name: "output"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = statusRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/strongRole.js
var require_strongRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/strongRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var strongRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "strong"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = strongRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/subscriptRole.js
var require_subscriptRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/subscriptRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var subscriptRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "sub"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = subscriptRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/superscriptRole.js
var require_superscriptRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/superscriptRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var superscriptRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: ["aria-label", "aria-labelledby"],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "sup"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = superscriptRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/switchRole.js
var require_switchRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/switchRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var switchRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "button"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [["roletype", "widget", "input", "checkbox"]]
    };
    var _default = exports.default = switchRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/tabRole.js
var require_tabRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/tabRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var tabRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-posinset": null,
        "aria-setsize": null,
        "aria-selected": "false"
      },
      relatedConcepts: [],
      requireContextRole: ["tablist"],
      requiredContextRole: ["tablist"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "sectionhead"], ["roletype", "widget"]]
    };
    var _default = exports.default = tabRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/tableRole.js
var require_tableRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/tableRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var tableRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-colcount": null,
        "aria-rowcount": null
      },
      relatedConcepts: [{
        concept: {
          name: "table"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["row"], ["row", "rowgroup"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = tableRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/tablistRole.js
var require_tablistRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/tablistRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var tablistRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-level": null,
        "aria-multiselectable": null,
        "aria-orientation": "horizontal"
      },
      relatedConcepts: [{
        module: "DAISY",
        concept: {
          name: "guide"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["tab"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite"]]
    };
    var _default = exports.default = tablistRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/tabpanelRole.js
var require_tabpanelRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/tabpanelRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var tabpanelRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = tabpanelRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/termRole.js
var require_termRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/termRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var termRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "dfn"
        },
        module: "HTML"
      }, {
        concept: {
          name: "dt"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = termRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/textboxRole.js
var require_textboxRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/textboxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var textboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-autocomplete": null,
        "aria-errormessage": null,
        "aria-haspopup": null,
        "aria-invalid": null,
        "aria-multiline": null,
        "aria-placeholder": null,
        "aria-readonly": null,
        "aria-required": null
      },
      relatedConcepts: [{
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "type"
          }, {
            constraints: ["undefined"],
            name: "list"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "email"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "tel"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "text"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          attributes: [{
            constraints: ["undefined"],
            name: "list"
          }, {
            name: "type",
            value: "url"
          }],
          constraints: ["the list attribute is not set"],
          name: "input"
        },
        module: "HTML"
      }, {
        concept: {
          name: "input"
        },
        module: "XForms"
      }, {
        concept: {
          name: "textarea"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "input"]]
    };
    var _default = exports.default = textboxRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/timeRole.js
var require_timeRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/timeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var timeRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "time"
        },
        module: "HTML"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = timeRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/timerRole.js
var require_timerRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/timerRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var timerRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "status"]]
    };
    var _default = exports.default = timerRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/toolbarRole.js
var require_toolbarRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/toolbarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var toolbarRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-orientation": "horizontal"
      },
      relatedConcepts: [{
        concept: {
          name: "menubar"
        },
        module: "ARIA"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "group"]]
    };
    var _default = exports.default = toolbarRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/tooltipRole.js
var require_tooltipRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/tooltipRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var tooltipRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = tooltipRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/treeRole.js
var require_treeRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/treeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var treeRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-multiselectable": null,
        "aria-required": null,
        "aria-orientation": "vertical"
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["treeitem", "group"], ["treeitem"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
    };
    var _default = exports.default = treeRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/treegridRole.js
var require_treegridRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/treegridRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var treegridRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["row"], ["row", "rowgroup"]],
      requiredProps: {},
      superClass: [["roletype", "widget", "composite", "grid"], ["roletype", "structure", "section", "table", "grid"], ["roletype", "widget", "composite", "select", "tree"], ["roletype", "structure", "section", "group", "select", "tree"]]
    };
    var _default = exports.default = treegridRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/treeitemRole.js
var require_treeitemRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/literal/treeitemRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var treeitemRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-expanded": null,
        "aria-haspopup": null
      },
      relatedConcepts: [],
      requireContextRole: ["group", "tree"],
      requiredContextRole: ["group", "tree"],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-selected": null
      },
      superClass: [["roletype", "structure", "section", "listitem"], ["roletype", "widget", "input", "option"]]
    };
    var _default = exports.default = treeitemRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/ariaLiteralRoles.js
var require_ariaLiteralRoles = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/ariaLiteralRoles.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _alertRole = _interopRequireDefault(require_alertRole());
    var _alertdialogRole = _interopRequireDefault(require_alertdialogRole());
    var _applicationRole = _interopRequireDefault(require_applicationRole());
    var _articleRole = _interopRequireDefault(require_articleRole());
    var _bannerRole = _interopRequireDefault(require_bannerRole());
    var _blockquoteRole = _interopRequireDefault(require_blockquoteRole());
    var _buttonRole = _interopRequireDefault(require_buttonRole());
    var _captionRole = _interopRequireDefault(require_captionRole());
    var _cellRole = _interopRequireDefault(require_cellRole());
    var _checkboxRole = _interopRequireDefault(require_checkboxRole());
    var _codeRole = _interopRequireDefault(require_codeRole());
    var _columnheaderRole = _interopRequireDefault(require_columnheaderRole());
    var _comboboxRole = _interopRequireDefault(require_comboboxRole());
    var _complementaryRole = _interopRequireDefault(require_complementaryRole());
    var _contentinfoRole = _interopRequireDefault(require_contentinfoRole());
    var _definitionRole = _interopRequireDefault(require_definitionRole());
    var _deletionRole = _interopRequireDefault(require_deletionRole());
    var _dialogRole = _interopRequireDefault(require_dialogRole());
    var _directoryRole = _interopRequireDefault(require_directoryRole());
    var _documentRole = _interopRequireDefault(require_documentRole());
    var _emphasisRole = _interopRequireDefault(require_emphasisRole());
    var _feedRole = _interopRequireDefault(require_feedRole());
    var _figureRole = _interopRequireDefault(require_figureRole());
    var _formRole = _interopRequireDefault(require_formRole());
    var _genericRole = _interopRequireDefault(require_genericRole());
    var _gridRole = _interopRequireDefault(require_gridRole());
    var _gridcellRole = _interopRequireDefault(require_gridcellRole());
    var _groupRole = _interopRequireDefault(require_groupRole());
    var _headingRole = _interopRequireDefault(require_headingRole());
    var _imgRole = _interopRequireDefault(require_imgRole());
    var _insertionRole = _interopRequireDefault(require_insertionRole());
    var _linkRole = _interopRequireDefault(require_linkRole());
    var _listRole = _interopRequireDefault(require_listRole());
    var _listboxRole = _interopRequireDefault(require_listboxRole());
    var _listitemRole = _interopRequireDefault(require_listitemRole());
    var _logRole = _interopRequireDefault(require_logRole());
    var _mainRole = _interopRequireDefault(require_mainRole());
    var _markRole = _interopRequireDefault(require_markRole());
    var _marqueeRole = _interopRequireDefault(require_marqueeRole());
    var _mathRole = _interopRequireDefault(require_mathRole());
    var _menuRole = _interopRequireDefault(require_menuRole());
    var _menubarRole = _interopRequireDefault(require_menubarRole());
    var _menuitemRole = _interopRequireDefault(require_menuitemRole());
    var _menuitemcheckboxRole = _interopRequireDefault(require_menuitemcheckboxRole());
    var _menuitemradioRole = _interopRequireDefault(require_menuitemradioRole());
    var _meterRole = _interopRequireDefault(require_meterRole());
    var _navigationRole = _interopRequireDefault(require_navigationRole());
    var _noneRole = _interopRequireDefault(require_noneRole());
    var _noteRole = _interopRequireDefault(require_noteRole());
    var _optionRole = _interopRequireDefault(require_optionRole());
    var _paragraphRole = _interopRequireDefault(require_paragraphRole());
    var _presentationRole = _interopRequireDefault(require_presentationRole());
    var _progressbarRole = _interopRequireDefault(require_progressbarRole());
    var _radioRole = _interopRequireDefault(require_radioRole());
    var _radiogroupRole = _interopRequireDefault(require_radiogroupRole());
    var _regionRole = _interopRequireDefault(require_regionRole());
    var _rowRole = _interopRequireDefault(require_rowRole());
    var _rowgroupRole = _interopRequireDefault(require_rowgroupRole());
    var _rowheaderRole = _interopRequireDefault(require_rowheaderRole());
    var _scrollbarRole = _interopRequireDefault(require_scrollbarRole());
    var _searchRole = _interopRequireDefault(require_searchRole());
    var _searchboxRole = _interopRequireDefault(require_searchboxRole());
    var _separatorRole = _interopRequireDefault(require_separatorRole());
    var _sliderRole = _interopRequireDefault(require_sliderRole());
    var _spinbuttonRole = _interopRequireDefault(require_spinbuttonRole());
    var _statusRole = _interopRequireDefault(require_statusRole());
    var _strongRole = _interopRequireDefault(require_strongRole());
    var _subscriptRole = _interopRequireDefault(require_subscriptRole());
    var _superscriptRole = _interopRequireDefault(require_superscriptRole());
    var _switchRole = _interopRequireDefault(require_switchRole());
    var _tabRole = _interopRequireDefault(require_tabRole());
    var _tableRole = _interopRequireDefault(require_tableRole());
    var _tablistRole = _interopRequireDefault(require_tablistRole());
    var _tabpanelRole = _interopRequireDefault(require_tabpanelRole());
    var _termRole = _interopRequireDefault(require_termRole());
    var _textboxRole = _interopRequireDefault(require_textboxRole());
    var _timeRole = _interopRequireDefault(require_timeRole());
    var _timerRole = _interopRequireDefault(require_timerRole());
    var _toolbarRole = _interopRequireDefault(require_toolbarRole());
    var _tooltipRole = _interopRequireDefault(require_tooltipRole());
    var _treeRole = _interopRequireDefault(require_treeRole());
    var _treegridRole = _interopRequireDefault(require_treegridRole());
    var _treeitemRole = _interopRequireDefault(require_treeitemRole());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    var ariaLiteralRoles = [["alert", _alertRole.default], ["alertdialog", _alertdialogRole.default], ["application", _applicationRole.default], ["article", _articleRole.default], ["banner", _bannerRole.default], ["blockquote", _blockquoteRole.default], ["button", _buttonRole.default], ["caption", _captionRole.default], ["cell", _cellRole.default], ["checkbox", _checkboxRole.default], ["code", _codeRole.default], ["columnheader", _columnheaderRole.default], ["combobox", _comboboxRole.default], ["complementary", _complementaryRole.default], ["contentinfo", _contentinfoRole.default], ["definition", _definitionRole.default], ["deletion", _deletionRole.default], ["dialog", _dialogRole.default], ["directory", _directoryRole.default], ["document", _documentRole.default], ["emphasis", _emphasisRole.default], ["feed", _feedRole.default], ["figure", _figureRole.default], ["form", _formRole.default], ["generic", _genericRole.default], ["grid", _gridRole.default], ["gridcell", _gridcellRole.default], ["group", _groupRole.default], ["heading", _headingRole.default], ["img", _imgRole.default], ["insertion", _insertionRole.default], ["link", _linkRole.default], ["list", _listRole.default], ["listbox", _listboxRole.default], ["listitem", _listitemRole.default], ["log", _logRole.default], ["main", _mainRole.default], ["mark", _markRole.default], ["marquee", _marqueeRole.default], ["math", _mathRole.default], ["menu", _menuRole.default], ["menubar", _menubarRole.default], ["menuitem", _menuitemRole.default], ["menuitemcheckbox", _menuitemcheckboxRole.default], ["menuitemradio", _menuitemradioRole.default], ["meter", _meterRole.default], ["navigation", _navigationRole.default], ["none", _noneRole.default], ["note", _noteRole.default], ["option", _optionRole.default], ["paragraph", _paragraphRole.default], ["presentation", _presentationRole.default], ["progressbar", _progressbarRole.default], ["radio", _radioRole.default], ["radiogroup", _radiogroupRole.default], ["region", _regionRole.default], ["row", _rowRole.default], ["rowgroup", _rowgroupRole.default], ["rowheader", _rowheaderRole.default], ["scrollbar", _scrollbarRole.default], ["search", _searchRole.default], ["searchbox", _searchboxRole.default], ["separator", _separatorRole.default], ["slider", _sliderRole.default], ["spinbutton", _spinbuttonRole.default], ["status", _statusRole.default], ["strong", _strongRole.default], ["subscript", _subscriptRole.default], ["superscript", _superscriptRole.default], ["switch", _switchRole.default], ["tab", _tabRole.default], ["table", _tableRole.default], ["tablist", _tablistRole.default], ["tabpanel", _tabpanelRole.default], ["term", _termRole.default], ["textbox", _textboxRole.default], ["time", _timeRole.default], ["timer", _timerRole.default], ["toolbar", _toolbarRole.default], ["tooltip", _tooltipRole.default], ["tree", _treeRole.default], ["treegrid", _treegridRole.default], ["treeitem", _treeitemRole.default]];
    var _default = exports.default = ariaLiteralRoles;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docAbstractRole.js
var require_docAbstractRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docAbstractRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docAbstractRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "abstract [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = docAbstractRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docAcknowledgmentsRole.js
var require_docAcknowledgmentsRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docAcknowledgmentsRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docAcknowledgmentsRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "acknowledgments [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docAcknowledgmentsRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docAfterwordRole.js
var require_docAfterwordRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docAfterwordRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docAfterwordRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "afterword [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docAfterwordRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docAppendixRole.js
var require_docAppendixRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docAppendixRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docAppendixRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "appendix [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docAppendixRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docBacklinkRole.js
var require_docBacklinkRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docBacklinkRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docBacklinkRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "referrer [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    };
    var _default = exports.default = docBacklinkRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docBiblioentryRole.js
var require_docBiblioentryRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docBiblioentryRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docBiblioentryRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "EPUB biblioentry [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: ["doc-bibliography"],
      requiredContextRole: ["doc-bibliography"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "listitem"]]
    };
    var _default = exports.default = docBiblioentryRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docBibliographyRole.js
var require_docBibliographyRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docBibliographyRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docBibliographyRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "bibliography [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["doc-biblioentry"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docBibliographyRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docBibliorefRole.js
var require_docBibliorefRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docBibliorefRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docBibliorefRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "biblioref [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    };
    var _default = exports.default = docBibliorefRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docChapterRole.js
var require_docChapterRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docChapterRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docChapterRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "chapter [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docChapterRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docColophonRole.js
var require_docColophonRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docColophonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docColophonRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "colophon [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = docColophonRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docConclusionRole.js
var require_docConclusionRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docConclusionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docConclusionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "conclusion [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docConclusionRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docCoverRole.js
var require_docCoverRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docCoverRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docCoverRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "cover [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "img"]]
    };
    var _default = exports.default = docCoverRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docCreditRole.js
var require_docCreditRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docCreditRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docCreditRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "credit [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = docCreditRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docCreditsRole.js
var require_docCreditsRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docCreditsRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docCreditsRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "credits [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docCreditsRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docDedicationRole.js
var require_docDedicationRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docDedicationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docDedicationRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "dedication [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = docDedicationRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docEndnoteRole.js
var require_docEndnoteRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docEndnoteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docEndnoteRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "rearnote [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: ["doc-endnotes"],
      requiredContextRole: ["doc-endnotes"],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "listitem"]]
    };
    var _default = exports.default = docEndnoteRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docEndnotesRole.js
var require_docEndnotesRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docEndnotesRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docEndnotesRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "rearnotes [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["doc-endnote"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docEndnotesRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docEpigraphRole.js
var require_docEpigraphRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docEpigraphRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docEpigraphRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "epigraph [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = docEpigraphRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docEpilogueRole.js
var require_docEpilogueRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docEpilogueRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docEpilogueRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "epilogue [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docEpilogueRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docErrataRole.js
var require_docErrataRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docErrataRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docErrataRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "errata [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docErrataRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docExampleRole.js
var require_docExampleRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docExampleRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docExampleRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = docExampleRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docFootnoteRole.js
var require_docFootnoteRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docFootnoteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docFootnoteRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "footnote [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = docFootnoteRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docForewordRole.js
var require_docForewordRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docForewordRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docForewordRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "foreword [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docForewordRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docGlossaryRole.js
var require_docGlossaryRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docGlossaryRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docGlossaryRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "glossary [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [["definition"], ["term"]],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docGlossaryRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docGlossrefRole.js
var require_docGlossrefRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docGlossrefRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docGlossrefRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "glossref [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    };
    var _default = exports.default = docGlossrefRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docIndexRole.js
var require_docIndexRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docIndexRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docIndexRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "index [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
    };
    var _default = exports.default = docIndexRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docIntroductionRole.js
var require_docIntroductionRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docIntroductionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docIntroductionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "introduction [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docIntroductionRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docNoterefRole.js
var require_docNoterefRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docNoterefRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docNoterefRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "noteref [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "widget", "command", "link"]]
    };
    var _default = exports.default = docNoterefRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docNoticeRole.js
var require_docNoticeRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docNoticeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docNoticeRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "notice [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "note"]]
    };
    var _default = exports.default = docNoticeRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docPagebreakRole.js
var require_docPagebreakRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docPagebreakRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPagebreakRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "pagebreak [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "separator"]]
    };
    var _default = exports.default = docPagebreakRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docPagefooterRole.js
var require_docPagefooterRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docPagefooterRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPagefooterRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: [],
      props: {
        "aria-braillelabel": null,
        "aria-brailleroledescription": null,
        "aria-description": null,
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = docPagefooterRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docPageheaderRole.js
var require_docPageheaderRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docPageheaderRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPageheaderRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["prohibited"],
      prohibitedProps: [],
      props: {
        "aria-braillelabel": null,
        "aria-brailleroledescription": null,
        "aria-description": null,
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = docPageheaderRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docPagelistRole.js
var require_docPagelistRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docPagelistRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPagelistRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "page-list [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
    };
    var _default = exports.default = docPagelistRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docPartRole.js
var require_docPartRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docPartRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPartRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "part [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docPartRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docPrefaceRole.js
var require_docPrefaceRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docPrefaceRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPrefaceRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "preface [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docPrefaceRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docPrologueRole.js
var require_docPrologueRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docPrologueRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPrologueRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "prologue [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark"]]
    };
    var _default = exports.default = docPrologueRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docPullquoteRole.js
var require_docPullquoteRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docPullquoteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docPullquoteRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [{
        concept: {
          name: "pullquote [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["none"]]
    };
    var _default = exports.default = docPullquoteRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docQnaRole.js
var require_docQnaRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docQnaRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docQnaRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "qna [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section"]]
    };
    var _default = exports.default = docQnaRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docSubtitleRole.js
var require_docSubtitleRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docSubtitleRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docSubtitleRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "subtitle [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "sectionhead"]]
    };
    var _default = exports.default = docSubtitleRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docTipRole.js
var require_docTipRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docTipRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docTipRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "help [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "note"]]
    };
    var _default = exports.default = docTipRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docTocRole.js
var require_docTocRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/dpub/docTocRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var docTocRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        concept: {
          name: "toc [EPUB-SSV]"
        },
        module: "EPUB"
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
    };
    var _default = exports.default = docTocRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/ariaDpubRoles.js
var require_ariaDpubRoles = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/ariaDpubRoles.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _docAbstractRole = _interopRequireDefault(require_docAbstractRole());
    var _docAcknowledgmentsRole = _interopRequireDefault(require_docAcknowledgmentsRole());
    var _docAfterwordRole = _interopRequireDefault(require_docAfterwordRole());
    var _docAppendixRole = _interopRequireDefault(require_docAppendixRole());
    var _docBacklinkRole = _interopRequireDefault(require_docBacklinkRole());
    var _docBiblioentryRole = _interopRequireDefault(require_docBiblioentryRole());
    var _docBibliographyRole = _interopRequireDefault(require_docBibliographyRole());
    var _docBibliorefRole = _interopRequireDefault(require_docBibliorefRole());
    var _docChapterRole = _interopRequireDefault(require_docChapterRole());
    var _docColophonRole = _interopRequireDefault(require_docColophonRole());
    var _docConclusionRole = _interopRequireDefault(require_docConclusionRole());
    var _docCoverRole = _interopRequireDefault(require_docCoverRole());
    var _docCreditRole = _interopRequireDefault(require_docCreditRole());
    var _docCreditsRole = _interopRequireDefault(require_docCreditsRole());
    var _docDedicationRole = _interopRequireDefault(require_docDedicationRole());
    var _docEndnoteRole = _interopRequireDefault(require_docEndnoteRole());
    var _docEndnotesRole = _interopRequireDefault(require_docEndnotesRole());
    var _docEpigraphRole = _interopRequireDefault(require_docEpigraphRole());
    var _docEpilogueRole = _interopRequireDefault(require_docEpilogueRole());
    var _docErrataRole = _interopRequireDefault(require_docErrataRole());
    var _docExampleRole = _interopRequireDefault(require_docExampleRole());
    var _docFootnoteRole = _interopRequireDefault(require_docFootnoteRole());
    var _docForewordRole = _interopRequireDefault(require_docForewordRole());
    var _docGlossaryRole = _interopRequireDefault(require_docGlossaryRole());
    var _docGlossrefRole = _interopRequireDefault(require_docGlossrefRole());
    var _docIndexRole = _interopRequireDefault(require_docIndexRole());
    var _docIntroductionRole = _interopRequireDefault(require_docIntroductionRole());
    var _docNoterefRole = _interopRequireDefault(require_docNoterefRole());
    var _docNoticeRole = _interopRequireDefault(require_docNoticeRole());
    var _docPagebreakRole = _interopRequireDefault(require_docPagebreakRole());
    var _docPagefooterRole = _interopRequireDefault(require_docPagefooterRole());
    var _docPageheaderRole = _interopRequireDefault(require_docPageheaderRole());
    var _docPagelistRole = _interopRequireDefault(require_docPagelistRole());
    var _docPartRole = _interopRequireDefault(require_docPartRole());
    var _docPrefaceRole = _interopRequireDefault(require_docPrefaceRole());
    var _docPrologueRole = _interopRequireDefault(require_docPrologueRole());
    var _docPullquoteRole = _interopRequireDefault(require_docPullquoteRole());
    var _docQnaRole = _interopRequireDefault(require_docQnaRole());
    var _docSubtitleRole = _interopRequireDefault(require_docSubtitleRole());
    var _docTipRole = _interopRequireDefault(require_docTipRole());
    var _docTocRole = _interopRequireDefault(require_docTocRole());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    var ariaDpubRoles = [["doc-abstract", _docAbstractRole.default], ["doc-acknowledgments", _docAcknowledgmentsRole.default], ["doc-afterword", _docAfterwordRole.default], ["doc-appendix", _docAppendixRole.default], ["doc-backlink", _docBacklinkRole.default], ["doc-biblioentry", _docBiblioentryRole.default], ["doc-bibliography", _docBibliographyRole.default], ["doc-biblioref", _docBibliorefRole.default], ["doc-chapter", _docChapterRole.default], ["doc-colophon", _docColophonRole.default], ["doc-conclusion", _docConclusionRole.default], ["doc-cover", _docCoverRole.default], ["doc-credit", _docCreditRole.default], ["doc-credits", _docCreditsRole.default], ["doc-dedication", _docDedicationRole.default], ["doc-endnote", _docEndnoteRole.default], ["doc-endnotes", _docEndnotesRole.default], ["doc-epigraph", _docEpigraphRole.default], ["doc-epilogue", _docEpilogueRole.default], ["doc-errata", _docErrataRole.default], ["doc-example", _docExampleRole.default], ["doc-footnote", _docFootnoteRole.default], ["doc-foreword", _docForewordRole.default], ["doc-glossary", _docGlossaryRole.default], ["doc-glossref", _docGlossrefRole.default], ["doc-index", _docIndexRole.default], ["doc-introduction", _docIntroductionRole.default], ["doc-noteref", _docNoterefRole.default], ["doc-notice", _docNoticeRole.default], ["doc-pagebreak", _docPagebreakRole.default], ["doc-pagefooter", _docPagefooterRole.default], ["doc-pageheader", _docPageheaderRole.default], ["doc-pagelist", _docPagelistRole.default], ["doc-part", _docPartRole.default], ["doc-preface", _docPrefaceRole.default], ["doc-prologue", _docPrologueRole.default], ["doc-pullquote", _docPullquoteRole.default], ["doc-qna", _docQnaRole.default], ["doc-subtitle", _docSubtitleRole.default], ["doc-tip", _docTipRole.default], ["doc-toc", _docTocRole.default]];
    var _default = exports.default = ariaDpubRoles;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/graphics/graphicsDocumentRole.js
var require_graphicsDocumentRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/graphics/graphicsDocumentRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var graphicsDocumentRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        module: "GRAPHICS",
        concept: {
          name: "graphics-object"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "img"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "article"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "document"]]
    };
    var _default = exports.default = graphicsDocumentRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/graphics/graphicsObjectRole.js
var require_graphicsObjectRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/graphics/graphicsObjectRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var graphicsObjectRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: ["author", "contents"],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [{
        module: "GRAPHICS",
        concept: {
          name: "graphics-document"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "group"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "img"
        }
      }, {
        module: "GRAPHICS",
        concept: {
          name: "graphics-symbol"
        }
      }],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "group"]]
    };
    var _default = exports.default = graphicsObjectRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/graphics/graphicsSymbolRole.js
var require_graphicsSymbolRole = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/graphics/graphicsSymbolRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var graphicsSymbolRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: ["author"],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [["roletype", "structure", "section", "img"]]
    };
    var _default = exports.default = graphicsSymbolRole;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/ariaGraphicsRoles.js
var require_ariaGraphicsRoles = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/etc/roles/ariaGraphicsRoles.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _graphicsDocumentRole = _interopRequireDefault(require_graphicsDocumentRole());
    var _graphicsObjectRole = _interopRequireDefault(require_graphicsObjectRole());
    var _graphicsSymbolRole = _interopRequireDefault(require_graphicsSymbolRole());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    var ariaGraphicsRoles = [["graphics-document", _graphicsDocumentRole.default], ["graphics-object", _graphicsObjectRole.default], ["graphics-symbol", _graphicsSymbolRole.default]];
    var _default = exports.default = ariaGraphicsRoles;
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/rolesMap.js
var require_rolesMap = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/rolesMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _ariaAbstractRoles = _interopRequireDefault(require_ariaAbstractRoles());
    var _ariaLiteralRoles = _interopRequireDefault(require_ariaLiteralRoles());
    var _ariaDpubRoles = _interopRequireDefault(require_ariaDpubRoles());
    var _ariaGraphicsRoles = _interopRequireDefault(require_ariaGraphicsRoles());
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    function _createForOfIteratorHelper(r, e2) {
      var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (!t) {
        if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e2 && r && "number" == typeof r.length) {
          t && (r = t);
          var _n = 0, F = function F2() {
          };
          return { s: F, n: function n() {
            return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
          }, e: function e3(r2) {
            throw r2;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var o, a = true, u2 = false;
      return { s: function s() {
        t = t.call(r);
      }, n: function n() {
        var r2 = t.next();
        return a = r2.done, r2;
      }, e: function e3(r2) {
        u2 = true, o = r2;
      }, f: function f() {
        try {
          a || null == t.return || t.return();
        } finally {
          if (u2) throw o;
        }
      } };
    }
    function _slicedToArray(r, e2) {
      return _arrayWithHoles(r) || _iterableToArrayLimit(r, e2) || _unsupportedIterableToArray(r, e2) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e2 = 0, n = Array(a); e2 < a; e2++) n[e2] = r[e2];
      return n;
    }
    function _iterableToArrayLimit(r, l2) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e2, n, i, u2, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l2) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e2 = i.call(t)).done) && (a.push(e2.value), a.length !== l2); f = true) ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t.return && (u2 = t.return(), Object(u2) !== u2)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(r) {
      if (Array.isArray(r)) return r;
    }
    var roles = [].concat(_ariaAbstractRoles.default, _ariaLiteralRoles.default, _ariaDpubRoles.default, _ariaGraphicsRoles.default);
    roles.forEach(function(_ref) {
      var _ref2 = _slicedToArray(_ref, 2), roleDefinition = _ref2[1];
      var _iterator = _createForOfIteratorHelper(roleDefinition.superClass), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var superClassIter = _step.value;
          var _iterator2 = _createForOfIteratorHelper(superClassIter), _step2;
          try {
            var _loop = function _loop2() {
              var superClassName = _step2.value;
              var superClassRoleTuple = roles.filter(function(_ref3) {
                var _ref4 = _slicedToArray(_ref3, 1), name2 = _ref4[0];
                return name2 === superClassName;
              })[0];
              if (superClassRoleTuple) {
                var superClassDefinition = superClassRoleTuple[1];
                for (var _i = 0, _Object$keys = Object.keys(superClassDefinition.props); _i < _Object$keys.length; _i++) {
                  var prop3 = _Object$keys[_i];
                  if (
                    // $FlowIssue Accessing the hasOwnProperty on the Object prototype is fine.
                    !Object.prototype.hasOwnProperty.call(roleDefinition.props, prop3)
                  ) {
                    roleDefinition.props[prop3] = superClassDefinition.props[prop3];
                  }
                }
              }
            };
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              _loop();
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    });
    var rolesMap = {
      entries: function entries() {
        return roles;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        var _iterator3 = _createForOfIteratorHelper(roles), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
            var _step3$value = _slicedToArray(_step3.value, 2), key2 = _step3$value[0], values = _step3$value[1];
            fn.call(thisArg, values, key2, roles);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      },
      get: function get2(key2) {
        var item = roles.filter(function(tuple) {
          return tuple[0] === key2 ? true : false;
        })[0];
        return item && item[1];
      },
      has: function has(key2) {
        return !!rolesMap.get(key2);
      },
      keys: function keys2() {
        return roles.map(function(_ref5) {
          var _ref6 = _slicedToArray(_ref5, 1), key2 = _ref6[0];
          return key2;
        });
      },
      values: function values() {
        return roles.map(function(_ref7) {
          var _ref8 = _slicedToArray(_ref7, 2), values2 = _ref8[1];
          return values2;
        });
      }
    };
    var _default = exports.default = (0, _iterationDecorator.default)(rolesMap, rolesMap.entries());
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/elementRoleMap.js
var require_elementRoleMap = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/elementRoleMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
    var _rolesMap = _interopRequireDefault(require_rolesMap());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    function _slicedToArray(r, e2) {
      return _arrayWithHoles(r) || _iterableToArrayLimit(r, e2) || _unsupportedIterableToArray(r, e2) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e2 = 0, n = Array(a); e2 < a; e2++) n[e2] = r[e2];
      return n;
    }
    function _iterableToArrayLimit(r, l2) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e2, n, i2, u2, a = [], f = true, o = false;
        try {
          if (i2 = (t = t.call(r)).next, 0 === l2) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e2 = i2.call(t)).done) && (a.push(e2.value), a.length !== l2); f = true) ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t.return && (u2 = t.return(), Object(u2) !== u2)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(r) {
      if (Array.isArray(r)) return r;
    }
    var elementRoles2 = [];
    var keys2 = _rolesMap.default.keys();
    for (i = 0; i < keys2.length; i++) {
      key2 = keys2[i];
      role = _rolesMap.default.get(key2);
      if (role) {
        concepts = [].concat(role.baseConcepts, role.relatedConcepts);
        _loop = function _loop2() {
          var relation = concepts[k];
          if (relation.module === "HTML") {
            var concept = relation.concept;
            if (concept) {
              var elementRoleRelation = elementRoles2.filter(function(relation2) {
                return ariaRoleRelationConceptEquals(relation2[0], concept);
              })[0];
              var roles;
              if (elementRoleRelation) {
                roles = elementRoleRelation[1];
              } else {
                roles = [];
              }
              var isUnique = true;
              for (var _i = 0; _i < roles.length; _i++) {
                if (roles[_i] === key2) {
                  isUnique = false;
                  break;
                }
              }
              if (isUnique) {
                roles.push(key2);
              }
              if (!elementRoleRelation) {
                elementRoles2.push([concept, roles]);
              }
            }
          }
        };
        for (k = 0; k < concepts.length; k++) {
          _loop();
        }
      }
    }
    var key2;
    var role;
    var concepts;
    var _loop;
    var k;
    var i;
    var elementRoleMap = {
      entries: function entries() {
        return elementRoles2;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        for (var _i2 = 0, _elementRoles = elementRoles2; _i2 < _elementRoles.length; _i2++) {
          var _elementRoles$_i = _slicedToArray(_elementRoles[_i2], 2), _key = _elementRoles$_i[0], values = _elementRoles$_i[1];
          fn.call(thisArg, values, _key, elementRoles2);
        }
      },
      get: function get2(key3) {
        var item = elementRoles2.filter(function(tuple) {
          return key3.name === tuple[0].name && ariaRoleRelationConceptAttributeEquals(key3.attributes, tuple[0].attributes);
        })[0];
        return item && item[1];
      },
      has: function has(key3) {
        return !!elementRoleMap.get(key3);
      },
      keys: function keys3() {
        return elementRoles2.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key3 = _ref2[0];
          return key3;
        });
      },
      values: function values() {
        return elementRoles2.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    function ariaRoleRelationConceptEquals(a, b) {
      return a.name === b.name && ariaRoleRelationConstraintsEquals(a.constraints, b.constraints) && ariaRoleRelationConceptAttributeEquals(a.attributes, b.attributes);
    }
    function ariaRoleRelationConstraintsEquals(a, b) {
      if (a === void 0 && b !== void 0) {
        return false;
      }
      if (a !== void 0 && b === void 0) {
        return false;
      }
      if (a !== void 0 && b !== void 0) {
        if (a.length !== b.length) {
          return false;
        }
        for (var _i3 = 0; _i3 < a.length; _i3++) {
          if (a[_i3] !== b[_i3]) {
            return false;
          }
        }
      }
      return true;
    }
    function ariaRoleRelationConceptAttributeEquals(a, b) {
      if (a === void 0 && b !== void 0) {
        return false;
      }
      if (a !== void 0 && b === void 0) {
        return false;
      }
      if (a !== void 0 && b !== void 0) {
        if (a.length !== b.length) {
          return false;
        }
        for (var _i4 = 0; _i4 < a.length; _i4++) {
          if (a[_i4].name !== b[_i4].name || a[_i4].value !== b[_i4].value) {
            return false;
          }
          if (a[_i4].constraints === void 0 && b[_i4].constraints !== void 0) {
            return false;
          }
          if (a[_i4].constraints !== void 0 && b[_i4].constraints === void 0) {
            return false;
          }
          if (a[_i4].constraints !== void 0 && b[_i4].constraints !== void 0) {
            if (a[_i4].constraints.length !== b[_i4].constraints.length) {
              return false;
            }
            for (var j = 0; j < a[_i4].constraints.length; j++) {
              if (a[_i4].constraints[j] !== b[_i4].constraints[j]) {
                return false;
              }
            }
          }
        }
      }
      return true;
    }
    var _default = exports.default = (0, _iterationDecorator.default)(elementRoleMap, elementRoleMap.entries());
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/roleElementMap.js
var require_roleElementMap = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/roleElementMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator());
    var _rolesMap = _interopRequireDefault(require_rolesMap());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    function _slicedToArray(r, e2) {
      return _arrayWithHoles(r) || _iterableToArrayLimit(r, e2) || _unsupportedIterableToArray(r, e2) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e2 = 0, n = Array(a); e2 < a; e2++) n[e2] = r[e2];
      return n;
    }
    function _iterableToArrayLimit(r, l2) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e2, n, i2, u2, a = [], f = true, o = false;
        try {
          if (i2 = (t = t.call(r)).next, 0 === l2) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e2 = i2.call(t)).done) && (a.push(e2.value), a.length !== l2); f = true) ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t.return && (u2 = t.return(), Object(u2) !== u2)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(r) {
      if (Array.isArray(r)) return r;
    }
    var roleElement = [];
    var keys2 = _rolesMap.default.keys();
    for (i = 0; i < keys2.length; i++) {
      key2 = keys2[i];
      role = _rolesMap.default.get(key2);
      relationConcepts = [];
      if (role) {
        concepts = [].concat(role.baseConcepts, role.relatedConcepts);
        for (k = 0; k < concepts.length; k++) {
          relation = concepts[k];
          if (relation.module === "HTML") {
            concept = relation.concept;
            if (concept != null) {
              relationConcepts.push(concept);
            }
          }
        }
        if (relationConcepts.length > 0) {
          roleElement.push([key2, relationConcepts]);
        }
      }
    }
    var key2;
    var role;
    var relationConcepts;
    var concepts;
    var relation;
    var concept;
    var k;
    var i;
    var roleElementMap = {
      entries: function entries() {
        return roleElement;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        for (var _i = 0, _roleElement = roleElement; _i < _roleElement.length; _i++) {
          var _roleElement$_i = _slicedToArray(_roleElement[_i], 2), _key = _roleElement$_i[0], values = _roleElement$_i[1];
          fn.call(thisArg, values, _key, roleElement);
        }
      },
      get: function get2(key3) {
        var item = roleElement.filter(function(tuple) {
          return tuple[0] === key3 ? true : false;
        })[0];
        return item && item[1];
      },
      has: function has(key3) {
        return !!roleElementMap.get(key3);
      },
      keys: function keys3() {
        return roleElement.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key3 = _ref2[0];
          return key3;
        });
      },
      values: function values() {
        return roleElement.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = exports.default = (0, _iterationDecorator.default)(roleElementMap, roleElementMap.entries());
  }
});

// node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/index.js
var require_lib = __commonJS({
  "node_modules/.deno/aria-query@5.3.2/node_modules/aria-query/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.roles = exports.roleElements = exports.elementRoles = exports.dom = exports.aria = void 0;
    var _ariaPropsMap = _interopRequireDefault(require_ariaPropsMap());
    var _domMap = _interopRequireDefault(require_domMap());
    var _rolesMap = _interopRequireDefault(require_rolesMap());
    var _elementRoleMap = _interopRequireDefault(require_elementRoleMap());
    var _roleElementMap = _interopRequireDefault(require_roleElementMap());
    function _interopRequireDefault(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    var aria3 = exports.aria = _ariaPropsMap.default;
    var dom = exports.dom = _domMap.default;
    var roles = exports.roles = _rolesMap.default;
    var elementRoles2 = exports.elementRoles = _elementRoleMap.default;
    var roleElements = exports.roleElements = _roleElementMap.default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/util/iteratorProxy.js
var require_iteratorProxy2 = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/util/iteratorProxy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    function iteratorProxy() {
      var values = this;
      var index2 = 0;
      var iter = {
        "@@iterator": function iterator() {
          return iter;
        },
        next: function next2() {
          if (index2 < values.length) {
            var value = values[index2];
            index2 = index2 + 1;
            return {
              done: false,
              value
            };
          } else {
            return {
              done: true
            };
          }
        }
      };
      return iter;
    }
    var _default = iteratorProxy;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/util/iterationDecorator.js
var require_iterationDecorator2 = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/util/iterationDecorator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = iterationDecorator;
    var _iteratorProxy = _interopRequireDefault(require_iteratorProxy2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    function iterationDecorator(collection, entries) {
      if (typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol") {
        Object.defineProperty(collection, Symbol.iterator, {
          value: _iteratorProxy.default.bind(entries)
        });
      }
      return collection;
    }
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/AbbrRole.js
var require_AbbrRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/AbbrRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var AbbrRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "abbr"
        }
      }],
      type: "structure"
    };
    var _default = AbbrRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/AlertDialogRole.js
var require_AlertDialogRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/AlertDialogRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var AlertDialogRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "alertdialog"
        }
      }],
      type: "window"
    };
    var _default = AlertDialogRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/AlertRole.js
var require_AlertRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/AlertRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var AlertRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "alert"
        }
      }],
      type: "structure"
    };
    var _default = AlertRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/AnnotationRole.js
var require_AnnotationRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/AnnotationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var AnnotationRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = AnnotationRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ApplicationRole.js
var require_ApplicationRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ApplicationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ApplicationRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "application"
        }
      }],
      type: "window"
    };
    var _default = ApplicationRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ArticleRole.js
var require_ArticleRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ArticleRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ArticleRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "article"
        }
      }, {
        module: "HTML",
        concept: {
          name: "article"
        }
      }],
      type: "structure"
    };
    var _default = ArticleRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/AudioRole.js
var require_AudioRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/AudioRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var AudioRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "audio"
        }
      }],
      type: "widget"
    };
    var _default = AudioRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/BannerRole.js
var require_BannerRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/BannerRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var BannerRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "banner"
        }
      }],
      type: "structure"
    };
    var _default = BannerRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/BlockquoteRole.js
var require_BlockquoteRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/BlockquoteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var BlockquoteRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "blockquote"
        }
      }],
      type: "structure"
    };
    var _default = BlockquoteRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/BusyIndicatorRole.js
var require_BusyIndicatorRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/BusyIndicatorRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var BusyIndicatorRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          attributes: [{
            name: "aria-busy",
            value: "true"
          }]
        }
      }],
      type: "widget"
    };
    var _default = BusyIndicatorRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ButtonRole.js
var require_ButtonRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ButtonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ButtonRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "button"
        }
      }, {
        module: "HTML",
        concept: {
          name: "button"
        }
      }],
      type: "widget"
    };
    var _default = ButtonRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/CanvasRole.js
var require_CanvasRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/CanvasRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var CanvasRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "canvas"
        }
      }],
      type: "widget"
    };
    var _default = CanvasRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/CaptionRole.js
var require_CaptionRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/CaptionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var CaptionRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "caption"
        }
      }],
      type: "structure"
    };
    var _default = CaptionRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/CellRole.js
var require_CellRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/CellRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var CellRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "cell"
        }
      }, {
        module: "ARIA",
        concept: {
          name: "gridcell"
        }
      }, {
        module: "HTML",
        concept: {
          name: "td"
        }
      }],
      type: "widget"
    };
    var _default = CellRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/CheckBoxRole.js
var require_CheckBoxRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/CheckBoxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var CheckBoxRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "checkbox"
        }
      }, {
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "checkbox"
          }]
        }
      }],
      type: "widget"
    };
    var _default = CheckBoxRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ColorWellRole.js
var require_ColorWellRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ColorWellRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ColorWellRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "color"
          }]
        }
      }],
      type: "widget"
    };
    var _default = ColorWellRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ColumnHeaderRole.js
var require_ColumnHeaderRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ColumnHeaderRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ColumnHeaderRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "columnheader"
        }
      }, {
        module: "HTML",
        concept: {
          name: "th"
        }
      }],
      type: "widget"
    };
    var _default = ColumnHeaderRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ColumnRole.js
var require_ColumnRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ColumnRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ColumnRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = ColumnRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ComboBoxRole.js
var require_ComboBoxRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ComboBoxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ComboBoxRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "combobox"
        }
      }, {
        module: "HTML",
        concept: {
          name: "select"
        }
      }],
      type: "widget"
    };
    var _default = ComboBoxRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ComplementaryRole.js
var require_ComplementaryRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ComplementaryRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ComplementaryRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "complementary"
        }
      }],
      type: "structure"
    };
    var _default = ComplementaryRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ContentInfoRole.js
var require_ContentInfoRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ContentInfoRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ContentInfoRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "structureinfo"
        }
      }],
      type: "structure"
    };
    var _default = ContentInfoRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DateRole.js
var require_DateRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DateRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DateRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "date"
          }]
        }
      }],
      type: "widget"
    };
    var _default = DateRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DateTimeRole.js
var require_DateTimeRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DateTimeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DateTimeRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "datetime"
          }]
        }
      }],
      type: "widget"
    };
    var _default = DateTimeRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DefinitionRole.js
var require_DefinitionRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DefinitionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DefinitionRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "dfn"
        }
      }],
      type: "structure"
    };
    var _default = DefinitionRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DescriptionListDetailRole.js
var require_DescriptionListDetailRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DescriptionListDetailRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DescriptionListDetailRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "dd"
        }
      }],
      type: "structure"
    };
    var _default = DescriptionListDetailRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DescriptionListRole.js
var require_DescriptionListRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DescriptionListRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DescriptionListRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "dl"
        }
      }],
      type: "structure"
    };
    var _default = DescriptionListRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DescriptionListTermRole.js
var require_DescriptionListTermRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DescriptionListTermRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DescriptionListTermRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "dt"
        }
      }],
      type: "structure"
    };
    var _default = DescriptionListTermRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DetailsRole.js
var require_DetailsRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DetailsRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DetailsRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "details"
        }
      }],
      type: "structure"
    };
    var _default = DetailsRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DialogRole.js
var require_DialogRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DialogRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DialogRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "dialog"
        }
      }, {
        module: "HTML",
        concept: {
          name: "dialog"
        }
      }],
      type: "window"
    };
    var _default = DialogRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DirectoryRole.js
var require_DirectoryRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DirectoryRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DirectoryRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "directory"
        }
      }, {
        module: "HTML",
        concept: {
          name: "dir"
        }
      }],
      type: "structure"
    };
    var _default = DirectoryRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DisclosureTriangleRole.js
var require_DisclosureTriangleRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DisclosureTriangleRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DisclosureTriangleRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          constraints: ["scoped to a details element"],
          name: "summary"
        }
      }],
      type: "widget"
    };
    var _default = DisclosureTriangleRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DivRole.js
var require_DivRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DivRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DivRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "div"
        }
      }],
      type: "generic"
    };
    var _default = DivRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DocumentRole.js
var require_DocumentRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/DocumentRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DocumentRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "document"
        }
      }],
      type: "structure"
    };
    var _default = DocumentRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/EmbeddedObjectRole.js
var require_EmbeddedObjectRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/EmbeddedObjectRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var EmbeddedObjectRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "embed"
        }
      }],
      type: "widget"
    };
    var _default = EmbeddedObjectRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/FeedRole.js
var require_FeedRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/FeedRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var FeedRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "feed"
        }
      }],
      type: "structure"
    };
    var _default = FeedRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/FigcaptionRole.js
var require_FigcaptionRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/FigcaptionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var FigcaptionRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "figcaption"
        }
      }],
      type: "structure"
    };
    var _default = FigcaptionRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/FigureRole.js
var require_FigureRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/FigureRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var FigureRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "figure"
        }
      }, {
        module: "HTML",
        concept: {
          name: "figure"
        }
      }],
      type: "structure"
    };
    var _default = FigureRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/FooterRole.js
var require_FooterRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/FooterRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var FooterRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "footer"
        }
      }],
      type: "structure"
    };
    var _default = FooterRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/FormRole.js
var require_FormRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/FormRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var FormRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "form"
        }
      }, {
        module: "HTML",
        concept: {
          name: "form"
        }
      }],
      type: "structure"
    };
    var _default = FormRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/GridRole.js
var require_GridRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/GridRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var GridRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "grid"
        }
      }],
      type: "widget"
    };
    var _default = GridRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/GroupRole.js
var require_GroupRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/GroupRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var GroupRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "group"
        }
      }],
      type: "structure"
    };
    var _default = GroupRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/HeadingRole.js
var require_HeadingRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/HeadingRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var HeadingRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "heading"
        }
      }, {
        module: "HTML",
        concept: {
          name: "h1"
        }
      }, {
        module: "HTML",
        concept: {
          name: "h2"
        }
      }, {
        module: "HTML",
        concept: {
          name: "h3"
        }
      }, {
        module: "HTML",
        concept: {
          name: "h4"
        }
      }, {
        module: "HTML",
        concept: {
          name: "h5"
        }
      }, {
        module: "HTML",
        concept: {
          name: "h6"
        }
      }],
      type: "structure"
    };
    var _default = HeadingRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/IframePresentationalRole.js
var require_IframePresentationalRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/IframePresentationalRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var IframePresentationalRole = {
      relatedConcepts: [],
      type: "window"
    };
    var _default = IframePresentationalRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/IframeRole.js
var require_IframeRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/IframeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var IframeRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "iframe"
        }
      }],
      type: "window"
    };
    var _default = IframeRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/IgnoredRole.js
var require_IgnoredRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/IgnoredRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var IgnoredRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = IgnoredRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ImageMapLinkRole.js
var require_ImageMapLinkRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ImageMapLinkRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ImageMapLinkRole = {
      relatedConcepts: [],
      type: "widget"
    };
    var _default = ImageMapLinkRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ImageMapRole.js
var require_ImageMapRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ImageMapRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ImageMapRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "img",
          attributes: [{
            name: "usemap"
          }]
        }
      }],
      type: "structure"
    };
    var _default = ImageMapRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ImageRole.js
var require_ImageRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ImageRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ImageRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "img"
        }
      }, {
        module: "HTML",
        concept: {
          name: "img"
        }
      }],
      type: "structure"
    };
    var _default = ImageRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/InlineTextBoxRole.js
var require_InlineTextBoxRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/InlineTextBoxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var InlineTextBoxRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "input"
        }
      }],
      type: "widget"
    };
    var _default = InlineTextBoxRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/InputTimeRole.js
var require_InputTimeRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/InputTimeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var InputTimeRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "time"
          }]
        }
      }],
      type: "widget"
    };
    var _default = InputTimeRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/LabelRole.js
var require_LabelRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/LabelRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var LabelRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "label"
        }
      }],
      type: "structure"
    };
    var _default = LabelRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/LegendRole.js
var require_LegendRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/LegendRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var LegendRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "legend"
        }
      }],
      type: "structure"
    };
    var _default = LegendRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/LineBreakRole.js
var require_LineBreakRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/LineBreakRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var LineBreakRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "br"
        }
      }],
      type: "structure"
    };
    var _default = LineBreakRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/LinkRole.js
var require_LinkRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/LinkRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var LinkRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "link"
        }
      }, {
        module: "HTML",
        concept: {
          name: "a",
          attributes: [{
            name: "href"
          }]
        }
      }],
      type: "widget"
    };
    var _default = LinkRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ListBoxOptionRole.js
var require_ListBoxOptionRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ListBoxOptionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ListBoxOptionRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "option"
        }
      }, {
        module: "HTML",
        concept: {
          name: "option"
        }
      }],
      type: "widget"
    };
    var _default = ListBoxOptionRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ListBoxRole.js
var require_ListBoxRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ListBoxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ListBoxRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "listbox"
        }
      }, {
        module: "HTML",
        concept: {
          name: "datalist"
        }
      }, {
        module: "HTML",
        concept: {
          name: "select"
        }
      }],
      type: "widget"
    };
    var _default = ListBoxRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ListItemRole.js
var require_ListItemRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ListItemRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ListItemRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "listitem"
        }
      }, {
        module: "HTML",
        concept: {
          name: "li"
        }
      }],
      type: "structure"
    };
    var _default = ListItemRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ListMarkerRole.js
var require_ListMarkerRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ListMarkerRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ListMarkerRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = ListMarkerRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ListRole.js
var require_ListRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ListRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ListRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "list"
        }
      }, {
        module: "HTML",
        concept: {
          name: "ul"
        }
      }, {
        module: "HTML",
        concept: {
          name: "ol"
        }
      }],
      type: "structure"
    };
    var _default = ListRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/LogRole.js
var require_LogRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/LogRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var LogRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "log"
        }
      }],
      type: "structure"
    };
    var _default = LogRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MainRole.js
var require_MainRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MainRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MainRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "main"
        }
      }, {
        module: "HTML",
        concept: {
          name: "main"
        }
      }],
      type: "structure"
    };
    var _default = MainRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MarkRole.js
var require_MarkRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MarkRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MarkRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "mark"
        }
      }],
      type: "structure"
    };
    var _default = MarkRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MarqueeRole.js
var require_MarqueeRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MarqueeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MarqueeRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "marquee"
        }
      }, {
        module: "HTML",
        concept: {
          name: "marquee"
        }
      }],
      type: "structure"
    };
    var _default = MarqueeRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MathRole.js
var require_MathRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MathRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MathRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "math"
        }
      }],
      type: "structure"
    };
    var _default = MathRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MenuBarRole.js
var require_MenuBarRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MenuBarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MenuBarRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "menubar"
        }
      }],
      type: "structure"
    };
    var _default = MenuBarRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MenuButtonRole.js
var require_MenuButtonRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MenuButtonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MenuButtonRole = {
      relatedConcepts: [],
      type: "widget"
    };
    var _default = MenuButtonRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MenuItemRole.js
var require_MenuItemRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MenuItemRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MenuItemRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "menuitem"
        }
      }, {
        module: "HTML",
        concept: {
          name: "menuitem"
        }
      }],
      type: "widget"
    };
    var _default = MenuItemRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MenuItemCheckBoxRole.js
var require_MenuItemCheckBoxRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MenuItemCheckBoxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MenuItemCheckBoxRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "menuitemcheckbox"
        }
      }],
      type: "widget"
    };
    var _default = MenuItemCheckBoxRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MenuItemRadioRole.js
var require_MenuItemRadioRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MenuItemRadioRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MenuItemRadioRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "menuitemradio"
        }
      }],
      type: "widget"
    };
    var _default = MenuItemRadioRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MenuListOptionRole.js
var require_MenuListOptionRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MenuListOptionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MenuListOptionRole = {
      relatedConcepts: [],
      type: "widget"
    };
    var _default = MenuListOptionRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MenuListPopupRole.js
var require_MenuListPopupRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MenuListPopupRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MenuListPopupRole = {
      relatedConcepts: [],
      type: "widget"
    };
    var _default = MenuListPopupRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MenuRole.js
var require_MenuRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MenuRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MenuRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "menu"
        }
      }, {
        module: "HTML",
        concept: {
          name: "menu"
        }
      }],
      type: "structure"
    };
    var _default = MenuRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MeterRole.js
var require_MeterRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/MeterRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MeterRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "meter"
        }
      }],
      type: "structure"
    };
    var _default = MeterRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/NavigationRole.js
var require_NavigationRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/NavigationRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var NavigationRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "navigation"
        }
      }, {
        module: "HTML",
        concept: {
          name: "nav"
        }
      }],
      type: "structure"
    };
    var _default = NavigationRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/NoneRole.js
var require_NoneRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/NoneRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var NoneRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "none"
        }
      }],
      type: "structure"
    };
    var _default = NoneRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/NoteRole.js
var require_NoteRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/NoteRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var NoteRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "note"
        }
      }],
      type: "structure"
    };
    var _default = NoteRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/OutlineRole.js
var require_OutlineRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/OutlineRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var OutlineRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = OutlineRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ParagraphRole.js
var require_ParagraphRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ParagraphRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ParagraphRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "p"
        }
      }],
      type: "structure"
    };
    var _default = ParagraphRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/PopUpButtonRole.js
var require_PopUpButtonRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/PopUpButtonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var PopUpButtonRole = {
      relatedConcepts: [],
      type: "widget"
    };
    var _default = PopUpButtonRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/PreRole.js
var require_PreRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/PreRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var PreRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "pre"
        }
      }],
      type: "structure"
    };
    var _default = PreRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/PresentationalRole.js
var require_PresentationalRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/PresentationalRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var PresentationalRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "presentation"
        }
      }],
      type: "structure"
    };
    var _default = PresentationalRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ProgressIndicatorRole.js
var require_ProgressIndicatorRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ProgressIndicatorRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ProgressIndicatorRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "progressbar"
        }
      }, {
        module: "HTML",
        concept: {
          name: "progress"
        }
      }],
      type: "structure"
    };
    var _default = ProgressIndicatorRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/RadioButtonRole.js
var require_RadioButtonRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/RadioButtonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var RadioButtonRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "radio"
        }
      }, {
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "radio"
          }]
        }
      }],
      type: "widget"
    };
    var _default = RadioButtonRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/RadioGroupRole.js
var require_RadioGroupRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/RadioGroupRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var RadioGroupRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "radiogroup"
        }
      }],
      type: "structure"
    };
    var _default = RadioGroupRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/RegionRole.js
var require_RegionRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/RegionRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var RegionRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "region"
        }
      }],
      type: "structure"
    };
    var _default = RegionRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/RootWebAreaRole.js
var require_RootWebAreaRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/RootWebAreaRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var RootWebAreaRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = RootWebAreaRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/RowHeaderRole.js
var require_RowHeaderRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/RowHeaderRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var RowHeaderRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "rowheader"
        }
      }, {
        module: "HTML",
        concept: {
          name: "th",
          attributes: [{
            name: "scope",
            value: "row"
          }]
        }
      }],
      type: "widget"
    };
    var _default = RowHeaderRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/RowRole.js
var require_RowRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/RowRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var RowRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "row"
        }
      }, {
        module: "HTML",
        concept: {
          name: "tr"
        }
      }],
      type: "structure"
    };
    var _default = RowRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/RubyRole.js
var require_RubyRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/RubyRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var RubyRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "ruby"
        }
      }],
      type: "structure"
    };
    var _default = RubyRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/RulerRole.js
var require_RulerRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/RulerRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var RulerRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = RulerRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ScrollAreaRole.js
var require_ScrollAreaRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ScrollAreaRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ScrollAreaRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = ScrollAreaRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ScrollBarRole.js
var require_ScrollBarRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ScrollBarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ScrollBarRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "scrollbar"
        }
      }],
      type: "widget"
    };
    var _default = ScrollBarRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/SeamlessWebAreaRole.js
var require_SeamlessWebAreaRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/SeamlessWebAreaRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SeamlessWebAreaRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = SeamlessWebAreaRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/SearchRole.js
var require_SearchRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/SearchRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SearchRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "search"
        }
      }],
      type: "structure"
    };
    var _default = SearchRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/SearchBoxRole.js
var require_SearchBoxRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/SearchBoxRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SearchBoxRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "searchbox"
        }
      }, {
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "search"
          }]
        }
      }],
      type: "widget"
    };
    var _default = SearchBoxRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/SliderRole.js
var require_SliderRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/SliderRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SliderRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "slider"
        }
      }, {
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "range"
          }]
        }
      }],
      type: "widget"
    };
    var _default = SliderRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/SliderThumbRole.js
var require_SliderThumbRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/SliderThumbRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SliderThumbRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = SliderThumbRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/SpinButtonRole.js
var require_SpinButtonRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/SpinButtonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SpinButtonRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "spinbutton"
        }
      }, {
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "number"
          }]
        }
      }],
      type: "widget"
    };
    var _default = SpinButtonRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/SpinButtonPartRole.js
var require_SpinButtonPartRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/SpinButtonPartRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SpinButtonPartRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = SpinButtonPartRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/SplitterRole.js
var require_SplitterRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/SplitterRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SplitterRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "separator"
        }
      }],
      type: "widget"
    };
    var _default = SplitterRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/StaticTextRole.js
var require_StaticTextRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/StaticTextRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var StaticTextRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = StaticTextRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/StatusRole.js
var require_StatusRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/StatusRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var StatusRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "status"
        }
      }],
      type: "structure"
    };
    var _default = StatusRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/SVGRootRole.js
var require_SVGRootRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/SVGRootRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SVGRootRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = SVGRootRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/SwitchRole.js
var require_SwitchRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/SwitchRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SwitchRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "switch"
        }
      }, {
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "checkbox"
          }]
        }
      }],
      type: "widget"
    };
    var _default = SwitchRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TabGroupRole.js
var require_TabGroupRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TabGroupRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TabGroupRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "tablist"
        }
      }],
      type: "structure"
    };
    var _default = TabGroupRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TabRole.js
var require_TabRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TabRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TabRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "tab"
        }
      }],
      type: "widget"
    };
    var _default = TabRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TableHeaderContainerRole.js
var require_TableHeaderContainerRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TableHeaderContainerRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TableHeaderContainerRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = TableHeaderContainerRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TableRole.js
var require_TableRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TableRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TableRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "table"
        }
      }, {
        module: "HTML",
        concept: {
          name: "table"
        }
      }],
      type: "structure"
    };
    var _default = TableRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TabListRole.js
var require_TabListRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TabListRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TabListRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "tablist"
        }
      }],
      type: "structure"
    };
    var _default = TabListRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TabPanelRole.js
var require_TabPanelRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TabPanelRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TabPanelRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "tabpanel"
        }
      }],
      type: "structure"
    };
    var _default = TabPanelRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TermRole.js
var require_TermRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TermRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TermRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "term"
        }
      }],
      type: "structure"
    };
    var _default = TermRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TextAreaRole.js
var require_TextAreaRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TextAreaRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TextAreaRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          attributes: [{
            name: "aria-multiline",
            value: "true"
          }],
          name: "textbox"
        }
      }, {
        module: "HTML",
        concept: {
          name: "textarea"
        }
      }],
      type: "widget"
    };
    var _default = TextAreaRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TextFieldRole.js
var require_TextFieldRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TextFieldRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TextFieldRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "textbox"
        }
      }, {
        module: "HTML",
        concept: {
          name: "input"
        }
      }, {
        module: "HTML",
        concept: {
          name: "input",
          attributes: [{
            name: "type",
            value: "text"
          }]
        }
      }],
      type: "widget"
    };
    var _default = TextFieldRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TimeRole.js
var require_TimeRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TimeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TimeRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "time"
        }
      }],
      type: "structure"
    };
    var _default = TimeRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TimerRole.js
var require_TimerRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TimerRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TimerRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "timer"
        }
      }],
      type: "structure"
    };
    var _default = TimerRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ToggleButtonRole.js
var require_ToggleButtonRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ToggleButtonRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ToggleButtonRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          attributes: [{
            name: "aria-pressed"
          }]
        }
      }],
      type: "widget"
    };
    var _default = ToggleButtonRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ToolbarRole.js
var require_ToolbarRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/ToolbarRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var ToolbarRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "toolbar"
        }
      }],
      type: "structure"
    };
    var _default = ToolbarRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TreeRole.js
var require_TreeRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TreeRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TreeRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "tree"
        }
      }],
      type: "widget"
    };
    var _default = TreeRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TreeGridRole.js
var require_TreeGridRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TreeGridRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TreeGridRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "treegrid"
        }
      }],
      type: "widget"
    };
    var _default = TreeGridRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TreeItemRole.js
var require_TreeItemRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/TreeItemRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TreeItemRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "treeitem"
        }
      }],
      type: "widget"
    };
    var _default = TreeItemRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/UserInterfaceTooltipRole.js
var require_UserInterfaceTooltipRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/UserInterfaceTooltipRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var UserInterfaceTooltipRole = {
      relatedConcepts: [{
        module: "ARIA",
        concept: {
          name: "tooltip"
        }
      }],
      type: "structure"
    };
    var _default = UserInterfaceTooltipRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/VideoRole.js
var require_VideoRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/VideoRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var VideoRole = {
      relatedConcepts: [{
        module: "HTML",
        concept: {
          name: "video"
        }
      }],
      type: "widget"
    };
    var _default = VideoRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/WebAreaRole.js
var require_WebAreaRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/WebAreaRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var WebAreaRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = WebAreaRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/WindowRole.js
var require_WindowRole = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/etc/objects/WindowRole.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var WindowRole = {
      relatedConcepts: [],
      type: "window"
    };
    var _default = WindowRole;
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/AXObjectsMap.js
var require_AXObjectsMap = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/AXObjectsMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator2());
    var _AbbrRole = _interopRequireDefault(require_AbbrRole());
    var _AlertDialogRole = _interopRequireDefault(require_AlertDialogRole());
    var _AlertRole = _interopRequireDefault(require_AlertRole());
    var _AnnotationRole = _interopRequireDefault(require_AnnotationRole());
    var _ApplicationRole = _interopRequireDefault(require_ApplicationRole());
    var _ArticleRole = _interopRequireDefault(require_ArticleRole());
    var _AudioRole = _interopRequireDefault(require_AudioRole());
    var _BannerRole = _interopRequireDefault(require_BannerRole());
    var _BlockquoteRole = _interopRequireDefault(require_BlockquoteRole());
    var _BusyIndicatorRole = _interopRequireDefault(require_BusyIndicatorRole());
    var _ButtonRole = _interopRequireDefault(require_ButtonRole());
    var _CanvasRole = _interopRequireDefault(require_CanvasRole());
    var _CaptionRole = _interopRequireDefault(require_CaptionRole());
    var _CellRole = _interopRequireDefault(require_CellRole());
    var _CheckBoxRole = _interopRequireDefault(require_CheckBoxRole());
    var _ColorWellRole = _interopRequireDefault(require_ColorWellRole());
    var _ColumnHeaderRole = _interopRequireDefault(require_ColumnHeaderRole());
    var _ColumnRole = _interopRequireDefault(require_ColumnRole());
    var _ComboBoxRole = _interopRequireDefault(require_ComboBoxRole());
    var _ComplementaryRole = _interopRequireDefault(require_ComplementaryRole());
    var _ContentInfoRole = _interopRequireDefault(require_ContentInfoRole());
    var _DateRole = _interopRequireDefault(require_DateRole());
    var _DateTimeRole = _interopRequireDefault(require_DateTimeRole());
    var _DefinitionRole = _interopRequireDefault(require_DefinitionRole());
    var _DescriptionListDetailRole = _interopRequireDefault(require_DescriptionListDetailRole());
    var _DescriptionListRole = _interopRequireDefault(require_DescriptionListRole());
    var _DescriptionListTermRole = _interopRequireDefault(require_DescriptionListTermRole());
    var _DetailsRole = _interopRequireDefault(require_DetailsRole());
    var _DialogRole = _interopRequireDefault(require_DialogRole());
    var _DirectoryRole = _interopRequireDefault(require_DirectoryRole());
    var _DisclosureTriangleRole = _interopRequireDefault(require_DisclosureTriangleRole());
    var _DivRole = _interopRequireDefault(require_DivRole());
    var _DocumentRole = _interopRequireDefault(require_DocumentRole());
    var _EmbeddedObjectRole = _interopRequireDefault(require_EmbeddedObjectRole());
    var _FeedRole = _interopRequireDefault(require_FeedRole());
    var _FigcaptionRole = _interopRequireDefault(require_FigcaptionRole());
    var _FigureRole = _interopRequireDefault(require_FigureRole());
    var _FooterRole = _interopRequireDefault(require_FooterRole());
    var _FormRole = _interopRequireDefault(require_FormRole());
    var _GridRole = _interopRequireDefault(require_GridRole());
    var _GroupRole = _interopRequireDefault(require_GroupRole());
    var _HeadingRole = _interopRequireDefault(require_HeadingRole());
    var _IframePresentationalRole = _interopRequireDefault(require_IframePresentationalRole());
    var _IframeRole = _interopRequireDefault(require_IframeRole());
    var _IgnoredRole = _interopRequireDefault(require_IgnoredRole());
    var _ImageMapLinkRole = _interopRequireDefault(require_ImageMapLinkRole());
    var _ImageMapRole = _interopRequireDefault(require_ImageMapRole());
    var _ImageRole = _interopRequireDefault(require_ImageRole());
    var _InlineTextBoxRole = _interopRequireDefault(require_InlineTextBoxRole());
    var _InputTimeRole = _interopRequireDefault(require_InputTimeRole());
    var _LabelRole = _interopRequireDefault(require_LabelRole());
    var _LegendRole = _interopRequireDefault(require_LegendRole());
    var _LineBreakRole = _interopRequireDefault(require_LineBreakRole());
    var _LinkRole = _interopRequireDefault(require_LinkRole());
    var _ListBoxOptionRole = _interopRequireDefault(require_ListBoxOptionRole());
    var _ListBoxRole = _interopRequireDefault(require_ListBoxRole());
    var _ListItemRole = _interopRequireDefault(require_ListItemRole());
    var _ListMarkerRole = _interopRequireDefault(require_ListMarkerRole());
    var _ListRole = _interopRequireDefault(require_ListRole());
    var _LogRole = _interopRequireDefault(require_LogRole());
    var _MainRole = _interopRequireDefault(require_MainRole());
    var _MarkRole = _interopRequireDefault(require_MarkRole());
    var _MarqueeRole = _interopRequireDefault(require_MarqueeRole());
    var _MathRole = _interopRequireDefault(require_MathRole());
    var _MenuBarRole = _interopRequireDefault(require_MenuBarRole());
    var _MenuButtonRole = _interopRequireDefault(require_MenuButtonRole());
    var _MenuItemRole = _interopRequireDefault(require_MenuItemRole());
    var _MenuItemCheckBoxRole = _interopRequireDefault(require_MenuItemCheckBoxRole());
    var _MenuItemRadioRole = _interopRequireDefault(require_MenuItemRadioRole());
    var _MenuListOptionRole = _interopRequireDefault(require_MenuListOptionRole());
    var _MenuListPopupRole = _interopRequireDefault(require_MenuListPopupRole());
    var _MenuRole = _interopRequireDefault(require_MenuRole());
    var _MeterRole = _interopRequireDefault(require_MeterRole());
    var _NavigationRole = _interopRequireDefault(require_NavigationRole());
    var _NoneRole = _interopRequireDefault(require_NoneRole());
    var _NoteRole = _interopRequireDefault(require_NoteRole());
    var _OutlineRole = _interopRequireDefault(require_OutlineRole());
    var _ParagraphRole = _interopRequireDefault(require_ParagraphRole());
    var _PopUpButtonRole = _interopRequireDefault(require_PopUpButtonRole());
    var _PreRole = _interopRequireDefault(require_PreRole());
    var _PresentationalRole = _interopRequireDefault(require_PresentationalRole());
    var _ProgressIndicatorRole = _interopRequireDefault(require_ProgressIndicatorRole());
    var _RadioButtonRole = _interopRequireDefault(require_RadioButtonRole());
    var _RadioGroupRole = _interopRequireDefault(require_RadioGroupRole());
    var _RegionRole = _interopRequireDefault(require_RegionRole());
    var _RootWebAreaRole = _interopRequireDefault(require_RootWebAreaRole());
    var _RowHeaderRole = _interopRequireDefault(require_RowHeaderRole());
    var _RowRole = _interopRequireDefault(require_RowRole());
    var _RubyRole = _interopRequireDefault(require_RubyRole());
    var _RulerRole = _interopRequireDefault(require_RulerRole());
    var _ScrollAreaRole = _interopRequireDefault(require_ScrollAreaRole());
    var _ScrollBarRole = _interopRequireDefault(require_ScrollBarRole());
    var _SeamlessWebAreaRole = _interopRequireDefault(require_SeamlessWebAreaRole());
    var _SearchRole = _interopRequireDefault(require_SearchRole());
    var _SearchBoxRole = _interopRequireDefault(require_SearchBoxRole());
    var _SliderRole = _interopRequireDefault(require_SliderRole());
    var _SliderThumbRole = _interopRequireDefault(require_SliderThumbRole());
    var _SpinButtonRole = _interopRequireDefault(require_SpinButtonRole());
    var _SpinButtonPartRole = _interopRequireDefault(require_SpinButtonPartRole());
    var _SplitterRole = _interopRequireDefault(require_SplitterRole());
    var _StaticTextRole = _interopRequireDefault(require_StaticTextRole());
    var _StatusRole = _interopRequireDefault(require_StatusRole());
    var _SVGRootRole = _interopRequireDefault(require_SVGRootRole());
    var _SwitchRole = _interopRequireDefault(require_SwitchRole());
    var _TabGroupRole = _interopRequireDefault(require_TabGroupRole());
    var _TabRole = _interopRequireDefault(require_TabRole());
    var _TableHeaderContainerRole = _interopRequireDefault(require_TableHeaderContainerRole());
    var _TableRole = _interopRequireDefault(require_TableRole());
    var _TabListRole = _interopRequireDefault(require_TabListRole());
    var _TabPanelRole = _interopRequireDefault(require_TabPanelRole());
    var _TermRole = _interopRequireDefault(require_TermRole());
    var _TextAreaRole = _interopRequireDefault(require_TextAreaRole());
    var _TextFieldRole = _interopRequireDefault(require_TextFieldRole());
    var _TimeRole = _interopRequireDefault(require_TimeRole());
    var _TimerRole = _interopRequireDefault(require_TimerRole());
    var _ToggleButtonRole = _interopRequireDefault(require_ToggleButtonRole());
    var _ToolbarRole = _interopRequireDefault(require_ToolbarRole());
    var _TreeRole = _interopRequireDefault(require_TreeRole());
    var _TreeGridRole = _interopRequireDefault(require_TreeGridRole());
    var _TreeItemRole = _interopRequireDefault(require_TreeItemRole());
    var _UserInterfaceTooltipRole = _interopRequireDefault(require_UserInterfaceTooltipRole());
    var _VideoRole = _interopRequireDefault(require_VideoRole());
    var _WebAreaRole = _interopRequireDefault(require_WebAreaRole());
    var _WindowRole = _interopRequireDefault(require_WindowRole());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null) return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    var AXObjects2 = [["AbbrRole", _AbbrRole.default], ["AlertDialogRole", _AlertDialogRole.default], ["AlertRole", _AlertRole.default], ["AnnotationRole", _AnnotationRole.default], ["ApplicationRole", _ApplicationRole.default], ["ArticleRole", _ArticleRole.default], ["AudioRole", _AudioRole.default], ["BannerRole", _BannerRole.default], ["BlockquoteRole", _BlockquoteRole.default], ["BusyIndicatorRole", _BusyIndicatorRole.default], ["ButtonRole", _ButtonRole.default], ["CanvasRole", _CanvasRole.default], ["CaptionRole", _CaptionRole.default], ["CellRole", _CellRole.default], ["CheckBoxRole", _CheckBoxRole.default], ["ColorWellRole", _ColorWellRole.default], ["ColumnHeaderRole", _ColumnHeaderRole.default], ["ColumnRole", _ColumnRole.default], ["ComboBoxRole", _ComboBoxRole.default], ["ComplementaryRole", _ComplementaryRole.default], ["ContentInfoRole", _ContentInfoRole.default], ["DateRole", _DateRole.default], ["DateTimeRole", _DateTimeRole.default], ["DefinitionRole", _DefinitionRole.default], ["DescriptionListDetailRole", _DescriptionListDetailRole.default], ["DescriptionListRole", _DescriptionListRole.default], ["DescriptionListTermRole", _DescriptionListTermRole.default], ["DetailsRole", _DetailsRole.default], ["DialogRole", _DialogRole.default], ["DirectoryRole", _DirectoryRole.default], ["DisclosureTriangleRole", _DisclosureTriangleRole.default], ["DivRole", _DivRole.default], ["DocumentRole", _DocumentRole.default], ["EmbeddedObjectRole", _EmbeddedObjectRole.default], ["FeedRole", _FeedRole.default], ["FigcaptionRole", _FigcaptionRole.default], ["FigureRole", _FigureRole.default], ["FooterRole", _FooterRole.default], ["FormRole", _FormRole.default], ["GridRole", _GridRole.default], ["GroupRole", _GroupRole.default], ["HeadingRole", _HeadingRole.default], ["IframePresentationalRole", _IframePresentationalRole.default], ["IframeRole", _IframeRole.default], ["IgnoredRole", _IgnoredRole.default], ["ImageMapLinkRole", _ImageMapLinkRole.default], ["ImageMapRole", _ImageMapRole.default], ["ImageRole", _ImageRole.default], ["InlineTextBoxRole", _InlineTextBoxRole.default], ["InputTimeRole", _InputTimeRole.default], ["LabelRole", _LabelRole.default], ["LegendRole", _LegendRole.default], ["LineBreakRole", _LineBreakRole.default], ["LinkRole", _LinkRole.default], ["ListBoxOptionRole", _ListBoxOptionRole.default], ["ListBoxRole", _ListBoxRole.default], ["ListItemRole", _ListItemRole.default], ["ListMarkerRole", _ListMarkerRole.default], ["ListRole", _ListRole.default], ["LogRole", _LogRole.default], ["MainRole", _MainRole.default], ["MarkRole", _MarkRole.default], ["MarqueeRole", _MarqueeRole.default], ["MathRole", _MathRole.default], ["MenuBarRole", _MenuBarRole.default], ["MenuButtonRole", _MenuButtonRole.default], ["MenuItemRole", _MenuItemRole.default], ["MenuItemCheckBoxRole", _MenuItemCheckBoxRole.default], ["MenuItemRadioRole", _MenuItemRadioRole.default], ["MenuListOptionRole", _MenuListOptionRole.default], ["MenuListPopupRole", _MenuListPopupRole.default], ["MenuRole", _MenuRole.default], ["MeterRole", _MeterRole.default], ["NavigationRole", _NavigationRole.default], ["NoneRole", _NoneRole.default], ["NoteRole", _NoteRole.default], ["OutlineRole", _OutlineRole.default], ["ParagraphRole", _ParagraphRole.default], ["PopUpButtonRole", _PopUpButtonRole.default], ["PreRole", _PreRole.default], ["PresentationalRole", _PresentationalRole.default], ["ProgressIndicatorRole", _ProgressIndicatorRole.default], ["RadioButtonRole", _RadioButtonRole.default], ["RadioGroupRole", _RadioGroupRole.default], ["RegionRole", _RegionRole.default], ["RootWebAreaRole", _RootWebAreaRole.default], ["RowHeaderRole", _RowHeaderRole.default], ["RowRole", _RowRole.default], ["RubyRole", _RubyRole.default], ["RulerRole", _RulerRole.default], ["ScrollAreaRole", _ScrollAreaRole.default], ["ScrollBarRole", _ScrollBarRole.default], ["SeamlessWebAreaRole", _SeamlessWebAreaRole.default], ["SearchRole", _SearchRole.default], ["SearchBoxRole", _SearchBoxRole.default], ["SliderRole", _SliderRole.default], ["SliderThumbRole", _SliderThumbRole.default], ["SpinButtonRole", _SpinButtonRole.default], ["SpinButtonPartRole", _SpinButtonPartRole.default], ["SplitterRole", _SplitterRole.default], ["StaticTextRole", _StaticTextRole.default], ["StatusRole", _StatusRole.default], ["SVGRootRole", _SVGRootRole.default], ["SwitchRole", _SwitchRole.default], ["TabGroupRole", _TabGroupRole.default], ["TabRole", _TabRole.default], ["TableHeaderContainerRole", _TableHeaderContainerRole.default], ["TableRole", _TableRole.default], ["TabListRole", _TabListRole.default], ["TabPanelRole", _TabPanelRole.default], ["TermRole", _TermRole.default], ["TextAreaRole", _TextAreaRole.default], ["TextFieldRole", _TextFieldRole.default], ["TimeRole", _TimeRole.default], ["TimerRole", _TimerRole.default], ["ToggleButtonRole", _ToggleButtonRole.default], ["ToolbarRole", _ToolbarRole.default], ["TreeRole", _TreeRole.default], ["TreeGridRole", _TreeGridRole.default], ["TreeItemRole", _TreeItemRole.default], ["UserInterfaceTooltipRole", _UserInterfaceTooltipRole.default], ["VideoRole", _VideoRole.default], ["WebAreaRole", _WebAreaRole.default], ["WindowRole", _WindowRole.default]];
    var AXObjectsMap = {
      entries: function entries() {
        return AXObjects2;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        for (var _i = 0, _AXObjects = AXObjects2; _i < _AXObjects.length; _i++) {
          var _AXObjects$_i = _slicedToArray(_AXObjects[_i], 2), key2 = _AXObjects$_i[0], values = _AXObjects$_i[1];
          fn.call(thisArg, values, key2, AXObjects2);
        }
      },
      get: function get2(key2) {
        var item = AXObjects2.find(function(tuple) {
          return tuple[0] === key2 ? true : false;
        });
        return item && item[1];
      },
      has: function has(key2) {
        return !!AXObjectsMap.get(key2);
      },
      keys: function keys2() {
        return AXObjects2.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key2 = _ref2[0];
          return key2;
        });
      },
      values: function values() {
        return AXObjects2.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = (0, _iterationDecorator.default)(AXObjectsMap, AXObjectsMap.entries());
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/AXObjectElementMap.js
var require_AXObjectElementMap = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/AXObjectElementMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator2());
    var _AXObjectsMap = _interopRequireDefault(require_AXObjectsMap());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null) return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it2 = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it2) {
        if (Array.isArray(o) || (it2 = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it2) o = it2;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e2(_e2) {
            throw _e2;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it2 = it2.call(o);
      }, n: function n() {
        var step = it2.next();
        normalCompletion = step.done;
        return step;
      }, e: function e2(_e3) {
        didErr = true;
        err = _e3;
      }, f: function f() {
        try {
          if (!normalCompletion && it2.return != null) it2.return();
        } finally {
          if (didErr) throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var AXObjectElements = [];
    var _iterator = _createForOfIteratorHelper(_AXObjectsMap.default.entries());
    var _step;
    try {
      _loop = function _loop2() {
        var _step$value = _slicedToArray(_step.value, 2), name2 = _step$value[0], def = _step$value[1];
        var relatedConcepts = def.relatedConcepts;
        if (Array.isArray(relatedConcepts)) {
          relatedConcepts.forEach(function(relation) {
            if (relation.module === "HTML") {
              var concept = relation.concept;
              if (concept) {
                var index2 = AXObjectElements.findIndex(function(_ref5) {
                  var _ref6 = _slicedToArray(_ref5, 1), key2 = _ref6[0];
                  return key2 === name2;
                });
                if (index2 === -1) {
                  AXObjectElements.push([name2, []]);
                  index2 = AXObjectElements.length - 1;
                }
                AXObjectElements[index2][1].push(concept);
              }
            }
          });
        }
      };
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        _loop();
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var _loop;
    var AXObjectElementMap = {
      entries: function entries() {
        return AXObjectElements;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        for (var _i = 0, _AXObjectElements = AXObjectElements; _i < _AXObjectElements.length; _i++) {
          var _AXObjectElements$_i = _slicedToArray(_AXObjectElements[_i], 2), key2 = _AXObjectElements$_i[0], values = _AXObjectElements$_i[1];
          fn.call(thisArg, values, key2, AXObjectElements);
        }
      },
      get: function get2(key2) {
        var item = AXObjectElements.find(function(tuple) {
          return tuple[0] === key2 ? true : false;
        });
        return item && item[1];
      },
      has: function has(key2) {
        return !!AXObjectElementMap.get(key2);
      },
      keys: function keys2() {
        return AXObjectElements.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key2 = _ref2[0];
          return key2;
        });
      },
      values: function values() {
        return AXObjectElements.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = (0, _iterationDecorator.default)(AXObjectElementMap, AXObjectElementMap.entries());
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/AXObjectRoleMap.js
var require_AXObjectRoleMap = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/AXObjectRoleMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator2());
    var _AXObjectsMap = _interopRequireDefault(require_AXObjectsMap());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null) return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it2 = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it2) {
        if (Array.isArray(o) || (it2 = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it2) o = it2;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e2(_e2) {
            throw _e2;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it2 = it2.call(o);
      }, n: function n() {
        var step = it2.next();
        normalCompletion = step.done;
        return step;
      }, e: function e2(_e3) {
        didErr = true;
        err = _e3;
      }, f: function f() {
        try {
          if (!normalCompletion && it2.return != null) it2.return();
        } finally {
          if (didErr) throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var AXObjectRoleElements = [];
    var _iterator = _createForOfIteratorHelper(_AXObjectsMap.default.entries());
    var _step;
    try {
      _loop = function _loop2() {
        var _step$value = _slicedToArray(_step.value, 2), name2 = _step$value[0], def = _step$value[1];
        var relatedConcepts = def.relatedConcepts;
        if (Array.isArray(relatedConcepts)) {
          relatedConcepts.forEach(function(relation) {
            if (relation.module === "ARIA") {
              var concept = relation.concept;
              if (concept) {
                var index2 = AXObjectRoleElements.findIndex(function(_ref5) {
                  var _ref6 = _slicedToArray(_ref5, 1), key2 = _ref6[0];
                  return key2 === name2;
                });
                if (index2 === -1) {
                  AXObjectRoleElements.push([name2, []]);
                  index2 = AXObjectRoleElements.length - 1;
                }
                AXObjectRoleElements[index2][1].push(concept);
              }
            }
          });
        }
      };
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        _loop();
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var _loop;
    var AXObjectRoleMap = {
      entries: function entries() {
        return AXObjectRoleElements;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        for (var _i = 0, _AXObjectRoleElements = AXObjectRoleElements; _i < _AXObjectRoleElements.length; _i++) {
          var _AXObjectRoleElements2 = _slicedToArray(_AXObjectRoleElements[_i], 2), key2 = _AXObjectRoleElements2[0], values = _AXObjectRoleElements2[1];
          fn.call(thisArg, values, key2, AXObjectRoleElements);
        }
      },
      get: function get2(key2) {
        var item = AXObjectRoleElements.find(function(tuple) {
          return tuple[0] === key2 ? true : false;
        });
        return item && item[1];
      },
      has: function has(key2) {
        return !!AXObjectRoleMap.get(key2);
      },
      keys: function keys2() {
        return AXObjectRoleElements.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key2 = _ref2[0];
          return key2;
        });
      },
      values: function values() {
        return AXObjectRoleElements.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = (0, _iterationDecorator.default)(AXObjectRoleMap, AXObjectRoleMap.entries());
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/elementAXObjectMap.js
var require_elementAXObjectMap = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/elementAXObjectMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _AXObjectsMap = _interopRequireDefault(require_AXObjectsMap());
    var _iterationDecorator = _interopRequireDefault(require_iterationDecorator2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null) return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it2 = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it2) {
        if (Array.isArray(o) || (it2 = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it2) o = it2;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e2(_e2) {
            throw _e2;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it2 = it2.call(o);
      }, n: function n() {
        var step = it2.next();
        normalCompletion = step.done;
        return step;
      }, e: function e2(_e3) {
        didErr = true;
        err = _e3;
      }, f: function f() {
        try {
          if (!normalCompletion && it2.return != null) it2.return();
        } finally {
          if (didErr) throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var elementAXObjects3 = [];
    var _iterator = _createForOfIteratorHelper(_AXObjectsMap.default.entries());
    var _step;
    try {
      _loop = function _loop2() {
        var _step$value = _slicedToArray(_step.value, 2), name2 = _step$value[0], def = _step$value[1];
        var relatedConcepts = def.relatedConcepts;
        if (Array.isArray(relatedConcepts)) {
          relatedConcepts.forEach(function(relation) {
            if (relation.module === "HTML") {
              var concept = relation.concept;
              if (concept != null) {
                var conceptStr = JSON.stringify(concept);
                var axObjects;
                var index2 = 0;
                for (; index2 < elementAXObjects3.length; index2++) {
                  var key2 = elementAXObjects3[index2][0];
                  if (JSON.stringify(key2) === conceptStr) {
                    axObjects = elementAXObjects3[index2][1];
                    break;
                  }
                }
                if (!Array.isArray(axObjects)) {
                  axObjects = [];
                }
                var loc = axObjects.findIndex(function(item) {
                  return item === name2;
                });
                if (loc === -1) {
                  axObjects.push(name2);
                }
                if (index2 < elementAXObjects3.length) {
                  elementAXObjects3.splice(index2, 1, [concept, axObjects]);
                } else {
                  elementAXObjects3.push([concept, axObjects]);
                }
              }
            }
          });
        }
      };
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        _loop();
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var _loop;
    function deepAxObjectModelRelationshipConceptAttributeCheck(a, b) {
      if (a === void 0 && b !== void 0) {
        return false;
      }
      if (a !== void 0 && b === void 0) {
        return false;
      }
      if (a !== void 0 && b !== void 0) {
        if (a.length != b.length) {
          return false;
        }
        for (var i = 0; i < a.length; i++) {
          if (b[i].name !== a[i].name || b[i].value !== a[i].value) {
            return false;
          }
        }
      }
      return true;
    }
    var elementAXObjectMap = {
      entries: function entries() {
        return elementAXObjects3;
      },
      forEach: function forEach(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        for (var _i = 0, _elementAXObjects = elementAXObjects3; _i < _elementAXObjects.length; _i++) {
          var _elementAXObjects$_i = _slicedToArray(_elementAXObjects[_i], 2), key2 = _elementAXObjects$_i[0], values = _elementAXObjects$_i[1];
          fn.call(thisArg, values, key2, elementAXObjects3);
        }
      },
      get: function get2(key2) {
        var item = elementAXObjects3.find(function(tuple) {
          return key2.name === tuple[0].name && deepAxObjectModelRelationshipConceptAttributeCheck(key2.attributes, tuple[0].attributes);
        });
        return item && item[1];
      },
      has: function has(key2) {
        return !!elementAXObjectMap.get(key2);
      },
      keys: function keys2() {
        return elementAXObjects3.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key2 = _ref2[0];
          return key2;
        });
      },
      values: function values() {
        return elementAXObjects3.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = (0, _iterationDecorator.default)(elementAXObjectMap, elementAXObjectMap.entries());
    exports.default = _default;
  }
});

// node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/.deno/axobject-query@4.1.0/node_modules/axobject-query/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.elementAXObjects = exports.AXObjects = exports.AXObjectRoles = exports.AXObjectElements = void 0;
    var _AXObjectElementMap = _interopRequireDefault(require_AXObjectElementMap());
    var _AXObjectRoleMap = _interopRequireDefault(require_AXObjectRoleMap());
    var _AXObjectsMap = _interopRequireDefault(require_AXObjectsMap());
    var _elementAXObjectMap = _interopRequireDefault(require_elementAXObjectMap());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var AXObjectElements = _AXObjectElementMap.default;
    exports.AXObjectElements = AXObjectElements;
    var AXObjectRoles2 = _AXObjectRoleMap.default;
    exports.AXObjectRoles = AXObjectRoles2;
    var AXObjects2 = _AXObjectsMap.default;
    exports.AXObjects = AXObjects2;
    var elementAXObjects3 = _elementAXObjectMap.default;
    exports.elementAXObjects = elementAXObjects3;
  }
});

// node_modules/.deno/@jridgewell+resolve-uri@3.1.2/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js
var require_resolve_uri_umd = __commonJS({
  "node_modules/.deno/@jridgewell+resolve-uri@3.1.2/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js"(exports, module) {
    (function(global2, factory2) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory2() : typeof define === "function" && define.amd ? define(factory2) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.resolveURI = factory2());
    })(exports, (function() {
      "use strict";
      const schemeRegex = /^[\w+.-]+:\/\//;
      const urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
      const fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
      function isAbsoluteUrl2(input) {
        return schemeRegex.test(input);
      }
      function isSchemeRelativeUrl(input) {
        return input.startsWith("//");
      }
      function isAbsolutePath(input) {
        return input.startsWith("/");
      }
      function isFileUrl(input) {
        return input.startsWith("file:");
      }
      function isRelative(input) {
        return /^[.?#]/.test(input);
      }
      function parseAbsoluteUrl(input) {
        const match = urlRegex.exec(input);
        return makeUrl(match[1], match[2] || "", match[3], match[4] || "", match[5] || "/", match[6] || "", match[7] || "");
      }
      function parseFileUrl(input) {
        const match = fileRegex.exec(input);
        const path2 = match[2];
        return makeUrl("file:", "", match[1] || "", "", isAbsolutePath(path2) ? path2 : "/" + path2, match[3] || "", match[4] || "");
      }
      function makeUrl(scheme, user, host, port, path2, query, hash2) {
        return {
          scheme,
          user,
          host,
          port,
          path: path2,
          query,
          hash: hash2,
          type: 7
        };
      }
      function parseUrl(input) {
        if (isSchemeRelativeUrl(input)) {
          const url3 = parseAbsoluteUrl("http:" + input);
          url3.scheme = "";
          url3.type = 6;
          return url3;
        }
        if (isAbsolutePath(input)) {
          const url3 = parseAbsoluteUrl("http://foo.com" + input);
          url3.scheme = "";
          url3.host = "";
          url3.type = 5;
          return url3;
        }
        if (isFileUrl(input))
          return parseFileUrl(input);
        if (isAbsoluteUrl2(input))
          return parseAbsoluteUrl(input);
        const url2 = parseAbsoluteUrl("http://foo.com/" + input);
        url2.scheme = "";
        url2.host = "";
        url2.type = input ? input.startsWith("?") ? 3 : input.startsWith("#") ? 2 : 4 : 1;
        return url2;
      }
      function stripPathFilename(path2) {
        if (path2.endsWith("/.."))
          return path2;
        const index2 = path2.lastIndexOf("/");
        return path2.slice(0, index2 + 1);
      }
      function mergePaths(url2, base) {
        normalizePath(base, base.type);
        if (url2.path === "/") {
          url2.path = base.path;
        } else {
          url2.path = stripPathFilename(base.path) + url2.path;
        }
      }
      function normalizePath(url2, type2) {
        const rel = type2 <= 4;
        const pieces = url2.path.split("/");
        let pointer = 1;
        let positive = 0;
        let addTrailingSlash = false;
        for (let i = 1; i < pieces.length; i++) {
          const piece = pieces[i];
          if (!piece) {
            addTrailingSlash = true;
            continue;
          }
          addTrailingSlash = false;
          if (piece === ".")
            continue;
          if (piece === "..") {
            if (positive) {
              addTrailingSlash = true;
              positive--;
              pointer--;
            } else if (rel) {
              pieces[pointer++] = piece;
            }
            continue;
          }
          pieces[pointer++] = piece;
          positive++;
        }
        let path2 = "";
        for (let i = 1; i < pointer; i++) {
          path2 += "/" + pieces[i];
        }
        if (!path2 || addTrailingSlash && !path2.endsWith("/..")) {
          path2 += "/";
        }
        url2.path = path2;
      }
      function resolve(input, base) {
        if (!input && !base)
          return "";
        const url2 = parseUrl(input);
        let inputType = url2.type;
        if (base && inputType !== 7) {
          const baseUrl = parseUrl(base);
          const baseType = baseUrl.type;
          switch (inputType) {
            case 1:
              url2.hash = baseUrl.hash;
            // fall through
            case 2:
              url2.query = baseUrl.query;
            // fall through
            case 3:
            case 4:
              mergePaths(url2, baseUrl);
            // fall through
            case 5:
              url2.user = baseUrl.user;
              url2.host = baseUrl.host;
              url2.port = baseUrl.port;
            // fall through
            case 6:
              url2.scheme = baseUrl.scheme;
          }
          if (baseType > inputType)
            inputType = baseType;
        }
        normalizePath(url2, inputType);
        const queryHash = url2.query + url2.hash;
        switch (inputType) {
          // This is impossible, because of the empty checks at the start of the function.
          // case UrlType.Empty:
          case 2:
          case 3:
            return queryHash;
          case 4: {
            const path2 = url2.path.slice(1);
            if (!path2)
              return queryHash || ".";
            if (isRelative(base || input) && !isRelative(path2)) {
              return "./" + path2 + queryHash;
            }
            return path2 + queryHash;
          }
          case 5:
            return url2.path + queryHash;
          default:
            return url2.scheme + "//" + url2.user + url2.host + url2.port + url2.path + queryHash;
        }
      }
      return resolve;
    }));
  }
});

// browser-external:util
var require_util = __commonJS({
  "browser-external:util"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key2) {
        if (key2 !== "__esModule" && key2 !== "__proto__" && key2 !== "constructor" && key2 !== "splice") {
          console.warn(`Module "util" has been externalized for browser compatibility. Cannot access "util.${key2}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/.deno/zimmerframe@1.1.4/node_modules/zimmerframe/src/walk.js
function walk(node, state, visitors) {
  const universal = visitors._;
  let stopped = false;
  function default_visitor(_, { next: next2, state: state2 }) {
    next2(state2);
  }
  function visit2(node2, path2, state2) {
    if (stopped) return;
    if (!node2.type) return;
    let result;
    const mutations = {};
    const context2 = {
      path: path2,
      state: state2,
      next: (next_state = state2) => {
        path2.push(node2);
        for (const key2 in node2) {
          if (key2 === "type") continue;
          const child_node = node2[key2];
          if (child_node && typeof child_node === "object") {
            if (Array.isArray(child_node)) {
              const array_mutations = {};
              const len = child_node.length;
              let mutated = false;
              for (let i = 0; i < len; i++) {
                const node3 = child_node[i];
                if (node3 && typeof node3 === "object") {
                  const result2 = visit2(node3, path2, next_state);
                  if (result2) {
                    array_mutations[i] = result2;
                    mutated = true;
                  }
                }
              }
              if (mutated) {
                mutations[key2] = child_node.map(
                  (node3, i) => array_mutations[i] ?? node3
                );
              }
            } else {
              const result2 = visit2(
                /** @type {T} */
                child_node,
                path2,
                next_state
              );
              if (result2) {
                mutations[key2] = result2;
              }
            }
          }
        }
        path2.pop();
        if (Object.keys(mutations).length > 0) {
          return apply_mutations(node2, mutations);
        }
      },
      stop: () => {
        stopped = true;
      },
      visit: (next_node, next_state = state2) => {
        path2.push(node2);
        const result2 = visit2(next_node, path2, next_state) ?? next_node;
        path2.pop();
        return result2;
      }
    };
    let visitor = (
      /** @type {Visitor<T, U, T>} */
      visitors[
        /** @type {T['type']} */
        node2.type
      ] ?? default_visitor
    );
    if (universal) {
      let inner_result;
      result = universal(node2, {
        ...context2,
        /** @param {U} next_state */
        next: (next_state = state2) => {
          state2 = next_state;
          inner_result = visitor(node2, {
            ...context2,
            state: next_state
          });
          return inner_result;
        }
      });
      if (!result && inner_result) {
        result = inner_result;
      }
    } else {
      result = visitor(node2, context2);
    }
    if (!result) {
      if (Object.keys(mutations).length > 0) {
        result = apply_mutations(node2, mutations);
      }
    }
    if (result) {
      return result;
    }
  }
  return visit2(node, [], state) ?? node;
}
function apply_mutations(node, mutations) {
  const obj = {};
  const descriptors = Object.getOwnPropertyDescriptors(node);
  for (const key2 in descriptors) {
    Object.defineProperty(obj, key2, descriptors[key2]);
  }
  for (const key2 in mutations) {
    obj[key2] = mutations[key2];
  }
  return (
    /** @type {T} */
    obj
  );
}

// node_modules/.deno/svelte@5.43.8/node_modules/svelte/src/compiler/phases/patterns.js
var regex_whitespace = /\s/;
var regex_starts_with_whitespaces = /^[ \t\r\n]+/;
var regex_ends_with_whitespaces = /[ \t\r\n]+$/;
var regex_not_whitespace = /[^ \t\r\n]/;
var regex_not_newline_characters = /[^\n]/g;

// node_modules/.deno/svelte@5.43.8/node_modules/svelte/src/compiler/phases/1-parse/utils/fuzzymatch.js
function fuzzymatch(name2, names) {
  if (names.length === 0) return null;
  const set3 = new FuzzySet(names);
  const matches = set3.get(name2);
  return matches && matches[0][0] > 0.7 ? matches[0][1] : null;
}
var GRAM_SIZE_LOWER = 2;
var GRAM_SIZE_UPPER = 3;
function _distance(str1, str2) {
  if (str1 === null && str2 === null) {
    throw "Trying to compare two null values";
  }
  if (str1 === null || str2 === null) return 0;
  str1 = String(str1);
  str2 = String(str2);
  const distance = levenshtein(str1, str2);
  return 1 - distance / Math.max(str1.length, str2.length);
}
function levenshtein(str1, str2) {
  const current2 = [];
  let prev = 0;
  let value = 0;
  for (let i = 0; i <= str2.length; i++) {
    for (let j = 0; j <= str1.length; j++) {
      if (i && j) {
        if (str1.charAt(j - 1) === str2.charAt(i - 1)) {
          value = prev;
        } else {
          value = Math.min(current2[j], current2[j - 1], prev) + 1;
        }
      } else {
        value = i + j;
      }
      prev = current2[j];
      current2[j] = value;
    }
  }
  return (
    /** @type {number} */
    current2.pop()
  );
}
var non_word_regex = /[^\w, ]+/;
function iterate_grams(value, gram_size = 2) {
  const simplified = "-" + value.toLowerCase().replace(non_word_regex, "") + "-";
  const len_diff = gram_size - simplified.length;
  const results = [];
  if (len_diff > 0) {
    for (let i = 0; i < len_diff; ++i) {
      value += "-";
    }
  }
  for (let i = 0; i < simplified.length - gram_size + 1; ++i) {
    results.push(simplified.slice(i, i + gram_size));
  }
  return results;
}
function gram_counter(value, gram_size = 2) {
  const result = {};
  const grams = iterate_grams(value, gram_size);
  let i = 0;
  for (i; i < grams.length; ++i) {
    if (grams[i] in result) {
      result[grams[i]] += 1;
    } else {
      result[grams[i]] = 1;
    }
  }
  return result;
}
function sort_descending(a, b) {
  return b[0] - a[0];
}
var FuzzySet = class {
  /** @type {Record<string, string>} */
  exact_set = {};
  /** @type {Record<string, [number, number][]>} */
  match_dict = {};
  /** @type {Record<string, number[]>} */
  items = {};
  /** @param {string[]} arr */
  constructor(arr) {
    for (let i = GRAM_SIZE_LOWER; i < GRAM_SIZE_UPPER + 1; ++i) {
      this.items[i] = [];
    }
    for (let i = 0; i < arr.length; ++i) {
      this.add(arr[i]);
    }
  }
  /** @param {string} value */
  add(value) {
    const normalized_value = value.toLowerCase();
    if (normalized_value in this.exact_set) {
      return false;
    }
    let i = GRAM_SIZE_LOWER;
    for (i; i < GRAM_SIZE_UPPER + 1; ++i) {
      this._add(value, i);
    }
  }
  /**
   * @param {string} value
   * @param {number} gram_size
   */
  _add(value, gram_size) {
    const normalized_value = value.toLowerCase();
    const items = this.items[gram_size] || [];
    const index2 = items.length;
    items.push(0);
    const gram_counts = gram_counter(normalized_value, gram_size);
    let sum_of_square_gram_counts = 0;
    let gram;
    let gram_count;
    for (gram in gram_counts) {
      gram_count = gram_counts[gram];
      sum_of_square_gram_counts += Math.pow(gram_count, 2);
      if (gram in this.match_dict) {
        this.match_dict[gram].push([index2, gram_count]);
      } else {
        this.match_dict[gram] = [[index2, gram_count]];
      }
    }
    const vector_normal = Math.sqrt(sum_of_square_gram_counts);
    items[index2] = [vector_normal, normalized_value];
    this.items[gram_size] = items;
    this.exact_set[normalized_value] = value;
  }
  /** @param {string} value */
  get(value) {
    const normalized_value = value.toLowerCase();
    const result = this.exact_set[normalized_value];
    if (result) {
      return (
        /** @type {MatchTuple[]} */
        [[1, result]]
      );
    }
    for (let gram_size = GRAM_SIZE_UPPER; gram_size >= GRAM_SIZE_LOWER; --gram_size) {
      const results = this.__get(value, gram_size);
      if (results.length > 0) return results;
    }
    return null;
  }
  /**
   * @param {string} value
   * @param {number} gram_size
   * @returns {MatchTuple[]}
   */
  __get(value, gram_size) {
    const normalized_value = value.toLowerCase();
    const matches = {};
    const gram_counts = gram_counter(normalized_value, gram_size);
    const items = this.items[gram_size];
    let sum_of_square_gram_counts = 0;
    let gram;
    let gram_count;
    let i;
    let index2;
    let other_gram_count;
    for (gram in gram_counts) {
      gram_count = gram_counts[gram];
      sum_of_square_gram_counts += Math.pow(gram_count, 2);
      if (gram in this.match_dict) {
        for (i = 0; i < this.match_dict[gram].length; ++i) {
          index2 = this.match_dict[gram][i][0];
          other_gram_count = this.match_dict[gram][i][1];
          if (index2 in matches) {
            matches[index2] += gram_count * other_gram_count;
          } else {
            matches[index2] = gram_count * other_gram_count;
          }
        }
      }
    }
    const vector_normal = Math.sqrt(sum_of_square_gram_counts);
    let results = [];
    let match_score;
    for (const match_index in matches) {
      match_score = matches[match_index];
      results.push([match_score / (vector_normal * items[match_index][0]), items[match_index][1]]);
    }
    results.sort(sort_descending);
    let new_results = [];
    const end_index = Math.min(50, results.length);
    for (let i2 = 0; i2 < end_index; ++i2) {
      new_results.push([_distance(results[i2][1], normalized_value), results[i2][1]]);
    }
    results = new_results;
    results.sort(sort_descending);
    new_results = [];
    for (let i2 = 0; i2 < results.length; ++i2) {
      if (results[i2][0] === results[0][0]) {
        new_results.push([results[i2][0], this.exact_set[results[i2][1]]]);
      }
    }
    return new_results;
  }
};

// node_modules/.deno/locate-character@3.0.0/node_modules/locate-character/src/index.js
function rangeContains(range2, index2) {
  return range2.start <= index2 && index2 < range2.end;
}
function getLocator(source2, options2 = {}) {
  const { offsetLine = 0, offsetColumn = 0 } = options2;
  let start2 = 0;
  const ranges = source2.split("\n").map((line, i2) => {
    const end2 = start2 + line.length + 1;
    const range2 = { start: start2, end: end2, line: i2 };
    start2 = end2;
    return range2;
  });
  let i = 0;
  function locator2(search, index2) {
    if (typeof search === "string") {
      search = source2.indexOf(search, index2 ?? 0);
    }
    if (search === -1) return void 0;
    let range2 = ranges[i];
    const d = search >= range2.end ? 1 : -1;
    while (range2) {
      if (rangeContains(range2, search)) {
        return {
          line: offsetLine + range2.line,
          column: offsetColumn + search - range2.start,
          character: search
        };
      }
      i += d;
      range2 = ranges[i];
    }
  }
  return locator2;
}

// node_modules/.deno/svelte@5.43.8/node_modules/svelte/src/compiler/state.js
var warnings = [];
var filename;
var UNKNOWN_FILENAME = "(unknown)";
var component_name = "<unknown>";
var source;
var dev;
var runes = false;
var locator = getLocator("", { offsetLine: 1 });
function set_source(value) {
  source = value;
  locator = getLocator(source, { offsetLine: 1 });
}
var warning_filter;
var ignore_stack = [];
var ignore_map = /* @__PURE__ */ new Map();
function reset(state) {
  dev = false;
  runes = false;
  component_name = UNKNOWN_FILENAME;
  source = "";
  locator = () => void 0;
  filename = (state.filename ?? UNKNOWN_FILENAME).replace(/\\/g, "/");
  warning_filter = state.warning ?? (() => true);
  warnings = [];
}

// node_modules/.deno/svelte@5.43.8/node_modules/svelte/src/compiler/utils/compile_diagnostic.js
var regex_tabs = /^\t+/;
function tabs_to_spaces(str2) {
  return str2.replace(regex_tabs, (match) => match.split("	").join("  "));
}
function get_code_frame(source2, line, column) {
  const lines = source2.split("\n");
  const frame_start = Math.max(0, line - 2);
  const frame_end = Math.min(line + 3, lines.length);
  const digits = String(frame_end + 1).length;
  return lines.slice(frame_start, frame_end).map((str2, i) => {
    const is_error_line = frame_start + i === line;
    const line_num = String(i + frame_start + 1).padStart(digits, " ");
    if (is_error_line) {
      const indicator = " ".repeat(digits + 2 + tabs_to_spaces(str2.slice(0, column)).length) + "^";
      return `${line_num}: ${tabs_to_spaces(str2)}
${indicator}`;
    }
    return `${line_num}: ${tabs_to_spaces(str2)}`;
  }).join("\n");
}
var CompileDiagnostic = class {
  name = "CompileDiagnostic";
  /**
   * @param {string} code
   * @param {string} message
   * @param {[number, number] | undefined} position
   */
  constructor(code2, message2, position2) {
    this.code = code2;
    this.message = message2;
    if (filename !== UNKNOWN_FILENAME) {
      this.filename = filename;
    }
    if (position2) {
      this.position = position2;
      this.start = locator(position2[0]);
      this.end = locator(position2[1]);
      if (this.start && this.end) {
        this.frame = get_code_frame(source, this.start.line - 1, this.end.column);
      }
    }
  }
  toString() {
    let out = `${this.code}: ${this.message}`;
    if (this.filename) {
      out += `
${this.filename}`;
      if (this.start) {
        out += `:${this.start.line}:${this.start.column}`;
      }
    }
    if (this.frame) {
      out += `
${this.frame}`;
    }
    return out;
  }
  toJSON() {
    return {
      code: this.code,
      message: this.message,
      filename: this.filename,
      start: this.start,
      end: this.end,
      position: this.position,
      frame: this.frame
    };
  }
};

// node_modules/.deno/svelte@5.43.8/node_modules/svelte/src/compiler/warnings.js
var InternalCompileWarning = class extends CompileDiagnostic {
  name = "CompileWarning";
  /**
   * @param {string} code
   * @param {string} message
   * @param {[number, number] | undefined} position
   */
  constructor(code2, message2, position2) {
    super(code2, message2, position2);
  }
};
function w(node, code2, message2) {
  let stack = ignore_stack;
  if (node) {
    stack = ignore_map.get(node) ?? ignore_stack;
  }
  if (stack && stack.at(-1)?.has(code2)) return;
  const warning = new InternalCompileWarning(code2, message2, node && node.start !== void 0 ? [node.start, node.end ?? node.start] : void 0);
  if (!warning_filter(warning)) return;
  warnings.push(warning);
}
var codes = [
  "a11y_accesskey",
  "a11y_aria_activedescendant_has_tabindex",
  "a11y_aria_attributes",
  "a11y_autocomplete_valid",
  "a11y_autofocus",
  "a11y_click_events_have_key_events",
  "a11y_consider_explicit_label",
  "a11y_distracting_elements",
  "a11y_figcaption_index",
  "a11y_figcaption_parent",
  "a11y_hidden",
  "a11y_img_redundant_alt",
  "a11y_incorrect_aria_attribute_type",
  "a11y_incorrect_aria_attribute_type_boolean",
  "a11y_incorrect_aria_attribute_type_id",
  "a11y_incorrect_aria_attribute_type_idlist",
  "a11y_incorrect_aria_attribute_type_integer",
  "a11y_incorrect_aria_attribute_type_token",
  "a11y_incorrect_aria_attribute_type_tokenlist",
  "a11y_incorrect_aria_attribute_type_tristate",
  "a11y_interactive_supports_focus",
  "a11y_invalid_attribute",
  "a11y_label_has_associated_control",
  "a11y_media_has_caption",
  "a11y_misplaced_role",
  "a11y_misplaced_scope",
  "a11y_missing_attribute",
  "a11y_missing_content",
  "a11y_mouse_events_have_key_events",
  "a11y_no_abstract_role",
  "a11y_no_interactive_element_to_noninteractive_role",
  "a11y_no_noninteractive_element_interactions",
  "a11y_no_noninteractive_element_to_interactive_role",
  "a11y_no_noninteractive_tabindex",
  "a11y_no_redundant_roles",
  "a11y_no_static_element_interactions",
  "a11y_positive_tabindex",
  "a11y_role_has_required_aria_props",
  "a11y_role_supports_aria_props",
  "a11y_role_supports_aria_props_implicit",
  "a11y_unknown_aria_attribute",
  "a11y_unknown_role",
  "bidirectional_control_characters",
  "legacy_code",
  "unknown_code",
  "options_deprecated_accessors",
  "options_deprecated_immutable",
  "options_missing_custom_element",
  "options_removed_enable_sourcemap",
  "options_removed_hydratable",
  "options_removed_loop_guard_timeout",
  "options_renamed_ssr_dom",
  "custom_element_props_identifier",
  "export_let_unused",
  "legacy_component_creation",
  "non_reactive_update",
  "perf_avoid_inline_class",
  "perf_avoid_nested_class",
  "reactive_declaration_invalid_placement",
  "reactive_declaration_module_script_dependency",
  "state_referenced_locally",
  "store_rune_conflict",
  "css_unused_selector",
  "attribute_avoid_is",
  "attribute_global_event_reference",
  "attribute_illegal_colon",
  "attribute_invalid_property_name",
  "attribute_quoted",
  "bind_invalid_each_rest",
  "block_empty",
  "component_name_lowercase",
  "element_implicitly_closed",
  "element_invalid_self_closing_tag",
  "event_directive_deprecated",
  "node_invalid_placement_ssr",
  "script_context_deprecated",
  "script_unknown_attribute",
  "slot_element_deprecated",
  "svelte_component_deprecated",
  "svelte_element_invalid_this",
  "svelte_self_deprecated"
];
function legacy_code(node, code2, suggestion) {
  w(node, "legacy_code", `\`${code2}\` is no longer valid  please use \`${suggestion}\` instead
https://svelte.dev/e/legacy_code`);
}
function unknown_code(node, code2, suggestion) {
  w(node, "unknown_code", `${suggestion ? `\`${code2}\` is not a recognised code (did you mean \`${suggestion}\`?)` : `\`${code2}\` is not a recognised code`}
https://svelte.dev/e/unknown_code`);
}
function options_deprecated_accessors(node) {
  w(node, "options_deprecated_accessors", `The \`accessors\` option has been deprecated. It will have no effect in runes mode
https://svelte.dev/e/options_deprecated_accessors`);
}
function options_deprecated_immutable(node) {
  w(node, "options_deprecated_immutable", `The \`immutable\` option has been deprecated. It will have no effect in runes mode
https://svelte.dev/e/options_deprecated_immutable`);
}
function options_removed_enable_sourcemap(node) {
  w(node, "options_removed_enable_sourcemap", `The \`enableSourcemap\` option has been removed. Source maps are always generated now, and tooling can choose to ignore them
https://svelte.dev/e/options_removed_enable_sourcemap`);
}
function options_removed_hydratable(node) {
  w(node, "options_removed_hydratable", `The \`hydratable\` option has been removed. Svelte components are always hydratable now
https://svelte.dev/e/options_removed_hydratable`);
}
function options_removed_loop_guard_timeout(node) {
  w(node, "options_removed_loop_guard_timeout", `The \`loopGuardTimeout\` option has been removed
https://svelte.dev/e/options_removed_loop_guard_timeout`);
}
function options_renamed_ssr_dom(node) {
  w(node, "options_renamed_ssr_dom", `\`generate: "dom"\` and \`generate: "ssr"\` options have been renamed to "client" and "server" respectively
https://svelte.dev/e/options_renamed_ssr_dom`);
}
function element_implicitly_closed(node, tag3, closing2) {
  w(node, "element_implicitly_closed", `This element is implicitly closed by the following \`${tag3}\`, which can cause an unexpected DOM structure. Add an explicit \`${closing2}\` to avoid surprises.
https://svelte.dev/e/element_implicitly_closed`);
}
function script_unknown_attribute(node) {
  w(node, "script_unknown_attribute", `Unrecognized attribute  should be one of \`generics\`, \`lang\` or \`module\`. If this exists for a preprocessor, ensure that the preprocessor removes it
https://svelte.dev/e/script_unknown_attribute`);
}
function svelte_element_invalid_this(node) {
  w(node, "svelte_element_invalid_this", `\`this\` should be an \`{expression}\`. Using a string attribute value will cause an error in future versions of Svelte
https://svelte.dev/e/svelte_element_invalid_this`);
}

// node_modules/.deno/svelte@5.43.8/node_modules/svelte/src/compiler/utils/extract_svelte_ignore.js
var regex_svelte_ignore = /^\s*svelte-ignore\s/;
var replacements = {
  "non-top-level-reactive-declaration": "reactive_declaration_invalid_placement",
  "module-script-reactive-declaration": "reactive_declaration_module_script",
  "empty-block": "block_empty",
  "avoid-is": "attribute_avoid_is",
  "invalid-html-attribute": "attribute_invalid_property_name",
  "a11y-structure": "a11y_figcaption_parent",
  "illegal-attribute-character": "attribute_illegal_colon",
  "invalid-rest-eachblock-binding": "bind_invalid_each_rest",
  "unused-export-let": "export_let_unused"
};
var codes2 = codes.concat(IGNORABLE_RUNTIME_WARNINGS);
function extract_svelte_ignore(offset2, text3, runes2) {
  const match = regex_svelte_ignore.exec(text3);
  if (!match) return [];
  let length = match[0].length;
  offset2 += length;
  const ignores = [];
  if (runes2) {
    for (const match2 of text3.slice(length).matchAll(/([\w$-]+)(,)?/gm)) {
      const code2 = match2[1];
      if (codes2.includes(code2)) {
        ignores.push(code2);
      } else {
        const replacement = replacements[code2] ?? code2.replace(/-/g, "_");
        const start2 = offset2 + /** @type {number} */
        match2.index;
        const end2 = start2 + code2.length;
        if (codes2.includes(replacement)) {
          legacy_code({ start: start2, end: end2 }, code2, replacement);
        } else {
          const suggestion = fuzzymatch(code2, codes2);
          unknown_code({ start: start2, end: end2 }, code2, suggestion);
        }
      }
      if (!match2[2]) {
        break;
      }
    }
  } else {
    for (const match2 of text3.slice(length).matchAll(/[\w$-]+/gm)) {
      const code2 = match2[0];
      ignores.push(code2);
      if (!codes2.includes(code2)) {
        const replacement = replacements[code2] ?? code2.replace(/-/g, "_");
        if (codes2.includes(replacement)) {
          ignores.push(replacement);
        }
      }
    }
  }
  return ignores;
}

// node_modules/.deno/svelte@5.43.8/node_modules/svelte/src/compiler/legacy.js
function remove_surrounding_whitespace_nodes(nodes) {
  const first2 = nodes.at(0);
  const last = nodes.at(-1);
  if (first2?.type === "Text") {
    if (!regex_not_whitespace.test(first2.data)) {
      nodes.shift();
    } else {
      first2.data = first2.data.replace(regex_starts_with_whitespaces, "");
    }
  }
  if (last?.type === "Text") {
    if (!regex_not_whitespace.test(last.data)) {
      nodes.pop();
    } else {
      last.data = last.data.replace(regex_ends_with_whitespaces, "");
    }
  }
}
function convert(source2, ast2) {
  const root2 = (
    /** @type {AST.SvelteNode | Legacy.LegacySvelteNode} */
    ast2
  );
  return (
    /** @type {Legacy.LegacyRoot} */
    walk(root2, null, {
      _(node, { next: next2 }) {
        delete node.metadata;
        next2();
      },
      // @ts-ignore
      Root(node, { visit: visit2 }) {
        const { instance, module, options: options2 } = node;
        if (
          /** @type {any} */
          options2?.__raw__
        ) {
          let idx = node.fragment.nodes.findIndex(
            (node2) => (
              /** @type {any} */
              options2.end <= node2.start
            )
          );
          if (idx === -1) {
            idx = node.fragment.nodes.length;
          }
          node.fragment.nodes.splice(
            idx,
            0,
            /** @type {any} */
            options2.__raw__
          );
        }
        let start2 = null;
        let end2 = null;
        if (node.fragment.nodes.length > 0) {
          const first2 = (
            /** @type {AST.BaseNode} */
            node.fragment.nodes.at(0)
          );
          const last = (
            /** @type {AST.BaseNode} */
            node.fragment.nodes.at(-1)
          );
          start2 = first2.start;
          end2 = last.end;
          while (/\s/.test(source2[start2])) start2 += 1;
          while (/\s/.test(source2[end2 - 1])) end2 -= 1;
        }
        if (instance) {
          delete instance.attributes;
        }
        if (module) {
          delete module.attributes;
        }
        return {
          html: {
            type: "Fragment",
            start: start2,
            end: end2,
            children: node.fragment.nodes.map((child) => visit2(child))
          },
          instance,
          module,
          css: ast2.css ? visit2(ast2.css) : void 0
        };
      },
      AnimateDirective(node) {
        return { ...node, type: "Animation" };
      },
      // @ts-ignore
      AwaitBlock(node, { visit: visit2 }) {
        let pendingblock = {
          type: "PendingBlock",
          /** @type {number | null} */
          start: null,
          /** @type {number | null} */
          end: null,
          children: node.pending?.nodes.map((child) => visit2(child)) ?? [],
          skip: true
        };
        let thenblock = {
          type: "ThenBlock",
          /** @type {number | null} */
          start: null,
          /** @type {number | null} */
          end: null,
          children: node.then?.nodes.map((child) => visit2(child)) ?? [],
          skip: true
        };
        let catchblock = {
          type: "CatchBlock",
          /** @type {number | null} */
          start: null,
          /** @type {number | null} */
          end: null,
          children: node.catch?.nodes.map((child) => visit2(child)) ?? [],
          skip: true
        };
        if (node.pending) {
          const first2 = node.pending.nodes.at(0);
          const last = node.pending.nodes.at(-1);
          pendingblock.start = first2?.start ?? source2.indexOf("}", node.expression.end) + 1;
          pendingblock.end = last?.end ?? pendingblock.start;
          pendingblock.skip = false;
        }
        if (node.then) {
          const first2 = node.then.nodes.at(0);
          const last = node.then.nodes.at(-1);
          thenblock.start = pendingblock.end ?? first2?.start ?? source2.indexOf("}", node.expression.end) + 1;
          thenblock.end = last?.end ?? source2.lastIndexOf("}", pendingblock.end ?? node.expression.end) + 1;
          thenblock.skip = false;
        }
        if (node.catch) {
          const first2 = node.catch.nodes.at(0);
          const last = node.catch.nodes.at(-1);
          catchblock.start = thenblock.end ?? pendingblock.end ?? first2?.start ?? source2.indexOf("}", node.expression.end) + 1;
          catchblock.end = last?.end ?? source2.lastIndexOf("}", thenblock.end ?? pendingblock.end ?? node.expression.end) + 1;
          catchblock.skip = false;
        }
        return {
          type: "AwaitBlock",
          start: node.start,
          end: node.end,
          expression: node.expression,
          value: node.value,
          error: node.error,
          pending: pendingblock,
          then: thenblock,
          catch: catchblock
        };
      },
      BindDirective(node) {
        return { ...node, type: "Binding" };
      },
      ClassDirective(node) {
        return { ...node, type: "Class" };
      },
      Comment(node) {
        return {
          ...node,
          ignores: extract_svelte_ignore(node.start, node.data, false)
        };
      },
      ComplexSelector(node, { next: next2 }) {
        next2();
        const children = [];
        for (const child of node.children) {
          if (child.combinator) {
            children.push(child.combinator);
          }
          children.push(...child.selectors);
        }
        return {
          type: "Selector",
          start: node.start,
          end: node.end,
          children
        };
      },
      Component(node, { visit: visit2 }) {
        return {
          type: "InlineComponent",
          start: node.start,
          end: node.end,
          name: node.name,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit2(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit2(child)
            )
          )
        };
      },
      // @ts-ignore
      ConstTag(node) {
        if (
          /** @type {Legacy.LegacyConstTag} */
          node.expression !== void 0
        ) {
          return node;
        }
        const modern_node = (
          /** @type {AST.ConstTag} */
          node
        );
        const { id: left } = { ...modern_node.declaration.declarations[0] };
        delete left.typeAnnotation;
        return {
          type: "ConstTag",
          start: modern_node.start,
          end: node.end,
          expression: {
            type: "AssignmentExpression",
            start: (modern_node.declaration.start ?? 0) + "const ".length,
            end: modern_node.declaration.end ?? 0,
            operator: "=",
            left,
            right: modern_node.declaration.declarations[0].init
          }
        };
      },
      // @ts-ignore
      KeyBlock(node, { visit: visit2 }) {
        remove_surrounding_whitespace_nodes(node.fragment.nodes);
        return {
          type: "KeyBlock",
          start: node.start,
          end: node.end,
          expression: node.expression,
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit2(child)
            )
          )
        };
      },
      // @ts-ignore
      EachBlock(node, { visit: visit2 }) {
        let elseblock = void 0;
        if (node.fallback) {
          const first2 = node.fallback.nodes.at(0);
          const end2 = source2.lastIndexOf(
            "{",
            /** @type {number} */
            node.end - 1
          );
          const start2 = first2?.start ?? end2;
          remove_surrounding_whitespace_nodes(node.fallback.nodes);
          elseblock = {
            type: "ElseBlock",
            start: start2,
            end: end2,
            children: node.fallback.nodes.map((child) => visit2(child))
          };
        }
        remove_surrounding_whitespace_nodes(node.body.nodes);
        return {
          type: "EachBlock",
          start: node.start,
          end: node.end,
          children: node.body.nodes.map((child) => visit2(child)),
          context: node.context,
          expression: node.expression,
          index: node.index,
          key: node.key,
          else: elseblock
        };
      },
      ExpressionTag(node, { path: path2 }) {
        const parent = path2.at(-1);
        if (parent?.type === "Attribute") {
          if (source2[parent.start] === "{") {
            return {
              type: "AttributeShorthand",
              start: node.start,
              end: node.end,
              expression: node.expression
            };
          }
        }
        return {
          type: "MustacheTag",
          start: node.start,
          end: node.end,
          expression: node.expression
        };
      },
      HtmlTag(node) {
        return { ...node, type: "RawMustacheTag" };
      },
      // @ts-ignore
      IfBlock(node, { visit: visit2 }) {
        let elseblock = void 0;
        if (node.alternate) {
          let nodes = node.alternate.nodes;
          if (nodes.length === 1 && nodes[0].type === "IfBlock" && nodes[0].elseif) {
            nodes = nodes[0].consequent.nodes;
          }
          const end2 = source2.lastIndexOf(
            "{",
            /** @type {number} */
            node.end - 1
          );
          const start3 = nodes.at(0)?.start ?? end2;
          remove_surrounding_whitespace_nodes(node.alternate.nodes);
          elseblock = {
            type: "ElseBlock",
            start: start3,
            end: end2,
            children: node.alternate.nodes.map(
              (child) => (
                /** @type {Legacy.LegacyElementLike} */
                visit2(child)
              )
            )
          };
        }
        const start2 = node.elseif ? node.consequent.nodes[0]?.start ?? source2.lastIndexOf(
          "{",
          /** @type {number} */
          node.end - 1
        ) : node.start;
        remove_surrounding_whitespace_nodes(node.consequent.nodes);
        return {
          type: "IfBlock",
          start: start2,
          end: node.end,
          expression: node.test,
          children: node.consequent.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit2(child)
            )
          ),
          else: elseblock,
          elseif: node.elseif ? true : void 0
        };
      },
      OnDirective(node) {
        return { ...node, type: "EventHandler" };
      },
      // @ts-expect-error
      SnippetBlock(node, { visit: visit2 }) {
        remove_surrounding_whitespace_nodes(node.body.nodes);
        return {
          type: "SnippetBlock",
          start: node.start,
          end: node.end,
          expression: node.expression,
          parameters: node.parameters,
          children: node.body.nodes.map((child) => visit2(child)),
          typeParams: node.typeParams
        };
      },
      // @ts-expect-error
      SvelteBoundary(node, { visit: visit2 }) {
        remove_surrounding_whitespace_nodes(node.fragment.nodes);
        return {
          type: "SvelteBoundary",
          name: "svelte:boundary",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit2(child)
            )
          ),
          children: node.fragment.nodes.map((child) => visit2(child))
        };
      },
      RegularElement(node, { visit: visit2 }) {
        return {
          type: "Element",
          start: node.start,
          end: node.end,
          name: node.name,
          attributes: node.attributes.map((child) => visit2(child)),
          children: node.fragment.nodes.map((child) => visit2(child))
        };
      },
      SlotElement(node, { visit: visit2 }) {
        return {
          type: "Slot",
          start: node.start,
          end: node.end,
          name: node.name,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit2(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit2(child)
            )
          )
        };
      },
      Attribute(node, { visit: visit2, next: next2, path: path2 }) {
        if (node.value !== true && !Array.isArray(node.value)) {
          path2.push(node);
          const value = (
            /** @type {Legacy.LegacyAttribute['value']} */
            [visit2(node.value)]
          );
          path2.pop();
          return {
            ...node,
            value
          };
        } else {
          return next2();
        }
      },
      StyleDirective(node, { visit: visit2, next: next2, path: path2 }) {
        if (node.value !== true && !Array.isArray(node.value)) {
          path2.push(node);
          const value = (
            /** @type {Legacy.LegacyStyleDirective['value']} */
            [visit2(node.value)]
          );
          path2.pop();
          return {
            ...node,
            value
          };
        } else {
          return next2();
        }
      },
      SpreadAttribute(node) {
        return { ...node, type: "Spread" };
      },
      // @ts-ignore
      StyleSheet(node, context2) {
        return {
          ...node,
          ...context2.next(),
          type: "Style"
        };
      },
      SvelteBody(node, { visit: visit2 }) {
        return {
          type: "Body",
          name: "svelte:body",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit2(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit2(child)
            )
          )
        };
      },
      SvelteComponent(node, { visit: visit2 }) {
        return {
          type: "InlineComponent",
          name: "svelte:component",
          start: node.start,
          end: node.end,
          expression: node.expression,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit2(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit2(child)
            )
          )
        };
      },
      SvelteDocument(node, { visit: visit2 }) {
        return {
          type: "Document",
          name: "svelte:document",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit2(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit2(child)
            )
          )
        };
      },
      SvelteElement(node, { visit: visit2 }) {
        let tag3 = node.tag;
        if (tag3.type === "Literal" && typeof tag3.value === "string" && source2[
          /** @type {number} */
          node.tag.start - 1
        ] !== "{") {
          tag3 = tag3.value;
        }
        return {
          type: "Element",
          name: "svelte:element",
          start: node.start,
          end: node.end,
          tag: tag3,
          attributes: node.attributes.map((child) => visit2(child)),
          children: node.fragment.nodes.map((child) => visit2(child))
        };
      },
      SvelteFragment(node, { visit: visit2 }) {
        return {
          type: "SlotTemplate",
          name: "svelte:fragment",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (a) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit2(a)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit2(child)
            )
          )
        };
      },
      SvelteHead(node, { visit: visit2 }) {
        return {
          type: "Head",
          name: "svelte:head",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit2(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit2(child)
            )
          )
        };
      },
      SvelteOptions(node, { visit: visit2 }) {
        return {
          type: "Options",
          name: "svelte:options",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit2(child)
            )
          )
        };
      },
      SvelteSelf(node, { visit: visit2 }) {
        return {
          type: "InlineComponent",
          name: "svelte:self",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit2(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit2(child)
            )
          )
        };
      },
      SvelteWindow(node, { visit: visit2 }) {
        return {
          type: "Window",
          name: "svelte:window",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit2(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit2(child)
            )
          )
        };
      },
      Text(node, { path: path2 }) {
        const parent = path2.at(-1);
        if (parent?.type === "RegularElement" && parent.name === "style") {
          return (
            /** @type {AST.Text} */
            {
              type: "Text",
              start: node.start,
              end: node.end,
              data: node.data
            }
          );
        }
      },
      TitleElement(node, { visit: visit2 }) {
        return {
          type: "Title",
          name: "title",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit2(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit2(child)
            )
          )
        };
      },
      TransitionDirective(node) {
        return { ...node, type: "Transition" };
      },
      UseDirective(node) {
        return { ...node, type: "Action" };
      },
      LetDirective(node) {
        return { ...node, type: "Let" };
      }
    })
  );
}

// node_modules/.deno/acorn@8.15.0/node_modules/acorn/dist/acorn.mjs
var acorn_exports = {};
__export(acorn_exports, {
  Node: () => Node,
  Parser: () => Parser,
  Position: () => Position,
  SourceLocation: () => SourceLocation,
  TokContext: () => TokContext,
  Token: () => Token,
  TokenType: () => TokenType,
  defaultOptions: () => defaultOptions,
  getLineInfo: () => getLineInfo,
  isIdentifierChar: () => isIdentifierChar,
  isIdentifierStart: () => isIdentifierStart,
  isNewLine: () => isNewLine,
  keywordTypes: () => keywords,
  lineBreak: () => lineBreak,
  lineBreakG: () => lineBreakG,
  nonASCIIwhitespace: () => nonASCIIwhitespace,
  parse: () => parse3,
  parseExpressionAt: () => parseExpressionAt2,
  tokContexts: () => types,
  tokTypes: () => types$1,
  tokenizer: () => tokenizer2,
  version: () => version
});
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
var nonASCIIidentifierChars = "-----------------------------------------------------------------------------------------------------------------------------------------------------";
var nonASCIIidentifierStartChars = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------";
var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};
var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
var keywords$1 = {
  5: ecma5AndLessKeywords,
  "5module": ecma5AndLessKeywords + " export import",
  6: ecma5AndLessKeywords + " const class extends export import super"
};
var keywordRelationalOperator = /^in(stanceof)?$/;
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
function isInAstralSet(code2, set3) {
  var pos = 65536;
  for (var i = 0; i < set3.length; i += 2) {
    pos += set3[i];
    if (pos > code2) {
      return false;
    }
    pos += set3[i + 1];
    if (pos >= code2) {
      return true;
    }
  }
  return false;
}
function isIdentifierStart(code2, astral) {
  if (code2 < 65) {
    return code2 === 36;
  }
  if (code2 < 91) {
    return true;
  }
  if (code2 < 97) {
    return code2 === 95;
  }
  if (code2 < 123) {
    return true;
  }
  if (code2 <= 65535) {
    return code2 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code2));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code2, astralIdentifierStartCodes);
}
function isIdentifierChar(code2, astral) {
  if (code2 < 48) {
    return code2 === 36;
  }
  if (code2 < 58) {
    return true;
  }
  if (code2 < 65) {
    return false;
  }
  if (code2 < 91) {
    return true;
  }
  if (code2 < 97) {
    return code2 === 95;
  }
  if (code2 < 123) {
    return true;
  }
  if (code2 <= 65535) {
    return code2 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code2));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code2, astralIdentifierStartCodes) || isInAstralSet(code2, astralIdentifierCodes);
}
var TokenType = function TokenType2(label, conf) {
  if (conf === void 0) conf = {};
  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};
function binop(name2, prec2) {
  return new TokenType(name2, { beforeExpr: true, binop: prec2 });
}
var beforeExpr = { beforeExpr: true };
var startsExpr = { startsExpr: true };
var keywords = {};
function kw(name2, options2) {
  if (options2 === void 0) options2 = {};
  options2.keyword = name2;
  return keywords[name2] = new TokenType(name2, options2);
}
var types$1 = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  privateId: new TokenType("privateId", startsExpr),
  eof: new TokenType("eof"),
  // Punctuation token types.
  bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  questionDot: new TokenType("?."),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.
  eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
  assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
  incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
  prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", { beforeExpr: true }),
  coalesce: binop("??", 1),
  // Keyword token types.
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", { isLoop: true, beforeExpr: true }),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", { isLoop: true }),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", { isLoop: true }),
  _with: kw("with"),
  _new: kw("new", { beforeExpr: true, startsExpr: true }),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import", startsExpr),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", { beforeExpr: true, binop: 7 }),
  _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
  _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
  _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
  _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
};
var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");
function isNewLine(code2) {
  return code2 === 10 || code2 === 13 || code2 === 8232 || code2 === 8233;
}
function nextLineBreak(code2, from, end2) {
  if (end2 === void 0) end2 = code2.length;
  for (var i = from; i < end2; i++) {
    var next2 = code2.charCodeAt(i);
    if (isNewLine(next2)) {
      return i < end2 - 1 && next2 === 13 && code2.charCodeAt(i + 1) === 10 ? i + 2 : i + 1;
    }
  }
  return -1;
}
var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var ref = Object.prototype;
var hasOwnProperty = ref.hasOwnProperty;
var toString = ref.toString;
var hasOwn = Object.hasOwn || (function(obj, propName) {
  return hasOwnProperty.call(obj, propName);
});
var isArray = Array.isArray || (function(obj) {
  return toString.call(obj) === "[object Array]";
});
var regexpCache = /* @__PURE__ */ Object.create(null);
function wordsRegexp(words) {
  return regexpCache[words] || (regexpCache[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"));
}
function codePointToString(code2) {
  if (code2 <= 65535) {
    return String.fromCharCode(code2);
  }
  code2 -= 65536;
  return String.fromCharCode((code2 >> 10) + 55296, (code2 & 1023) + 56320);
}
var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
var Position = function Position2(line, col) {
  this.line = line;
  this.column = col;
};
Position.prototype.offset = function offset(n) {
  return new Position(this.line, this.column + n);
};
var SourceLocation = function SourceLocation2(p2, start2, end2) {
  this.start = start2;
  this.end = end2;
  if (p2.sourceFile !== null) {
    this.source = p2.sourceFile;
  }
};
function getLineInfo(input, offset2) {
  for (var line = 1, cur = 0; ; ) {
    var nextBreak = nextLineBreak(input, cur, offset2);
    if (nextBreak < 0) {
      return new Position(line, offset2 - cur);
    }
    ++line;
    cur = nextBreak;
  }
}
var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
  // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
  // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
  // (the latest version the library supports). This influences
  // support for strict mode, the set of reserved words, and support
  // for new syntax features.
  ecmaVersion: null,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called when
  // a semicolon is automatically inserted. It will be passed the
  // position of the inserted semicolon as an offset, and if
  // `locations` is enabled, it is given the location as a `{line,
  // column}` object as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program, and an import.meta expression
  // in a script isn't considered an error.
  allowImportExportEverywhere: false,
  // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: null,
  // When enabled, super identifiers are not constrained to
  // appearing in methods and do not raise an error when they appear elsewhere.
  allowSuperOutsideMethod: null,
  // When enabled, hashbang directive in the beginning of file is
  // allowed and treated as a line comment. Enabled by default when
  // `ecmaVersion` >= 2023.
  allowHashBang: false,
  // By default, the parser will verify that private properties are
  // only used in places where they are valid and have been declared.
  // Set this to false to turn such checks off.
  checkPrivateFields: true,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callbackthat will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callbackthat will corrupt its internal state.
  // When this option has an array as value, objects representing the
  // comments are pushed to it.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false
};
var warnedAboutEcmaVersion = false;
function getOptions(opts) {
  var options2 = {};
  for (var opt in defaultOptions) {
    options2[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
  }
  if (options2.ecmaVersion === "latest") {
    options2.ecmaVersion = 1e8;
  } else if (options2.ecmaVersion == null) {
    if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
      warnedAboutEcmaVersion = true;
      console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
    }
    options2.ecmaVersion = 11;
  } else if (options2.ecmaVersion >= 2015) {
    options2.ecmaVersion -= 2009;
  }
  if (options2.allowReserved == null) {
    options2.allowReserved = options2.ecmaVersion < 5;
  }
  if (!opts || opts.allowHashBang == null) {
    options2.allowHashBang = options2.ecmaVersion >= 14;
  }
  if (isArray(options2.onToken)) {
    var tokens = options2.onToken;
    options2.onToken = function(token) {
      return tokens.push(token);
    };
  }
  if (isArray(options2.onComment)) {
    options2.onComment = pushComment(options2, options2.onComment);
  }
  return options2;
}
function pushComment(options2, array2) {
  return function(block3, text3, start2, end2, startLoc, endLoc) {
    var comment2 = {
      type: block3 ? "Block" : "Line",
      value: text3,
      start: start2,
      end: end2
    };
    if (options2.locations) {
      comment2.loc = new SourceLocation(this, startLoc, endLoc);
    }
    if (options2.ranges) {
      comment2.range = [start2, end2];
    }
    array2.push(comment2);
  };
}
var SCOPE_TOP = 1;
var SCOPE_FUNCTION = 2;
var SCOPE_ASYNC = 4;
var SCOPE_GENERATOR = 8;
var SCOPE_ARROW = 16;
var SCOPE_SIMPLE_CATCH = 32;
var SCOPE_SUPER = 64;
var SCOPE_DIRECT_SUPER = 128;
var SCOPE_CLASS_STATIC_BLOCK = 256;
var SCOPE_CLASS_FIELD_INIT = 512;
var SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
function functionFlags(async, generator) {
  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
}
var BIND_NONE = 0;
var BIND_VAR = 1;
var BIND_LEXICAL = 2;
var BIND_FUNCTION = 3;
var BIND_SIMPLE_CATCH = 4;
var BIND_OUTSIDE = 5;
var Parser = function Parser2(options2, input, startPos) {
  this.options = options2 = getOptions(options2);
  this.sourceFile = options2.sourceFile;
  this.keywords = wordsRegexp(keywords$1[options2.ecmaVersion >= 6 ? 6 : options2.sourceType === "module" ? "5module" : 5]);
  var reserved = "";
  if (options2.allowReserved !== true) {
    reserved = reservedWords[options2.ecmaVersion >= 6 ? 6 : options2.ecmaVersion === 5 ? 5 : 3];
    if (options2.sourceType === "module") {
      reserved += " await";
    }
  }
  this.reservedWords = wordsRegexp(reserved);
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = wordsRegexp(reservedStrict);
  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input);
  this.containsEsc = false;
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }
  this.type = types$1.eof;
  this.value = null;
  this.start = this.end = this.pos;
  this.startLoc = this.endLoc = this.curPosition();
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;
  this.context = this.initialContext();
  this.exprAllowed = true;
  this.inModule = options2.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);
  this.potentialArrowAt = -1;
  this.potentialArrowInForAwait = false;
  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
  this.labels = [];
  this.undefinedExports = /* @__PURE__ */ Object.create(null);
  if (this.pos === 0 && options2.allowHashBang && this.input.slice(0, 2) === "#!") {
    this.skipLineComment(2);
  }
  this.scopeStack = [];
  this.enterScope(SCOPE_TOP);
  this.regexpState = null;
  this.privateNameStack = [];
};
var prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
Parser.prototype.parse = function parse() {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node);
};
prototypeAccessors.inFunction.get = function() {
  return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
};
prototypeAccessors.inGenerator.get = function() {
  return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0;
};
prototypeAccessors.inAsync.get = function() {
  return (this.currentVarScope().flags & SCOPE_ASYNC) > 0;
};
prototypeAccessors.canAwait.get = function() {
  for (var i = this.scopeStack.length - 1; i >= 0; i--) {
    var ref2 = this.scopeStack[i];
    var flags = ref2.flags;
    if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT)) {
      return false;
    }
    if (flags & SCOPE_FUNCTION) {
      return (flags & SCOPE_ASYNC) > 0;
    }
  }
  return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
};
prototypeAccessors.allowSuper.get = function() {
  var ref2 = this.currentThisScope();
  var flags = ref2.flags;
  return (flags & SCOPE_SUPER) > 0 || this.options.allowSuperOutsideMethod;
};
prototypeAccessors.allowDirectSuper.get = function() {
  return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
};
prototypeAccessors.treatFunctionsAsVar.get = function() {
  return this.treatFunctionsAsVarInScope(this.currentScope());
};
prototypeAccessors.allowNewDotTarget.get = function() {
  for (var i = this.scopeStack.length - 1; i >= 0; i--) {
    var ref2 = this.scopeStack[i];
    var flags = ref2.flags;
    if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT) || flags & SCOPE_FUNCTION && !(flags & SCOPE_ARROW)) {
      return true;
    }
  }
  return false;
};
prototypeAccessors.inClassStaticBlock.get = function() {
  return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
};
Parser.extend = function extend() {
  var plugins = [], len = arguments.length;
  while (len--) plugins[len] = arguments[len];
  var cls = this;
  for (var i = 0; i < plugins.length; i++) {
    cls = plugins[i](cls);
  }
  return cls;
};
Parser.parse = function parse2(input, options2) {
  return new this(options2, input).parse();
};
Parser.parseExpressionAt = function parseExpressionAt(input, pos, options2) {
  var parser2 = new this(options2, input, pos);
  parser2.nextToken();
  return parser2.parseExpression();
};
Parser.tokenizer = function tokenizer(input, options2) {
  return new this(options2, input);
};
Object.defineProperties(Parser.prototype, prototypeAccessors);
var pp$9 = Parser.prototype;
var literal = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
pp$9.strictDirective = function(start2) {
  if (this.options.ecmaVersion < 5) {
    return false;
  }
  for (; ; ) {
    skipWhiteSpace.lastIndex = start2;
    start2 += skipWhiteSpace.exec(this.input)[0].length;
    var match = literal.exec(this.input.slice(start2));
    if (!match) {
      return false;
    }
    if ((match[1] || match[2]) === "use strict") {
      skipWhiteSpace.lastIndex = start2 + match[0].length;
      var spaceAfter = skipWhiteSpace.exec(this.input), end2 = spaceAfter.index + spaceAfter[0].length;
      var next2 = this.input.charAt(end2);
      return next2 === ";" || next2 === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next2) || next2 === "!" && this.input.charAt(end2 + 1) === "=");
    }
    start2 += match[0].length;
    skipWhiteSpace.lastIndex = start2;
    start2 += skipWhiteSpace.exec(this.input)[0].length;
    if (this.input[start2] === ";") {
      start2++;
    }
  }
};
pp$9.eat = function(type2) {
  if (this.type === type2) {
    this.next();
    return true;
  } else {
    return false;
  }
};
pp$9.isContextual = function(name2) {
  return this.type === types$1.name && this.value === name2 && !this.containsEsc;
};
pp$9.eatContextual = function(name2) {
  if (!this.isContextual(name2)) {
    return false;
  }
  this.next();
  return true;
};
pp$9.expectContextual = function(name2) {
  if (!this.eatContextual(name2)) {
    this.unexpected();
  }
};
pp$9.canInsertSemicolon = function() {
  return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$9.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon) {
      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
    }
    return true;
  }
};
pp$9.semicolon = function() {
  if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
    this.unexpected();
  }
};
pp$9.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma) {
      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
    }
    if (!notNext) {
      this.next();
    }
    return true;
  }
};
pp$9.expect = function(type2) {
  this.eat(type2) || this.unexpected();
};
pp$9.unexpected = function(pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};
var DestructuringErrors = function DestructuringErrors2() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
};
pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) {
    return;
  }
  if (refDestructuringErrors.trailingComma > -1) {
    this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
  }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) {
    this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
  }
};
pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) {
    return false;
  }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) {
    return shorthandAssign >= 0 || doubleProto >= 0;
  }
  if (shorthandAssign >= 0) {
    this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
  }
  if (doubleProto >= 0) {
    this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
  }
};
pp$9.checkYieldAwaitInDefaultParams = function() {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
    this.raise(this.yieldPos, "Yield expression cannot be a default value");
  }
  if (this.awaitPos) {
    this.raise(this.awaitPos, "Await expression cannot be a default value");
  }
};
pp$9.isSimpleAssignTarget = function(expr) {
  if (expr.type === "ParenthesizedExpression") {
    return this.isSimpleAssignTarget(expr.expression);
  }
  return expr.type === "Identifier" || expr.type === "MemberExpression";
};
var pp$8 = Parser.prototype;
pp$8.parseTopLevel = function(node) {
  var exports = /* @__PURE__ */ Object.create(null);
  if (!node.body) {
    node.body = [];
  }
  while (this.type !== types$1.eof) {
    var stmt2 = this.parseStatement(null, true, exports);
    node.body.push(stmt2);
  }
  if (this.inModule) {
    for (var i = 0, list4 = Object.keys(this.undefinedExports); i < list4.length; i += 1) {
      var name2 = list4[i];
      this.raiseRecoverable(this.undefinedExports[name2].start, "Export '" + name2 + "' is not defined");
    }
  }
  this.adaptDirectivePrologue(node.body);
  this.next();
  node.sourceType = this.options.sourceType;
  return this.finishNode(node, "Program");
};
var loopLabel = { kind: "loop" };
var switchLabel = { kind: "switch" };
pp$8.isLet = function(context2) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next2 = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next2);
  if (nextCh === 91 || nextCh === 92) {
    return true;
  }
  if (context2) {
    return false;
  }
  if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
    return true;
  }
  if (isIdentifierStart(nextCh, true)) {
    var pos = next2 + 1;
    while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) {
      ++pos;
    }
    if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
      return true;
    }
    var ident = this.input.slice(next2, pos);
    if (!keywordRelationalOperator.test(ident)) {
      return true;
    }
  }
  return false;
};
pp$8.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next2 = this.pos + skip[0].length, after2;
  return !lineBreak.test(this.input.slice(this.pos, next2)) && this.input.slice(next2, next2 + 8) === "function" && (next2 + 8 === this.input.length || !(isIdentifierChar(after2 = this.input.charCodeAt(next2 + 8)) || after2 > 55295 && after2 < 56320));
};
pp$8.isUsingKeyword = function(isAwaitUsing, isFor) {
  if (this.options.ecmaVersion < 17 || !this.isContextual(isAwaitUsing ? "await" : "using")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next2 = this.pos + skip[0].length;
  if (lineBreak.test(this.input.slice(this.pos, next2))) {
    return false;
  }
  if (isAwaitUsing) {
    var awaitEndPos = next2 + 5, after2;
    if (this.input.slice(next2, awaitEndPos) !== "using" || awaitEndPos === this.input.length || isIdentifierChar(after2 = this.input.charCodeAt(awaitEndPos)) || after2 > 55295 && after2 < 56320) {
      return false;
    }
    skipWhiteSpace.lastIndex = awaitEndPos;
    var skipAfterUsing = skipWhiteSpace.exec(this.input);
    if (skipAfterUsing && lineBreak.test(this.input.slice(awaitEndPos, awaitEndPos + skipAfterUsing[0].length))) {
      return false;
    }
  }
  if (isFor) {
    var ofEndPos = next2 + 2, after$12;
    if (this.input.slice(next2, ofEndPos) === "of") {
      if (ofEndPos === this.input.length || !isIdentifierChar(after$12 = this.input.charCodeAt(ofEndPos)) && !(after$12 > 55295 && after$12 < 56320)) {
        return false;
      }
    }
  }
  var ch = this.input.charCodeAt(next2);
  return isIdentifierStart(ch, true) || ch === 92;
};
pp$8.isAwaitUsing = function(isFor) {
  return this.isUsingKeyword(true, isFor);
};
pp$8.isUsing = function(isFor) {
  return this.isUsingKeyword(false, isFor);
};
pp$8.parseStatement = function(context2, topLevel, exports) {
  var starttype = this.type, node = this.startNode(), kind;
  if (this.isLet(context2)) {
    starttype = types$1._var;
    kind = "let";
  }
  switch (starttype) {
    case types$1._break:
    case types$1._continue:
      return this.parseBreakContinueStatement(node, starttype.keyword);
    case types$1._debugger:
      return this.parseDebuggerStatement(node);
    case types$1._do:
      return this.parseDoStatement(node);
    case types$1._for:
      return this.parseForStatement(node);
    case types$1._function:
      if (context2 && (this.strict || context2 !== "if" && context2 !== "label") && this.options.ecmaVersion >= 6) {
        this.unexpected();
      }
      return this.parseFunctionStatement(node, false, !context2);
    case types$1._class:
      if (context2) {
        this.unexpected();
      }
      return this.parseClass(node, true);
    case types$1._if:
      return this.parseIfStatement(node);
    case types$1._return:
      return this.parseReturnStatement(node);
    case types$1._switch:
      return this.parseSwitchStatement(node);
    case types$1._throw:
      return this.parseThrowStatement(node);
    case types$1._try:
      return this.parseTryStatement(node);
    case types$1._const:
    case types$1._var:
      kind = kind || this.value;
      if (context2 && kind !== "var") {
        this.unexpected();
      }
      return this.parseVarStatement(node, kind);
    case types$1._while:
      return this.parseWhileStatement(node);
    case types$1._with:
      return this.parseWithStatement(node);
    case types$1.braceL:
      return this.parseBlock(true, node);
    case types$1.semi:
      return this.parseEmptyStatement(node);
    case types$1._export:
    case types$1._import:
      if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next2 = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next2);
        if (nextCh === 40 || nextCh === 46) {
          return this.parseExpressionStatement(node, this.parseExpression());
        }
      }
      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel) {
          this.raise(this.start, "'import' and 'export' may only appear at the top level");
        }
        if (!this.inModule) {
          this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
        }
      }
      return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports);
    // If the statement does not start with a statement keyword or a
    // brace, it's an ExpressionStatement or LabeledStatement. We
    // simply start parsing an expression, and afterwards, if the
    // next token is a colon and the expression was a simple
    // Identifier node, we switch to interpreting it as a label.
    default:
      if (this.isAsyncFunction()) {
        if (context2) {
          this.unexpected();
        }
        this.next();
        return this.parseFunctionStatement(node, true, !context2);
      }
      var usingKind = this.isAwaitUsing(false) ? "await using" : this.isUsing(false) ? "using" : null;
      if (usingKind) {
        if (topLevel && this.options.sourceType === "script") {
          this.raise(this.start, "Using declaration cannot appear in the top level when source type is `script`");
        }
        if (usingKind === "await using") {
          if (!this.canAwait) {
            this.raise(this.start, "Await using cannot appear outside of async function");
          }
          this.next();
        }
        this.next();
        this.parseVar(node, false, usingKind);
        this.semicolon();
        return this.finishNode(node, "VariableDeclaration");
      }
      var maybeName = this.value, expr = this.parseExpression();
      if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
        return this.parseLabeledStatement(node, maybeName, expr, context2);
      } else {
        return this.parseExpressionStatement(node, expr);
      }
  }
};
pp$8.parseBreakContinueStatement = function(node, keyword) {
  var isBreak = keyword === "break";
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node.label = null;
  } else if (this.type !== types$1.name) {
    this.unexpected();
  } else {
    node.label = this.parseIdent();
    this.semicolon();
  }
  var i = 0;
  for (; i < this.labels.length; ++i) {
    var lab = this.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) {
        break;
      }
      if (node.label && isBreak) {
        break;
      }
    }
  }
  if (i === this.labels.length) {
    this.raise(node.start, "Unsyntactic " + keyword);
  }
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
};
pp$8.parseDebuggerStatement = function(node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement");
};
pp$8.parseDoStatement = function(node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("do");
  this.labels.pop();
  this.expect(types$1._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6) {
    this.eat(types$1.semi);
  } else {
    this.semicolon();
  }
  return this.finishNode(node, "DoWhileStatement");
};
pp$8.parseForStatement = function(node) {
  this.next();
  var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterScope(0);
  this.expect(types$1.parenL);
  if (this.type === types$1.semi) {
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node, null);
  }
  var isLet = this.isLet();
  if (this.type === types$1._var || this.type === types$1._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");
    return this.parseForAfterInit(node, init$1, awaitAt);
  }
  var startsWithLet = this.isContextual("let"), isForOf = false;
  var usingKind = this.isUsing(true) ? "using" : this.isAwaitUsing(true) ? "await using" : null;
  if (usingKind) {
    var init$2 = this.startNode();
    this.next();
    if (usingKind === "await using") {
      this.next();
    }
    this.parseVar(init$2, true, usingKind);
    this.finishNode(init$2, "VariableDeclaration");
    return this.parseForAfterInit(node, init$2, awaitAt);
  }
  var containsEsc = this.containsEsc;
  var refDestructuringErrors = new DestructuringErrors();
  var initPos = this.start;
  var init2 = awaitAt > -1 ? this.parseExprSubscripts(refDestructuringErrors, "await") : this.parseExpression(true, refDestructuringErrors);
  if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
    if (awaitAt > -1) {
      if (this.type === types$1._in) {
        this.unexpected(awaitAt);
      }
      node.await = true;
    } else if (isForOf && this.options.ecmaVersion >= 8) {
      if (init2.start === initPos && !containsEsc && init2.type === "Identifier" && init2.name === "async") {
        this.unexpected();
      } else if (this.options.ecmaVersion >= 9) {
        node.await = false;
      }
    }
    if (startsWithLet && isForOf) {
      this.raise(init2.start, "The left-hand side of a for-of loop may not start with 'let'.");
    }
    this.toAssignable(init2, false, refDestructuringErrors);
    this.checkLValPattern(init2);
    return this.parseForIn(node, init2);
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt > -1) {
    this.unexpected(awaitAt);
  }
  return this.parseFor(node, init2);
};
pp$8.parseForAfterInit = function(node, init2, awaitAt) {
  if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init2.declarations.length === 1) {
    if (this.options.ecmaVersion >= 9) {
      if (this.type === types$1._in) {
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
      } else {
        node.await = awaitAt > -1;
      }
    }
    return this.parseForIn(node, init2);
  }
  if (awaitAt > -1) {
    this.unexpected(awaitAt);
  }
  return this.parseFor(node, init2);
};
pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
  this.next();
  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
};
pp$8.parseIfStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  node.consequent = this.parseStatement("if");
  node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
  return this.finishNode(node, "IfStatement");
};
pp$8.parseReturnStatement = function(node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
    this.raise(this.start, "'return' outside of function");
  }
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node.argument = null;
  } else {
    node.argument = this.parseExpression();
    this.semicolon();
  }
  return this.finishNode(node, "ReturnStatement");
};
pp$8.parseSwitchStatement = function(node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types$1.braceL);
  this.labels.push(switchLabel);
  this.enterScope(0);
  var cur;
  for (var sawDefault = false; this.type !== types$1.braceR; ) {
    if (this.type === types$1._case || this.type === types$1._default) {
      var isCase = this.type === types$1._case;
      if (cur) {
        this.finishNode(cur, "SwitchCase");
      }
      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) {
          this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
        }
        sawDefault = true;
        cur.test = null;
      }
      this.expect(types$1.colon);
    } else {
      if (!cur) {
        this.unexpected();
      }
      cur.consequent.push(this.parseStatement(null));
    }
  }
  this.exitScope();
  if (cur) {
    this.finishNode(cur, "SwitchCase");
  }
  this.next();
  this.labels.pop();
  return this.finishNode(node, "SwitchStatement");
};
pp$8.parseThrowStatement = function(node) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
    this.raise(this.lastTokEnd, "Illegal newline after throw");
  }
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement");
};
var empty$1 = [];
pp$8.parseCatchClauseParam = function() {
  var param = this.parseBindingAtom();
  var simple = param.type === "Identifier";
  this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
  this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
  this.expect(types$1.parenR);
  return param;
};
pp$8.parseTryStatement = function(node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === types$1._catch) {
    var clause = this.startNode();
    this.next();
    if (this.eat(types$1.parenL)) {
      clause.param = this.parseCatchClauseParam();
    } else {
      if (this.options.ecmaVersion < 10) {
        this.unexpected();
      }
      clause.param = null;
      this.enterScope(0);
    }
    clause.body = this.parseBlock(false);
    this.exitScope();
    node.handler = this.finishNode(clause, "CatchClause");
  }
  node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
  if (!node.handler && !node.finalizer) {
    this.raise(node.start, "Missing catch or finally clause");
  }
  return this.finishNode(node, "TryStatement");
};
pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {
  this.next();
  this.parseVar(node, false, kind, allowMissingInitializer);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration");
};
pp$8.parseWhileStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("while");
  this.labels.pop();
  return this.finishNode(node, "WhileStatement");
};
pp$8.parseWithStatement = function(node) {
  if (this.strict) {
    this.raise(this.start, "'with' in strict mode");
  }
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement("with");
  return this.finishNode(node, "WithStatement");
};
pp$8.parseEmptyStatement = function(node) {
  this.next();
  return this.finishNode(node, "EmptyStatement");
};
pp$8.parseLabeledStatement = function(node, maybeName, expr, context2) {
  for (var i$1 = 0, list4 = this.labels; i$1 < list4.length; i$1 += 1) {
    var label = list4[i$1];
    if (label.name === maybeName) {
      this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    }
  }
  var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
  for (var i = this.labels.length - 1; i >= 0; i--) {
    var label$1 = this.labels[i];
    if (label$1.statementStart === node.start) {
      label$1.statementStart = this.start;
      label$1.kind = kind;
    } else {
      break;
    }
  }
  this.labels.push({ name: maybeName, kind, statementStart: this.start });
  node.body = this.parseStatement(context2 ? context2.indexOf("label") === -1 ? context2 + "label" : context2 : "label");
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement");
};
pp$8.parseExpressionStatement = function(node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement");
};
pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
  if (createNewLexicalScope === void 0) createNewLexicalScope = true;
  if (node === void 0) node = this.startNode();
  node.body = [];
  this.expect(types$1.braceL);
  if (createNewLexicalScope) {
    this.enterScope(0);
  }
  while (this.type !== types$1.braceR) {
    var stmt2 = this.parseStatement(null);
    node.body.push(stmt2);
  }
  if (exitStrict) {
    this.strict = false;
  }
  this.next();
  if (createNewLexicalScope) {
    this.exitScope();
  }
  return this.finishNode(node, "BlockStatement");
};
pp$8.parseFor = function(node, init2) {
  node.init = init2;
  this.expect(types$1.semi);
  node.test = this.type === types$1.semi ? null : this.parseExpression();
  this.expect(types$1.semi);
  node.update = this.type === types$1.parenR ? null : this.parseExpression();
  this.expect(types$1.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, "ForStatement");
};
pp$8.parseForIn = function(node, init2) {
  var isForIn = this.type === types$1._in;
  this.next();
  if (init2.type === "VariableDeclaration" && init2.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init2.kind !== "var" || init2.declarations[0].id.type !== "Identifier")) {
    this.raise(
      init2.start,
      (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
    );
  }
  node.left = init2;
  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types$1.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
};
pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {
  node.declarations = [];
  node.kind = kind;
  for (; ; ) {
    var decl = this.startNode();
    this.parseVarId(decl, kind);
    if (this.eat(types$1.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      this.unexpected();
    } else if (!allowMissingInitializer && (kind === "using" || kind === "await using") && this.options.ecmaVersion >= 17 && this.type !== types$1._in && !this.isContextual("of")) {
      this.raise(this.lastTokEnd, "Missing initializer in " + kind + " declaration");
    } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(types$1.comma)) {
      break;
    }
  }
  return node;
};
pp$8.parseVarId = function(decl, kind) {
  decl.id = kind === "using" || kind === "await using" ? this.parseIdent() : this.parseBindingAtom();
  this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};
var FUNC_STATEMENT = 1;
var FUNC_HANGING_STATEMENT = 2;
var FUNC_NULLABLE_ID = 4;
pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
    if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
      this.unexpected();
    }
    node.generator = this.eat(types$1.star);
  }
  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }
  if (statement & FUNC_STATEMENT) {
    node.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
    if (node.id && !(statement & FUNC_HANGING_STATEMENT)) {
      this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
    }
  }
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node.async, node.generator));
  if (!(statement & FUNC_STATEMENT)) {
    node.id = this.type === types$1.name ? this.parseIdent() : null;
  }
  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
};
pp$8.parseFunctionParams = function(node) {
  this.expect(types$1.parenL);
  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
};
pp$8.parseClass = function(node, isStatement) {
  this.next();
  var oldStrict = this.strict;
  this.strict = true;
  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var privateNameMap = this.enterClassBody();
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types$1.braceL);
  while (this.type !== types$1.braceR) {
    var element3 = this.parseClassElement(node.superClass !== null);
    if (element3) {
      classBody.body.push(element3);
      if (element3.type === "MethodDefinition" && element3.kind === "constructor") {
        if (hadConstructor) {
          this.raiseRecoverable(element3.start, "Duplicate constructor in the same class");
        }
        hadConstructor = true;
      } else if (element3.key && element3.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element3)) {
        this.raiseRecoverable(element3.key.start, "Identifier '#" + element3.key.name + "' has already been declared");
      }
    }
  }
  this.strict = oldStrict;
  this.next();
  node.body = this.finishNode(classBody, "ClassBody");
  this.exitClassBody();
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};
pp$8.parseClassElement = function(constructorAllowsSuper) {
  if (this.eat(types$1.semi)) {
    return null;
  }
  var ecmaVersion = this.options.ecmaVersion;
  var node = this.startNode();
  var keyName = "";
  var isGenerator = false;
  var isAsync = false;
  var kind = "method";
  var isStatic = false;
  if (this.eatContextual("static")) {
    if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
      this.parseClassStaticBlock(node);
      return node;
    }
    if (this.isClassElementNameStart() || this.type === types$1.star) {
      isStatic = true;
    } else {
      keyName = "static";
    }
  }
  node.static = isStatic;
  if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
    if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
      isAsync = true;
    } else {
      keyName = "async";
    }
  }
  if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
    isGenerator = true;
  }
  if (!keyName && !isAsync && !isGenerator) {
    var lastValue = this.value;
    if (this.eatContextual("get") || this.eatContextual("set")) {
      if (this.isClassElementNameStart()) {
        kind = lastValue;
      } else {
        keyName = lastValue;
      }
    }
  }
  if (keyName) {
    node.computed = false;
    node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
    node.key.name = keyName;
    this.finishNode(node.key, "Identifier");
  } else {
    this.parseClassElementName(node);
  }
  if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
    var isConstructor = !node.static && checkKeyName(node, "constructor");
    var allowsDirectSuper = isConstructor && constructorAllowsSuper;
    if (isConstructor && kind !== "method") {
      this.raise(node.key.start, "Constructor can't have get/set modifier");
    }
    node.kind = isConstructor ? "constructor" : kind;
    this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
  } else {
    this.parseClassField(node);
  }
  return node;
};
pp$8.isClassElementNameStart = function() {
  return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
};
pp$8.parseClassElementName = function(element3) {
  if (this.type === types$1.privateId) {
    if (this.value === "constructor") {
      this.raise(this.start, "Classes can't have an element named '#constructor'");
    }
    element3.computed = false;
    element3.key = this.parsePrivateIdent();
  } else {
    this.parsePropertyName(element3);
  }
};
pp$8.parseClassMethod = function(method2, isGenerator, isAsync, allowsDirectSuper) {
  var key2 = method2.key;
  if (method2.kind === "constructor") {
    if (isGenerator) {
      this.raise(key2.start, "Constructor can't be a generator");
    }
    if (isAsync) {
      this.raise(key2.start, "Constructor can't be an async method");
    }
  } else if (method2.static && checkKeyName(method2, "prototype")) {
    this.raise(key2.start, "Classes may not have a static property named prototype");
  }
  var value = method2.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
  if (method2.kind === "get" && value.params.length !== 0) {
    this.raiseRecoverable(value.start, "getter should have no params");
  }
  if (method2.kind === "set" && value.params.length !== 1) {
    this.raiseRecoverable(value.start, "setter should have exactly one param");
  }
  if (method2.kind === "set" && value.params[0].type === "RestElement") {
    this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
  }
  return this.finishNode(method2, "MethodDefinition");
};
pp$8.parseClassField = function(field) {
  if (checkKeyName(field, "constructor")) {
    this.raise(field.key.start, "Classes can't have a field named 'constructor'");
  } else if (field.static && checkKeyName(field, "prototype")) {
    this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
  }
  if (this.eat(types$1.eq)) {
    this.enterScope(SCOPE_CLASS_FIELD_INIT | SCOPE_SUPER);
    field.value = this.parseMaybeAssign();
    this.exitScope();
  } else {
    field.value = null;
  }
  this.semicolon();
  return this.finishNode(field, "PropertyDefinition");
};
pp$8.parseClassStaticBlock = function(node) {
  node.body = [];
  var oldLabels = this.labels;
  this.labels = [];
  this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
  while (this.type !== types$1.braceR) {
    var stmt2 = this.parseStatement(null);
    node.body.push(stmt2);
  }
  this.next();
  this.exitScope();
  this.labels = oldLabels;
  return this.finishNode(node, "StaticBlock");
};
pp$8.parseClassId = function(node, isStatement) {
  if (this.type === types$1.name) {
    node.id = this.parseIdent();
    if (isStatement) {
      this.checkLValSimple(node.id, BIND_LEXICAL, false);
    }
  } else {
    if (isStatement === true) {
      this.unexpected();
    }
    node.id = null;
  }
};
pp$8.parseClassSuper = function(node) {
  node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
};
pp$8.enterClassBody = function() {
  var element3 = { declared: /* @__PURE__ */ Object.create(null), used: [] };
  this.privateNameStack.push(element3);
  return element3.declared;
};
pp$8.exitClassBody = function() {
  var ref2 = this.privateNameStack.pop();
  var declared = ref2.declared;
  var used = ref2.used;
  if (!this.options.checkPrivateFields) {
    return;
  }
  var len = this.privateNameStack.length;
  var parent = len === 0 ? null : this.privateNameStack[len - 1];
  for (var i = 0; i < used.length; ++i) {
    var id2 = used[i];
    if (!hasOwn(declared, id2.name)) {
      if (parent) {
        parent.used.push(id2);
      } else {
        this.raiseRecoverable(id2.start, "Private field '#" + id2.name + "' must be declared in an enclosing class");
      }
    }
  }
};
function isPrivateNameConflicted(privateNameMap, element3) {
  var name2 = element3.key.name;
  var curr = privateNameMap[name2];
  var next2 = "true";
  if (element3.type === "MethodDefinition" && (element3.kind === "get" || element3.kind === "set")) {
    next2 = (element3.static ? "s" : "i") + element3.kind;
  }
  if (curr === "iget" && next2 === "iset" || curr === "iset" && next2 === "iget" || curr === "sget" && next2 === "sset" || curr === "sset" && next2 === "sget") {
    privateNameMap[name2] = "true";
    return false;
  } else if (!curr) {
    privateNameMap[name2] = next2;
    return false;
  } else {
    return true;
  }
}
function checkKeyName(node, name2) {
  var computed = node.computed;
  var key2 = node.key;
  return !computed && (key2.type === "Identifier" && key2.name === name2 || key2.type === "Literal" && key2.value === name2);
}
pp$8.parseExportAllDeclaration = function(node, exports) {
  if (this.options.ecmaVersion >= 11) {
    if (this.eatContextual("as")) {
      node.exported = this.parseModuleExportName();
      this.checkExport(exports, node.exported, this.lastTokStart);
    } else {
      node.exported = null;
    }
  }
  this.expectContextual("from");
  if (this.type !== types$1.string) {
    this.unexpected();
  }
  node.source = this.parseExprAtom();
  if (this.options.ecmaVersion >= 16) {
    node.attributes = this.parseWithClause();
  }
  this.semicolon();
  return this.finishNode(node, "ExportAllDeclaration");
};
pp$8.parseExport = function(node, exports) {
  this.next();
  if (this.eat(types$1.star)) {
    return this.parseExportAllDeclaration(node, exports);
  }
  if (this.eat(types$1._default)) {
    this.checkExport(exports, "default", this.lastTokStart);
    node.declaration = this.parseExportDefaultDeclaration();
    return this.finishNode(node, "ExportDefaultDeclaration");
  }
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseExportDeclaration(node);
    if (node.declaration.type === "VariableDeclaration") {
      this.checkVariableExport(exports, node.declaration.declarations);
    } else {
      this.checkExport(exports, node.declaration.id, node.declaration.id.start);
    }
    node.specifiers = [];
    node.source = null;
    if (this.options.ecmaVersion >= 16) {
      node.attributes = [];
    }
  } else {
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers(exports);
    if (this.eatContextual("from")) {
      if (this.type !== types$1.string) {
        this.unexpected();
      }
      node.source = this.parseExprAtom();
      if (this.options.ecmaVersion >= 16) {
        node.attributes = this.parseWithClause();
      }
    } else {
      for (var i = 0, list4 = node.specifiers; i < list4.length; i += 1) {
        var spec = list4[i];
        this.checkUnreserved(spec.local);
        this.checkLocalExport(spec.local);
        if (spec.local.type === "Literal") {
          this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
        }
      }
      node.source = null;
      if (this.options.ecmaVersion >= 16) {
        node.attributes = [];
      }
    }
    this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration");
};
pp$8.parseExportDeclaration = function(node) {
  return this.parseStatement(null);
};
pp$8.parseExportDefaultDeclaration = function() {
  var isAsync;
  if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
    var fNode = this.startNode();
    this.next();
    if (isAsync) {
      this.next();
    }
    return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
  } else if (this.type === types$1._class) {
    var cNode = this.startNode();
    return this.parseClass(cNode, "nullableID");
  } else {
    var declaration2 = this.parseMaybeAssign();
    this.semicolon();
    return declaration2;
  }
};
pp$8.checkExport = function(exports, name2, pos) {
  if (!exports) {
    return;
  }
  if (typeof name2 !== "string") {
    name2 = name2.type === "Identifier" ? name2.name : name2.value;
  }
  if (hasOwn(exports, name2)) {
    this.raiseRecoverable(pos, "Duplicate export '" + name2 + "'");
  }
  exports[name2] = true;
};
pp$8.checkPatternExport = function(exports, pat) {
  var type2 = pat.type;
  if (type2 === "Identifier") {
    this.checkExport(exports, pat, pat.start);
  } else if (type2 === "ObjectPattern") {
    for (var i = 0, list4 = pat.properties; i < list4.length; i += 1) {
      var prop3 = list4[i];
      this.checkPatternExport(exports, prop3);
    }
  } else if (type2 === "ArrayPattern") {
    for (var i$1 = 0, list$12 = pat.elements; i$1 < list$12.length; i$1 += 1) {
      var elt = list$12[i$1];
      if (elt) {
        this.checkPatternExport(exports, elt);
      }
    }
  } else if (type2 === "Property") {
    this.checkPatternExport(exports, pat.value);
  } else if (type2 === "AssignmentPattern") {
    this.checkPatternExport(exports, pat.left);
  } else if (type2 === "RestElement") {
    this.checkPatternExport(exports, pat.argument);
  }
};
pp$8.checkVariableExport = function(exports, decls) {
  if (!exports) {
    return;
  }
  for (var i = 0, list4 = decls; i < list4.length; i += 1) {
    var decl = list4[i];
    this.checkPatternExport(exports, decl.id);
  }
};
pp$8.shouldParseExportStatement = function() {
  return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
pp$8.parseExportSpecifier = function(exports) {
  var node = this.startNode();
  node.local = this.parseModuleExportName();
  node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
  this.checkExport(
    exports,
    node.exported,
    node.exported.start
  );
  return this.finishNode(node, "ExportSpecifier");
};
pp$8.parseExportSpecifiers = function(exports) {
  var nodes = [], first2 = true;
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first2) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first2 = false;
    }
    nodes.push(this.parseExportSpecifier(exports));
  }
  return nodes;
};
pp$8.parseImport = function(node) {
  this.next();
  if (this.type === types$1.string) {
    node.specifiers = empty$1;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
  }
  if (this.options.ecmaVersion >= 16) {
    node.attributes = this.parseWithClause();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration");
};
pp$8.parseImportSpecifier = function() {
  var node = this.startNode();
  node.imported = this.parseModuleExportName();
  if (this.eatContextual("as")) {
    node.local = this.parseIdent();
  } else {
    this.checkUnreserved(node.imported);
    node.local = node.imported;
  }
  this.checkLValSimple(node.local, BIND_LEXICAL);
  return this.finishNode(node, "ImportSpecifier");
};
pp$8.parseImportDefaultSpecifier = function() {
  var node = this.startNode();
  node.local = this.parseIdent();
  this.checkLValSimple(node.local, BIND_LEXICAL);
  return this.finishNode(node, "ImportDefaultSpecifier");
};
pp$8.parseImportNamespaceSpecifier = function() {
  var node = this.startNode();
  this.next();
  this.expectContextual("as");
  node.local = this.parseIdent();
  this.checkLValSimple(node.local, BIND_LEXICAL);
  return this.finishNode(node, "ImportNamespaceSpecifier");
};
pp$8.parseImportSpecifiers = function() {
  var nodes = [], first2 = true;
  if (this.type === types$1.name) {
    nodes.push(this.parseImportDefaultSpecifier());
    if (!this.eat(types$1.comma)) {
      return nodes;
    }
  }
  if (this.type === types$1.star) {
    nodes.push(this.parseImportNamespaceSpecifier());
    return nodes;
  }
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first2) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first2 = false;
    }
    nodes.push(this.parseImportSpecifier());
  }
  return nodes;
};
pp$8.parseWithClause = function() {
  var nodes = [];
  if (!this.eat(types$1._with)) {
    return nodes;
  }
  this.expect(types$1.braceL);
  var attributeKeys = {};
  var first2 = true;
  while (!this.eat(types$1.braceR)) {
    if (!first2) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first2 = false;
    }
    var attr = this.parseImportAttribute();
    var keyName = attr.key.type === "Identifier" ? attr.key.name : attr.key.value;
    if (hasOwn(attributeKeys, keyName)) {
      this.raiseRecoverable(attr.key.start, "Duplicate attribute key '" + keyName + "'");
    }
    attributeKeys[keyName] = true;
    nodes.push(attr);
  }
  return nodes;
};
pp$8.parseImportAttribute = function() {
  var node = this.startNode();
  node.key = this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
  this.expect(types$1.colon);
  if (this.type !== types$1.string) {
    this.unexpected();
  }
  node.value = this.parseExprAtom();
  return this.finishNode(node, "ImportAttribute");
};
pp$8.parseModuleExportName = function() {
  if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
    var stringLiteral = this.parseLiteral(this.value);
    if (loneSurrogate.test(stringLiteral.value)) {
      this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
    }
    return stringLiteral;
  }
  return this.parseIdent(true);
};
pp$8.adaptDirectivePrologue = function(statements) {
  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
    statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
};
pp$8.isDirectiveCandidate = function(statement) {
  return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && // Reject parenthesized strings.
  (this.input[statement.start] === '"' || this.input[statement.start] === "'");
};
var pp$7 = Parser.prototype;
pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 6 && node) {
    switch (node.type) {
      case "Identifier":
        if (this.inAsync && node.name === "await") {
          this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
        }
        break;
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        node.type = "ObjectPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        for (var i = 0, list4 = node.properties; i < list4.length; i += 1) {
          var prop3 = list4[i];
          this.toAssignable(prop3, isBinding);
          if (prop3.type === "RestElement" && (prop3.argument.type === "ArrayPattern" || prop3.argument.type === "ObjectPattern")) {
            this.raise(prop3.argument.start, "Unexpected token");
          }
        }
        break;
      case "Property":
        if (node.kind !== "init") {
          this.raise(node.key.start, "Object pattern can't contain getter or setter");
        }
        this.toAssignable(node.value, isBinding);
        break;
      case "ArrayExpression":
        node.type = "ArrayPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        this.toAssignableList(node.elements, isBinding);
        break;
      case "SpreadElement":
        node.type = "RestElement";
        this.toAssignable(node.argument, isBinding);
        if (node.argument.type === "AssignmentPattern") {
          this.raise(node.argument.start, "Rest elements cannot have a default value");
        }
        break;
      case "AssignmentExpression":
        if (node.operator !== "=") {
          this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
        }
        node.type = "AssignmentPattern";
        delete node.operator;
        this.toAssignable(node.left, isBinding);
        break;
      case "ParenthesizedExpression":
        this.toAssignable(node.expression, isBinding, refDestructuringErrors);
        break;
      case "ChainExpression":
        this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
        break;
      case "MemberExpression":
        if (!isBinding) {
          break;
        }
      default:
        this.raise(node.start, "Assigning to rvalue");
    }
  } else if (refDestructuringErrors) {
    this.checkPatternErrors(refDestructuringErrors, true);
  }
  return node;
};
pp$7.toAssignableList = function(exprList, isBinding) {
  var end2 = exprList.length;
  for (var i = 0; i < end2; i++) {
    var elt = exprList[i];
    if (elt) {
      this.toAssignable(elt, isBinding);
    }
  }
  if (end2) {
    var last = exprList[end2 - 1];
    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
      this.unexpected(last.argument.start);
    }
  }
  return exprList;
};
pp$7.parseSpread = function(refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node, "SpreadElement");
};
pp$7.parseRestBinding = function() {
  var node = this.startNode();
  this.next();
  if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
    this.unexpected();
  }
  node.argument = this.parseBindingAtom();
  return this.finishNode(node, "RestElement");
};
pp$7.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6) {
    switch (this.type) {
      case types$1.bracketL:
        var node = this.startNode();
        this.next();
        node.elements = this.parseBindingList(types$1.bracketR, true, true);
        return this.finishNode(node, "ArrayPattern");
      case types$1.braceL:
        return this.parseObj(true);
    }
  }
  return this.parseIdent();
};
pp$7.parseBindingList = function(close2, allowEmpty, allowTrailingComma, allowModifiers) {
  var elts = [], first2 = true;
  while (!this.eat(close2)) {
    if (first2) {
      first2 = false;
    } else {
      this.expect(types$1.comma);
    }
    if (allowEmpty && this.type === types$1.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close2)) {
      break;
    } else if (this.type === types$1.ellipsis) {
      var rest2 = this.parseRestBinding();
      this.parseBindingListItem(rest2);
      elts.push(rest2);
      if (this.type === types$1.comma) {
        this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
      }
      this.expect(close2);
      break;
    } else {
      elts.push(this.parseAssignableListItem(allowModifiers));
    }
  }
  return elts;
};
pp$7.parseAssignableListItem = function(allowModifiers) {
  var elem = this.parseMaybeDefault(this.start, this.startLoc);
  this.parseBindingListItem(elem);
  return elem;
};
pp$7.parseBindingListItem = function(param) {
  return param;
};
pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
    return left;
  }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern");
};
pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0) bindingType = BIND_NONE;
  var isBind = bindingType !== BIND_NONE;
  switch (expr.type) {
    case "Identifier":
      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
        this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
      }
      if (isBind) {
        if (bindingType === BIND_LEXICAL && expr.name === "let") {
          this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
        }
        if (checkClashes) {
          if (hasOwn(checkClashes, expr.name)) {
            this.raiseRecoverable(expr.start, "Argument name clash");
          }
          checkClashes[expr.name] = true;
        }
        if (bindingType !== BIND_OUTSIDE) {
          this.declareName(expr.name, bindingType, expr.start);
        }
      }
      break;
    case "ChainExpression":
      this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
      break;
    case "MemberExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding member expression");
      }
      break;
    case "ParenthesizedExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding parenthesized expression");
      }
      return this.checkLValSimple(expr.expression, bindingType, checkClashes);
    default:
      this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
  }
};
pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0) bindingType = BIND_NONE;
  switch (expr.type) {
    case "ObjectPattern":
      for (var i = 0, list4 = expr.properties; i < list4.length; i += 1) {
        var prop3 = list4[i];
        this.checkLValInnerPattern(prop3, bindingType, checkClashes);
      }
      break;
    case "ArrayPattern":
      for (var i$1 = 0, list$12 = expr.elements; i$1 < list$12.length; i$1 += 1) {
        var elem = list$12[i$1];
        if (elem) {
          this.checkLValInnerPattern(elem, bindingType, checkClashes);
        }
      }
      break;
    default:
      this.checkLValSimple(expr, bindingType, checkClashes);
  }
};
pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0) bindingType = BIND_NONE;
  switch (expr.type) {
    case "Property":
      this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
      break;
    case "AssignmentPattern":
      this.checkLValPattern(expr.left, bindingType, checkClashes);
      break;
    case "RestElement":
      this.checkLValPattern(expr.argument, bindingType, checkClashes);
      break;
    default:
      this.checkLValPattern(expr, bindingType, checkClashes);
  }
};
var TokContext = function TokContext2(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};
var types = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function(p2) {
    return p2.tryReadTemplateToken();
  }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};
var pp$6 = Parser.prototype;
pp$6.initialContext = function() {
  return [types.b_stat];
};
pp$6.curContext = function() {
  return this.context[this.context.length - 1];
};
pp$6.braceIsBlock = function(prevType) {
  var parent = this.curContext();
  if (parent === types.f_expr || parent === types.f_stat) {
    return true;
  }
  if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {
    return !parent.isExpr;
  }
  if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
    return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  }
  if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
    return true;
  }
  if (prevType === types$1.braceL) {
    return parent === types.b_stat;
  }
  if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
    return false;
  }
  return !this.exprAllowed;
};
pp$6.inGeneratorContext = function() {
  for (var i = this.context.length - 1; i >= 1; i--) {
    var context2 = this.context[i];
    if (context2.token === "function") {
      return context2.generator;
    }
  }
  return false;
};
pp$6.updateContext = function(prevType) {
  var update2, type2 = this.type;
  if (type2.keyword && prevType === types$1.dot) {
    this.exprAllowed = false;
  } else if (update2 = type2.updateContext) {
    update2.call(this, prevType);
  } else {
    this.exprAllowed = type2.beforeExpr;
  }
};
pp$6.overrideContext = function(tokenCtx) {
  if (this.curContext() !== tokenCtx) {
    this.context[this.context.length - 1] = tokenCtx;
  }
};
types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return;
  }
  var out = this.context.pop();
  if (out === types.b_stat && this.curContext().token === "function") {
    out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};
types$1.braceL.updateContext = function(prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
  this.exprAllowed = true;
};
types$1.dollarBraceL.updateContext = function() {
  this.context.push(types.b_tmpl);
  this.exprAllowed = true;
};
types$1.parenL.updateContext = function(prevType) {
  var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
  this.context.push(statementParens ? types.p_stat : types.p_expr);
  this.exprAllowed = true;
};
types$1.incDec.updateContext = function() {
};
types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
  if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {
    this.context.push(types.f_expr);
  } else {
    this.context.push(types.f_stat);
  }
  this.exprAllowed = false;
};
types$1.colon.updateContext = function() {
  if (this.curContext().token === "function") {
    this.context.pop();
  }
  this.exprAllowed = true;
};
types$1.backQuote.updateContext = function() {
  if (this.curContext() === types.q_tmpl) {
    this.context.pop();
  } else {
    this.context.push(types.q_tmpl);
  }
  this.exprAllowed = false;
};
types$1.star.updateContext = function(prevType) {
  if (prevType === types$1._function) {
    var index2 = this.context.length - 1;
    if (this.context[index2] === types.f_expr) {
      this.context[index2] = types.f_expr_gen;
    } else {
      this.context[index2] = types.f_gen;
    }
  }
  this.exprAllowed = true;
};
types$1.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
    if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
      allowed = true;
    }
  }
  this.exprAllowed = allowed;
};
var pp$5 = Parser.prototype;
pp$5.checkPropClash = function(prop3, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 9 && prop3.type === "SpreadElement") {
    return;
  }
  if (this.options.ecmaVersion >= 6 && (prop3.computed || prop3.method || prop3.shorthand)) {
    return;
  }
  var key2 = prop3.key;
  var name2;
  switch (key2.type) {
    case "Identifier":
      name2 = key2.name;
      break;
    case "Literal":
      name2 = String(key2.value);
      break;
    default:
      return;
  }
  var kind = prop3.kind;
  if (this.options.ecmaVersion >= 6) {
    if (name2 === "__proto__" && kind === "init") {
      if (propHash.proto) {
        if (refDestructuringErrors) {
          if (refDestructuringErrors.doubleProto < 0) {
            refDestructuringErrors.doubleProto = key2.start;
          }
        } else {
          this.raiseRecoverable(key2.start, "Redefinition of __proto__ property");
        }
      }
      propHash.proto = true;
    }
    return;
  }
  name2 = "$" + name2;
  var other = propHash[name2];
  if (other) {
    var redefinition;
    if (kind === "init") {
      redefinition = this.strict && other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }
    if (redefinition) {
      this.raiseRecoverable(key2.start, "Redefinition of property");
    }
  } else {
    other = propHash[name2] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};
pp$5.parseExpression = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
  if (this.type === types$1.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(types$1.comma)) {
      node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
    }
    return this.finishNode(node, "SequenceExpression");
  }
  return expr;
};
pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
  if (this.isContextual("yield")) {
    if (this.inGenerator) {
      return this.parseYield(forInit);
    } else {
      this.exprAllowed = false;
    }
  }
  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    oldDoubleProto = refDestructuringErrors.doubleProto;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors();
    ownDestructuringErrors = true;
  }
  var startPos = this.start, startLoc = this.startLoc;
  if (this.type === types$1.parenL || this.type === types$1.name) {
    this.potentialArrowAt = this.start;
    this.potentialArrowInForAwait = forInit === "await";
  }
  var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
  if (afterLeftParse) {
    left = afterLeftParse.call(this, left, startPos, startLoc);
  }
  if (this.type.isAssign) {
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    if (this.type === types$1.eq) {
      left = this.toAssignable(left, false, refDestructuringErrors);
    }
    if (!ownDestructuringErrors) {
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
    }
    if (refDestructuringErrors.shorthandAssign >= left.start) {
      refDestructuringErrors.shorthandAssign = -1;
    }
    if (this.type === types$1.eq) {
      this.checkLValPattern(left);
    } else {
      this.checkLValSimple(left);
    }
    node.left = left;
    this.next();
    node.right = this.parseMaybeAssign(forInit);
    if (oldDoubleProto > -1) {
      refDestructuringErrors.doubleProto = oldDoubleProto;
    }
    return this.finishNode(node, "AssignmentExpression");
  } else {
    if (ownDestructuringErrors) {
      this.checkExpressionErrors(refDestructuringErrors, true);
    }
  }
  if (oldParenAssign > -1) {
    refDestructuringErrors.parenthesizedAssign = oldParenAssign;
  }
  if (oldTrailingComma > -1) {
    refDestructuringErrors.trailingComma = oldTrailingComma;
  }
  return left;
};
pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(forInit, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  if (this.eat(types$1.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(types$1.colon);
    node.alternate = this.parseMaybeAssign(forInit);
    return this.finishNode(node, "ConditionalExpression");
  }
  return expr;
};
pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
};
pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
  var prec2 = this.type.binop;
  if (prec2 != null && (!forInit || this.type !== types$1._in)) {
    if (prec2 > minPrec) {
      var logical2 = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
      var coalesce = this.type === types$1.coalesce;
      if (coalesce) {
        prec2 = types$1.logicalAND.binop;
      }
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec2, forInit);
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical2 || coalesce);
      if (logical2 && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
        this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
      }
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
    }
  }
  return left;
};
pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical2) {
  if (right.type === "PrivateIdentifier") {
    this.raise(right.start, "Private identifier can only be left side of binary expression");
  }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical2 ? "LogicalExpression" : "BinaryExpression");
};
pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual("await") && this.canAwait) {
    expr = this.parseAwait(forInit);
    sawUnary = true;
  } else if (this.type.prefix) {
    var node = this.startNode(), update2 = this.type === types$1.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true, update2, forInit);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update2) {
      this.checkLValSimple(node.argument);
    } else if (this.strict && node.operator === "delete" && isLocalVariableAccess(node.argument)) {
      this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
    } else if (node.operator === "delete" && isPrivateFieldAccess(node.argument)) {
      this.raiseRecoverable(node.start, "Private fields can not be deleted");
    } else {
      sawUnary = true;
    }
    expr = this.finishNode(node, update2 ? "UpdateExpression" : "UnaryExpression");
  } else if (!sawUnary && this.type === types$1.privateId) {
    if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {
      this.unexpected();
    }
    expr = this.parsePrivateIdent();
    if (this.type !== types$1._in) {
      this.unexpected();
    }
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
    if (this.checkExpressionErrors(refDestructuringErrors)) {
      return expr;
    }
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.operator = this.value;
      node$1.prefix = false;
      node$1.argument = expr;
      this.checkLValSimple(expr);
      this.next();
      expr = this.finishNode(node$1, "UpdateExpression");
    }
  }
  if (!incDec && this.eat(types$1.starstar)) {
    if (sawUnary) {
      this.unexpected(this.lastTokStart);
    } else {
      return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
    }
  } else {
    return expr;
  }
};
function isLocalVariableAccess(node) {
  return node.type === "Identifier" || node.type === "ParenthesizedExpression" && isLocalVariableAccess(node.expression);
}
function isPrivateFieldAccess(node) {
  return node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" || node.type === "ChainExpression" && isPrivateFieldAccess(node.expression) || node.type === "ParenthesizedExpression" && isPrivateFieldAccess(node.expression);
}
pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors, forInit);
  if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
    return expr;
  }
  var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
  if (refDestructuringErrors && result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign >= result.start) {
      refDestructuringErrors.parenthesizedAssign = -1;
    }
    if (refDestructuringErrors.parenthesizedBind >= result.start) {
      refDestructuringErrors.parenthesizedBind = -1;
    }
    if (refDestructuringErrors.trailingComma >= result.start) {
      refDestructuringErrors.trailingComma = -1;
    }
  }
  return result;
};
pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
  var optionalChained = false;
  while (true) {
    var element3 = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
    if (element3.optional) {
      optionalChained = true;
    }
    if (element3 === base || element3.type === "ArrowFunctionExpression") {
      if (optionalChained) {
        var chainNode = this.startNodeAt(startPos, startLoc);
        chainNode.expression = element3;
        element3 = this.finishNode(chainNode, "ChainExpression");
      }
      return element3;
    }
    base = element3;
  }
};
pp$5.shouldParseAsyncArrow = function() {
  return !this.canInsertSemicolon() && this.eat(types$1.arrow);
};
pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
};
pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
  var optionalSupported = this.options.ecmaVersion >= 11;
  var optional = optionalSupported && this.eat(types$1.questionDot);
  if (noCalls && optional) {
    this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
  }
  var computed = this.eat(types$1.bracketL);
  if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.object = base;
    if (computed) {
      node.property = this.parseExpression();
      this.expect(types$1.bracketR);
    } else if (this.type === types$1.privateId && base.type !== "Super") {
      node.property = this.parsePrivateIdent();
    } else {
      node.property = this.parseIdent(this.options.allowReserved !== "never");
    }
    node.computed = !!computed;
    if (optionalSupported) {
      node.optional = optional;
    }
    base = this.finishNode(node, "MemberExpression");
  } else if (!noCalls && this.eat(types$1.parenL)) {
    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
    if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      if (this.awaitIdentPos > 0) {
        this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
      }
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
    var node$1 = this.startNodeAt(startPos, startLoc);
    node$1.callee = base;
    node$1.arguments = exprList;
    if (optionalSupported) {
      node$1.optional = optional;
    }
    base = this.finishNode(node$1, "CallExpression");
  } else if (this.type === types$1.backQuote) {
    if (optional || optionalChained) {
      this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
    }
    var node$2 = this.startNodeAt(startPos, startLoc);
    node$2.tag = base;
    node$2.quasi = this.parseTemplate({ isTagged: true });
    base = this.finishNode(node$2, "TaggedTemplateExpression");
  }
  return base;
};
pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
  if (this.type === types$1.slash) {
    this.readRegexp();
  }
  var node, canBeArrow = this.potentialArrowAt === this.start;
  switch (this.type) {
    case types$1._super:
      if (!this.allowSuper) {
        this.raise(this.start, "'super' keyword outside a method");
      }
      node = this.startNode();
      this.next();
      if (this.type === types$1.parenL && !this.allowDirectSuper) {
        this.raise(node.start, "super() call outside constructor of a subclass");
      }
      if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
        this.unexpected();
      }
      return this.finishNode(node, "Super");
    case types$1._this:
      node = this.startNode();
      this.next();
      return this.finishNode(node, "ThisExpression");
    case types$1.name:
      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
      var id2 = this.parseIdent(false);
      if (this.options.ecmaVersion >= 8 && !containsEsc && id2.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
        this.overrideContext(types.f_expr);
        return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
      }
      if (canBeArrow && !this.canInsertSemicolon()) {
        if (this.eat(types$1.arrow)) {
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id2], false, forInit);
        }
        if (this.options.ecmaVersion >= 8 && id2.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
          id2 = this.parseIdent(false);
          if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
            this.unexpected();
          }
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id2], true, forInit);
        }
      }
      return id2;
    case types$1.regexp:
      var value = this.value;
      node = this.parseLiteral(value.value);
      node.regex = { pattern: value.pattern, flags: value.flags };
      return node;
    case types$1.num:
    case types$1.string:
      return this.parseLiteral(this.value);
    case types$1._null:
    case types$1._true:
    case types$1._false:
      node = this.startNode();
      node.value = this.type === types$1._null ? null : this.type === types$1._true;
      node.raw = this.type.keyword;
      this.next();
      return this.finishNode(node, "Literal");
    case types$1.parenL:
      var start2 = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
      if (refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
          refDestructuringErrors.parenthesizedAssign = start2;
        }
        if (refDestructuringErrors.parenthesizedBind < 0) {
          refDestructuringErrors.parenthesizedBind = start2;
        }
      }
      return expr;
    case types$1.bracketL:
      node = this.startNode();
      this.next();
      node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node, "ArrayExpression");
    case types$1.braceL:
      this.overrideContext(types.b_expr);
      return this.parseObj(false, refDestructuringErrors);
    case types$1._function:
      node = this.startNode();
      this.next();
      return this.parseFunction(node, 0);
    case types$1._class:
      return this.parseClass(this.startNode(), false);
    case types$1._new:
      return this.parseNew();
    case types$1.backQuote:
      return this.parseTemplate();
    case types$1._import:
      if (this.options.ecmaVersion >= 11) {
        return this.parseExprImport(forNew);
      } else {
        return this.unexpected();
      }
    default:
      return this.parseExprAtomDefault();
  }
};
pp$5.parseExprAtomDefault = function() {
  this.unexpected();
};
pp$5.parseExprImport = function(forNew) {
  var node = this.startNode();
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword import");
  }
  this.next();
  if (this.type === types$1.parenL && !forNew) {
    return this.parseDynamicImport(node);
  } else if (this.type === types$1.dot) {
    var meta2 = this.startNodeAt(node.start, node.loc && node.loc.start);
    meta2.name = "import";
    node.meta = this.finishNode(meta2, "Identifier");
    return this.parseImportMeta(node);
  } else {
    this.unexpected();
  }
};
pp$5.parseDynamicImport = function(node) {
  this.next();
  node.source = this.parseMaybeAssign();
  if (this.options.ecmaVersion >= 16) {
    if (!this.eat(types$1.parenR)) {
      this.expect(types$1.comma);
      if (!this.afterTrailingComma(types$1.parenR)) {
        node.options = this.parseMaybeAssign();
        if (!this.eat(types$1.parenR)) {
          this.expect(types$1.comma);
          if (!this.afterTrailingComma(types$1.parenR)) {
            this.unexpected();
          }
        }
      } else {
        node.options = null;
      }
    } else {
      node.options = null;
    }
  } else {
    if (!this.eat(types$1.parenR)) {
      var errorPos = this.start;
      if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
        this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
      } else {
        this.unexpected(errorPos);
      }
    }
  }
  return this.finishNode(node, "ImportExpression");
};
pp$5.parseImportMeta = function(node) {
  this.next();
  var containsEsc = this.containsEsc;
  node.property = this.parseIdent(true);
  if (node.property.name !== "meta") {
    this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
  }
  if (containsEsc) {
    this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
  }
  if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
    this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
  }
  return this.finishNode(node, "MetaProperty");
};
pp$5.parseLiteral = function(value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  if (node.raw.charCodeAt(node.raw.length - 1) === 110) {
    node.bigint = node.value != null ? node.value.toString() : node.raw.slice(0, -1).replace(/_/g, "");
  }
  this.next();
  return this.finishNode(node, "Literal");
};
pp$5.parseParenExpression = function() {
  this.expect(types$1.parenL);
  var val = this.parseExpression();
  this.expect(types$1.parenR);
  return val;
};
pp$5.shouldParseArrow = function(exprList) {
  return !this.canInsertSemicolon();
};
pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();
    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first2 = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    while (this.type !== types$1.parenR) {
      first2 ? first2 = false : this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
        lastIsComma = true;
        break;
      } else if (this.type === types$1.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRestBinding()));
        if (this.type === types$1.comma) {
          this.raiseRecoverable(
            this.start,
            "Comma is not permitted after the rest element"
          );
        }
        break;
      } else {
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
    this.expect(types$1.parenR);
    if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
    }
    if (!exprList.length || lastIsComma) {
      this.unexpected(this.lastTokStart);
    }
    if (spreadStart) {
      this.unexpected(spreadStart);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }
  if (this.options.preserveParens) {
    var par2 = this.startNodeAt(startPos, startLoc);
    par2.expression = val;
    return this.finishNode(par2, "ParenthesizedExpression");
  } else {
    return val;
  }
};
pp$5.parseParenItem = function(item) {
  return item;
};
pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
};
var empty = [];
pp$5.parseNew = function() {
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword new");
  }
  var node = this.startNode();
  this.next();
  if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {
    var meta2 = this.startNodeAt(node.start, node.loc && node.loc.start);
    meta2.name = "new";
    node.meta = this.finishNode(meta2, "Identifier");
    this.next();
    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);
    if (node.property.name !== "target") {
      this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
    }
    if (containsEsc) {
      this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
    }
    if (!this.allowNewDotTarget) {
      this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block");
    }
    return this.finishNode(node, "MetaProperty");
  }
  var startPos = this.start, startLoc = this.startLoc;
  node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
  if (this.eat(types$1.parenL)) {
    node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
  } else {
    node.arguments = empty;
  }
  return this.finishNode(node, "NewExpression");
};
pp$5.parseTemplateElement = function(ref2) {
  var isTagged = ref2.isTagged;
  var elem = this.startNode();
  if (this.type === types$1.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
    }
    elem.value = {
      raw: this.value.replace(/\r\n?/g, "\n"),
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
      cooked: this.value
    };
  }
  this.next();
  elem.tail = this.type === types$1.backQuote;
  return this.finishNode(elem, "TemplateElement");
};
pp$5.parseTemplate = function(ref2) {
  if (ref2 === void 0) ref2 = {};
  var isTagged = ref2.isTagged;
  if (isTagged === void 0) isTagged = false;
  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement({ isTagged });
  node.quasis = [curElt];
  while (!curElt.tail) {
    if (this.type === types$1.eof) {
      this.raise(this.pos, "Unterminated template literal");
    }
    this.expect(types$1.dollarBraceL);
    node.expressions.push(this.parseExpression());
    this.expect(types$1.braceR);
    node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral");
};
pp$5.isAsyncProp = function(prop3) {
  return !prop3.computed && prop3.key.type === "Identifier" && prop3.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$5.parseObj = function(isPattern, refDestructuringErrors) {
  var node = this.startNode(), first2 = true, propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(types$1.braceR)) {
    if (!first2) {
      this.expect(types$1.comma);
      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first2 = false;
    }
    var prop3 = this.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) {
      this.checkPropClash(prop3, propHash, refDestructuringErrors);
    }
    node.properties.push(prop3);
  }
  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
};
pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop3 = this.startNode(), isGenerator, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
    if (isPattern) {
      prop3.argument = this.parseIdent(false);
      if (this.type === types$1.comma) {
        this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
      }
      return this.finishNode(prop3, "RestElement");
    }
    prop3.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
      refDestructuringErrors.trailingComma = this.start;
    }
    return this.finishNode(prop3, "SpreadElement");
  }
  if (this.options.ecmaVersion >= 6) {
    prop3.method = false;
    prop3.shorthand = false;
    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }
    if (!isPattern) {
      isGenerator = this.eat(types$1.star);
    }
  }
  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop3);
  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop3)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
    this.parsePropertyName(prop3);
  } else {
    isAsync = false;
  }
  this.parsePropertyValue(prop3, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop3, "Property");
};
pp$5.parseGetterSetter = function(prop3) {
  var kind = prop3.key.name;
  this.parsePropertyName(prop3);
  prop3.value = this.parseMethod(false);
  prop3.kind = kind;
  var paramCount = prop3.kind === "get" ? 0 : 1;
  if (prop3.value.params.length !== paramCount) {
    var start2 = prop3.value.start;
    if (prop3.kind === "get") {
      this.raiseRecoverable(start2, "getter should have no params");
    } else {
      this.raiseRecoverable(start2, "setter should have exactly one param");
    }
  } else {
    if (prop3.kind === "set" && prop3.value.params[0].type === "RestElement") {
      this.raiseRecoverable(prop3.value.params[0].start, "Setter cannot use rest params");
    }
  }
};
pp$5.parsePropertyValue = function(prop3, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) && this.type === types$1.colon) {
    this.unexpected();
  }
  if (this.eat(types$1.colon)) {
    prop3.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop3.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
    if (isPattern) {
      this.unexpected();
    }
    prop3.method = true;
    prop3.value = this.parseMethod(isGenerator, isAsync);
    prop3.kind = "init";
  } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop3.computed && prop3.key.type === "Identifier" && (prop3.key.name === "get" || prop3.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    this.parseGetterSetter(prop3);
  } else if (this.options.ecmaVersion >= 6 && !prop3.computed && prop3.key.type === "Identifier") {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    this.checkUnreserved(prop3.key);
    if (prop3.key.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = startPos;
    }
    if (isPattern) {
      prop3.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop3.key));
    } else if (this.type === types$1.eq && refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign < 0) {
        refDestructuringErrors.shorthandAssign = this.start;
      }
      prop3.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop3.key));
    } else {
      prop3.value = this.copyNode(prop3.key);
    }
    prop3.kind = "init";
    prop3.shorthand = true;
  } else {
    this.unexpected();
  }
};
pp$5.parsePropertyName = function(prop3) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(types$1.bracketL)) {
      prop3.computed = true;
      prop3.key = this.parseMaybeAssign();
      this.expect(types$1.bracketR);
      return prop3.key;
    } else {
      prop3.computed = false;
    }
  }
  return prop3.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
};
pp$5.initFunction = function(node) {
  node.id = null;
  if (this.options.ecmaVersion >= 6) {
    node.generator = node.expression = false;
  }
  if (this.options.ecmaVersion >= 8) {
    node.async = false;
  }
};
pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.initFunction(node);
  if (this.options.ecmaVersion >= 6) {
    node.generator = isGenerator;
  }
  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
  this.expect(types$1.parenL);
  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node, false, true, false);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "FunctionExpression");
};
pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
  this.initFunction(node);
  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "ArrowFunctionExpression");
};
pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
  var isExpression = isArrowFunction && this.type !== types$1.braceL;
  var oldStrict = this.strict, useStrict = false;
  if (isExpression) {
    node.body = this.parseMaybeAssign(forInit);
    node.expression = true;
    this.checkParams(node, false);
  } else {
    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      if (useStrict && nonSimple) {
        this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
      }
    }
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) {
      this.strict = true;
    }
    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
    if (this.strict && node.id) {
      this.checkLValSimple(node.id, BIND_OUTSIDE);
    }
    node.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
    node.expression = false;
    this.adaptDirectivePrologue(node.body.body);
    this.labels = oldLabels;
  }
  this.exitScope();
};
pp$5.isSimpleParamList = function(params) {
  for (var i = 0, list4 = params; i < list4.length; i += 1) {
    var param = list4[i];
    if (param.type !== "Identifier") {
      return false;
    }
  }
  return true;
};
pp$5.checkParams = function(node, allowDuplicates) {
  var nameHash = /* @__PURE__ */ Object.create(null);
  for (var i = 0, list4 = node.params; i < list4.length; i += 1) {
    var param = list4[i];
    this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
  }
};
pp$5.parseExprList = function(close2, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [], first2 = true;
  while (!this.eat(close2)) {
    if (!first2) {
      this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(close2)) {
        break;
      }
    } else {
      first2 = false;
    }
    var elt = void 0;
    if (allowEmpty && this.type === types$1.comma) {
      elt = null;
    } else if (this.type === types$1.ellipsis) {
      elt = this.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
        refDestructuringErrors.trailingComma = this.start;
      }
    } else {
      elt = this.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts;
};
pp$5.checkUnreserved = function(ref2) {
  var start2 = ref2.start;
  var end2 = ref2.end;
  var name2 = ref2.name;
  if (this.inGenerator && name2 === "yield") {
    this.raiseRecoverable(start2, "Cannot use 'yield' as identifier inside a generator");
  }
  if (this.inAsync && name2 === "await") {
    this.raiseRecoverable(start2, "Cannot use 'await' as identifier inside an async function");
  }
  if (!(this.currentThisScope().flags & SCOPE_VAR) && name2 === "arguments") {
    this.raiseRecoverable(start2, "Cannot use 'arguments' in class field initializer");
  }
  if (this.inClassStaticBlock && (name2 === "arguments" || name2 === "await")) {
    this.raise(start2, "Cannot use " + name2 + " in class static initialization block");
  }
  if (this.keywords.test(name2)) {
    this.raise(start2, "Unexpected keyword '" + name2 + "'");
  }
  if (this.options.ecmaVersion < 6 && this.input.slice(start2, end2).indexOf("\\") !== -1) {
    return;
  }
  var re2 = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re2.test(name2)) {
    if (!this.inAsync && name2 === "await") {
      this.raiseRecoverable(start2, "Cannot use keyword 'await' outside an async function");
    }
    this.raiseRecoverable(start2, "The keyword '" + name2 + "' is reserved");
  }
};
pp$5.parseIdent = function(liberal) {
  var node = this.parseIdentNode();
  this.next(!!liberal);
  this.finishNode(node, "Identifier");
  if (!liberal) {
    this.checkUnreserved(node);
    if (node.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = node.start;
    }
  }
  return node;
};
pp$5.parseIdentNode = function() {
  var node = this.startNode();
  if (this.type === types$1.name) {
    node.name = this.value;
  } else if (this.type.keyword) {
    node.name = this.type.keyword;
    if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
    this.type = types$1.name;
  } else {
    this.unexpected();
  }
  return node;
};
pp$5.parsePrivateIdent = function() {
  var node = this.startNode();
  if (this.type === types$1.privateId) {
    node.name = this.value;
  } else {
    this.unexpected();
  }
  this.next();
  this.finishNode(node, "PrivateIdentifier");
  if (this.options.checkPrivateFields) {
    if (this.privateNameStack.length === 0) {
      this.raise(node.start, "Private field '#" + node.name + "' must be declared in an enclosing class");
    } else {
      this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
    }
  }
  return node;
};
pp$5.parseYield = function(forInit) {
  if (!this.yieldPos) {
    this.yieldPos = this.start;
  }
  var node = this.startNode();
  this.next();
  if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(types$1.star);
    node.argument = this.parseMaybeAssign(forInit);
  }
  return this.finishNode(node, "YieldExpression");
};
pp$5.parseAwait = function(forInit) {
  if (!this.awaitPos) {
    this.awaitPos = this.start;
  }
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeUnary(null, true, false, forInit);
  return this.finishNode(node, "AwaitExpression");
};
var pp$4 = Parser.prototype;
pp$4.raise = function(pos, message2) {
  var loc = getLineInfo(this.input, pos);
  message2 += " (" + loc.line + ":" + loc.column + ")";
  if (this.sourceFile) {
    message2 += " in " + this.sourceFile;
  }
  var err = new SyntaxError(message2);
  err.pos = pos;
  err.loc = loc;
  err.raisedAt = this.pos;
  throw err;
};
pp$4.raiseRecoverable = pp$4.raise;
pp$4.curPosition = function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart);
  }
};
var pp$3 = Parser.prototype;
var Scope = function Scope2(flags) {
  this.flags = flags;
  this.var = [];
  this.lexical = [];
  this.functions = [];
};
pp$3.enterScope = function(flags) {
  this.scopeStack.push(new Scope(flags));
};
pp$3.exitScope = function() {
  this.scopeStack.pop();
};
pp$3.treatFunctionsAsVarInScope = function(scope) {
  return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
};
pp$3.declareName = function(name2, bindingType, pos) {
  var redeclared = false;
  if (bindingType === BIND_LEXICAL) {
    var scope = this.currentScope();
    redeclared = scope.lexical.indexOf(name2) > -1 || scope.functions.indexOf(name2) > -1 || scope.var.indexOf(name2) > -1;
    scope.lexical.push(name2);
    if (this.inModule && scope.flags & SCOPE_TOP) {
      delete this.undefinedExports[name2];
    }
  } else if (bindingType === BIND_SIMPLE_CATCH) {
    var scope$1 = this.currentScope();
    scope$1.lexical.push(name2);
  } else if (bindingType === BIND_FUNCTION) {
    var scope$2 = this.currentScope();
    if (this.treatFunctionsAsVar) {
      redeclared = scope$2.lexical.indexOf(name2) > -1;
    } else {
      redeclared = scope$2.lexical.indexOf(name2) > -1 || scope$2.var.indexOf(name2) > -1;
    }
    scope$2.functions.push(name2);
  } else {
    for (var i = this.scopeStack.length - 1; i >= 0; --i) {
      var scope$3 = this.scopeStack[i];
      if (scope$3.lexical.indexOf(name2) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name2) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name2) > -1) {
        redeclared = true;
        break;
      }
      scope$3.var.push(name2);
      if (this.inModule && scope$3.flags & SCOPE_TOP) {
        delete this.undefinedExports[name2];
      }
      if (scope$3.flags & SCOPE_VAR) {
        break;
      }
    }
  }
  if (redeclared) {
    this.raiseRecoverable(pos, "Identifier '" + name2 + "' has already been declared");
  }
};
pp$3.checkLocalExport = function(id2) {
  if (this.scopeStack[0].lexical.indexOf(id2.name) === -1 && this.scopeStack[0].var.indexOf(id2.name) === -1) {
    this.undefinedExports[id2.name] = id2;
  }
};
pp$3.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1];
};
pp$3.currentVarScope = function() {
  for (var i = this.scopeStack.length - 1; ; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK)) {
      return scope;
    }
  }
};
pp$3.currentThisScope = function() {
  for (var i = this.scopeStack.length - 1; ; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK) && !(scope.flags & SCOPE_ARROW)) {
      return scope;
    }
  }
};
var Node = function Node2(parser2, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser2.options.locations) {
    this.loc = new SourceLocation(parser2, loc);
  }
  if (parser2.options.directSourceFile) {
    this.sourceFile = parser2.options.directSourceFile;
  }
  if (parser2.options.ranges) {
    this.range = [pos, 0];
  }
};
var pp$2 = Parser.prototype;
pp$2.startNode = function() {
  return new Node(this, this.start, this.startLoc);
};
pp$2.startNodeAt = function(pos, loc) {
  return new Node(this, pos, loc);
};
function finishNodeAt(node, type2, pos, loc) {
  node.type = type2;
  node.end = pos;
  if (this.options.locations) {
    node.loc.end = loc;
  }
  if (this.options.ranges) {
    node.range[1] = pos;
  }
  return node;
}
pp$2.finishNode = function(node, type2) {
  return finishNodeAt.call(this, node, type2, this.lastTokEnd, this.lastTokEndLoc);
};
pp$2.finishNodeAt = function(node, type2, pos, loc) {
  return finishNodeAt.call(this, node, type2, pos, loc);
};
pp$2.copyNode = function(node) {
  var newNode = new Node(this, node.start, this.startLoc);
  for (var prop3 in node) {
    newNode[prop3] = node[prop3];
  }
  return newNode;
};
var scriptValuesAddedInUnicode = "Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz";
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
var ecma13BinaryProperties = ecma12BinaryProperties;
var ecma14BinaryProperties = ecma13BinaryProperties;
var unicodeBinaryProperties = {
  9: ecma9BinaryProperties,
  10: ecma10BinaryProperties,
  11: ecma11BinaryProperties,
  12: ecma12BinaryProperties,
  13: ecma13BinaryProperties,
  14: ecma14BinaryProperties
};
var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
var unicodeBinaryPropertiesOfStrings = {
  9: "",
  10: "",
  11: "",
  12: "",
  13: "",
  14: ecma14BinaryPropertiesOfStrings
};
var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
var ecma14ScriptValues = ecma13ScriptValues + " " + scriptValuesAddedInUnicode;
var unicodeScriptValues = {
  9: ecma9ScriptValues,
  10: ecma10ScriptValues,
  11: ecma11ScriptValues,
  12: ecma12ScriptValues,
  13: ecma13ScriptValues,
  14: ecma14ScriptValues
};
var data = {};
function buildUnicodeData(ecmaVersion) {
  var d = data[ecmaVersion] = {
    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
    binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion]),
    nonBinary: {
      General_Category: wordsRegexp(unicodeGeneralCategoryValues),
      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
    }
  };
  d.nonBinary.Script_Extensions = d.nonBinary.Script;
  d.nonBinary.gc = d.nonBinary.General_Category;
  d.nonBinary.sc = d.nonBinary.Script;
  d.nonBinary.scx = d.nonBinary.Script_Extensions;
}
for (i = 0, list4 = [9, 10, 11, 12, 13, 14]; i < list4.length; i += 1) {
  ecmaVersion = list4[i];
  buildUnicodeData(ecmaVersion);
}
var ecmaVersion;
var i;
var list4;
var pp$1 = Parser.prototype;
var BranchID = function BranchID2(parent, base) {
  this.parent = parent;
  this.base = base || this;
};
BranchID.prototype.separatedFrom = function separatedFrom(alt) {
  for (var self2 = this; self2; self2 = self2.parent) {
    for (var other = alt; other; other = other.parent) {
      if (self2.base === other.base && self2 !== other) {
        return true;
      }
    }
  }
  return false;
};
BranchID.prototype.sibling = function sibling() {
  return new BranchID(this.parent, this.base);
};
var RegExpValidationState = function RegExpValidationState2(parser2) {
  this.parser = parser2;
  this.validFlags = "gim" + (parser2.options.ecmaVersion >= 6 ? "uy" : "") + (parser2.options.ecmaVersion >= 9 ? "s" : "") + (parser2.options.ecmaVersion >= 13 ? "d" : "") + (parser2.options.ecmaVersion >= 15 ? "v" : "");
  this.unicodeProperties = data[parser2.options.ecmaVersion >= 14 ? 14 : parser2.options.ecmaVersion];
  this.source = "";
  this.flags = "";
  this.start = 0;
  this.switchU = false;
  this.switchV = false;
  this.switchN = false;
  this.pos = 0;
  this.lastIntValue = 0;
  this.lastStringValue = "";
  this.lastAssertionIsQuantifiable = false;
  this.numCapturingParens = 0;
  this.maxBackReference = 0;
  this.groupNames = /* @__PURE__ */ Object.create(null);
  this.backReferenceNames = [];
  this.branchID = null;
};
RegExpValidationState.prototype.reset = function reset2(start2, pattern, flags) {
  var unicodeSets = flags.indexOf("v") !== -1;
  var unicode = flags.indexOf("u") !== -1;
  this.start = start2 | 0;
  this.source = pattern + "";
  this.flags = flags;
  if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
    this.switchU = true;
    this.switchV = true;
    this.switchN = true;
  } else {
    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
    this.switchV = false;
    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
  }
};
RegExpValidationState.prototype.raise = function raise(message2) {
  this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message2);
};
RegExpValidationState.prototype.at = function at(i, forceU) {
  if (forceU === void 0) forceU = false;
  var s = this.source;
  var l2 = s.length;
  if (i >= l2) {
    return -1;
  }
  var c = s.charCodeAt(i);
  if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i + 1 >= l2) {
    return c;
  }
  var next2 = s.charCodeAt(i + 1);
  return next2 >= 56320 && next2 <= 57343 ? (c << 10) + next2 - 56613888 : c;
};
RegExpValidationState.prototype.nextIndex = function nextIndex(i, forceU) {
  if (forceU === void 0) forceU = false;
  var s = this.source;
  var l2 = s.length;
  if (i >= l2) {
    return l2;
  }
  var c = s.charCodeAt(i), next2;
  if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i + 1 >= l2 || (next2 = s.charCodeAt(i + 1)) < 56320 || next2 > 57343) {
    return i + 1;
  }
  return i + 2;
};
RegExpValidationState.prototype.current = function current(forceU) {
  if (forceU === void 0) forceU = false;
  return this.at(this.pos, forceU);
};
RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
  if (forceU === void 0) forceU = false;
  return this.at(this.nextIndex(this.pos, forceU), forceU);
};
RegExpValidationState.prototype.advance = function advance(forceU) {
  if (forceU === void 0) forceU = false;
  this.pos = this.nextIndex(this.pos, forceU);
};
RegExpValidationState.prototype.eat = function eat(ch, forceU) {
  if (forceU === void 0) forceU = false;
  if (this.current(forceU) === ch) {
    this.advance(forceU);
    return true;
  }
  return false;
};
RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {
  if (forceU === void 0) forceU = false;
  var pos = this.pos;
  for (var i = 0, list4 = chs; i < list4.length; i += 1) {
    var ch = list4[i];
    var current2 = this.at(pos, forceU);
    if (current2 === -1 || current2 !== ch) {
      return false;
    }
    pos = this.nextIndex(pos, forceU);
  }
  this.pos = pos;
  return true;
};
pp$1.validateRegExpFlags = function(state) {
  var validFlags = state.validFlags;
  var flags = state.flags;
  var u2 = false;
  var v = false;
  for (var i = 0; i < flags.length; i++) {
    var flag = flags.charAt(i);
    if (validFlags.indexOf(flag) === -1) {
      this.raise(state.start, "Invalid regular expression flag");
    }
    if (flags.indexOf(flag, i + 1) > -1) {
      this.raise(state.start, "Duplicate regular expression flag");
    }
    if (flag === "u") {
      u2 = true;
    }
    if (flag === "v") {
      v = true;
    }
  }
  if (this.options.ecmaVersion >= 15 && u2 && v) {
    this.raise(state.start, "Invalid regular expression flag");
  }
};
function hasProp(obj) {
  for (var _ in obj) {
    return true;
  }
  return false;
}
pp$1.validateRegExpPattern = function(state) {
  this.regexp_pattern(state);
  if (!state.switchN && this.options.ecmaVersion >= 9 && hasProp(state.groupNames)) {
    state.switchN = true;
    this.regexp_pattern(state);
  }
};
pp$1.regexp_pattern = function(state) {
  state.pos = 0;
  state.lastIntValue = 0;
  state.lastStringValue = "";
  state.lastAssertionIsQuantifiable = false;
  state.numCapturingParens = 0;
  state.maxBackReference = 0;
  state.groupNames = /* @__PURE__ */ Object.create(null);
  state.backReferenceNames.length = 0;
  state.branchID = null;
  this.regexp_disjunction(state);
  if (state.pos !== state.source.length) {
    if (state.eat(
      41
      /* ) */
    )) {
      state.raise("Unmatched ')'");
    }
    if (state.eat(
      93
      /* ] */
    ) || state.eat(
      125
      /* } */
    )) {
      state.raise("Lone quantifier brackets");
    }
  }
  if (state.maxBackReference > state.numCapturingParens) {
    state.raise("Invalid escape");
  }
  for (var i = 0, list4 = state.backReferenceNames; i < list4.length; i += 1) {
    var name2 = list4[i];
    if (!state.groupNames[name2]) {
      state.raise("Invalid named capture referenced");
    }
  }
};
pp$1.regexp_disjunction = function(state) {
  var trackDisjunction = this.options.ecmaVersion >= 16;
  if (trackDisjunction) {
    state.branchID = new BranchID(state.branchID, null);
  }
  this.regexp_alternative(state);
  while (state.eat(
    124
    /* | */
  )) {
    if (trackDisjunction) {
      state.branchID = state.branchID.sibling();
    }
    this.regexp_alternative(state);
  }
  if (trackDisjunction) {
    state.branchID = state.branchID.parent;
  }
  if (this.regexp_eatQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  if (state.eat(
    123
    /* { */
  )) {
    state.raise("Lone quantifier brackets");
  }
};
pp$1.regexp_alternative = function(state) {
  while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
  }
};
pp$1.regexp_eatTerm = function(state) {
  if (this.regexp_eatAssertion(state)) {
    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
      if (state.switchU) {
        state.raise("Invalid quantifier");
      }
    }
    return true;
  }
  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true;
  }
  return false;
};
pp$1.regexp_eatAssertion = function(state) {
  var start2 = state.pos;
  state.lastAssertionIsQuantifiable = false;
  if (state.eat(
    94
    /* ^ */
  ) || state.eat(
    36
    /* $ */
  )) {
    return true;
  }
  if (state.eat(
    92
    /* \ */
  )) {
    if (state.eat(
      66
      /* B */
    ) || state.eat(
      98
      /* b */
    )) {
      return true;
    }
    state.pos = start2;
  }
  if (state.eat(
    40
    /* ( */
  ) && state.eat(
    63
    /* ? */
  )) {
    var lookbehind = false;
    if (this.options.ecmaVersion >= 9) {
      lookbehind = state.eat(
        60
        /* < */
      );
    }
    if (state.eat(
      61
      /* = */
    ) || state.eat(
      33
      /* ! */
    )) {
      this.regexp_disjunction(state);
      if (!state.eat(
        41
        /* ) */
      )) {
        state.raise("Unterminated group");
      }
      state.lastAssertionIsQuantifiable = !lookbehind;
      return true;
    }
  }
  state.pos = start2;
  return false;
};
pp$1.regexp_eatQuantifier = function(state, noError) {
  if (noError === void 0) noError = false;
  if (this.regexp_eatQuantifierPrefix(state, noError)) {
    state.eat(
      63
      /* ? */
    );
    return true;
  }
  return false;
};
pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
  return state.eat(
    42
    /* * */
  ) || state.eat(
    43
    /* + */
  ) || state.eat(
    63
    /* ? */
  ) || this.regexp_eatBracedQuantifier(state, noError);
};
pp$1.regexp_eatBracedQuantifier = function(state, noError) {
  var start2 = state.pos;
  if (state.eat(
    123
    /* { */
  )) {
    var min = 0, max = -1;
    if (this.regexp_eatDecimalDigits(state)) {
      min = state.lastIntValue;
      if (state.eat(
        44
        /* , */
      ) && this.regexp_eatDecimalDigits(state)) {
        max = state.lastIntValue;
      }
      if (state.eat(
        125
        /* } */
      )) {
        if (max !== -1 && max < min && !noError) {
          state.raise("numbers out of order in {} quantifier");
        }
        return true;
      }
    }
    if (state.switchU && !noError) {
      state.raise("Incomplete quantifier");
    }
    state.pos = start2;
  }
  return false;
};
pp$1.regexp_eatAtom = function(state) {
  return this.regexp_eatPatternCharacters(state) || state.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
};
pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start2 = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatAtomEscape(state)) {
      return true;
    }
    state.pos = start2;
  }
  return false;
};
pp$1.regexp_eatUncapturingGroup = function(state) {
  var start2 = state.pos;
  if (state.eat(
    40
    /* ( */
  )) {
    if (state.eat(
      63
      /* ? */
    )) {
      if (this.options.ecmaVersion >= 16) {
        var addModifiers = this.regexp_eatModifiers(state);
        var hasHyphen = state.eat(
          45
          /* - */
        );
        if (addModifiers || hasHyphen) {
          for (var i = 0; i < addModifiers.length; i++) {
            var modifier = addModifiers.charAt(i);
            if (addModifiers.indexOf(modifier, i + 1) > -1) {
              state.raise("Duplicate regular expression modifiers");
            }
          }
          if (hasHyphen) {
            var removeModifiers = this.regexp_eatModifiers(state);
            if (!addModifiers && !removeModifiers && state.current() === 58) {
              state.raise("Invalid regular expression modifiers");
            }
            for (var i$1 = 0; i$1 < removeModifiers.length; i$1++) {
              var modifier$1 = removeModifiers.charAt(i$1);
              if (removeModifiers.indexOf(modifier$1, i$1 + 1) > -1 || addModifiers.indexOf(modifier$1) > -1) {
                state.raise("Duplicate regular expression modifiers");
              }
            }
          }
        }
      }
      if (state.eat(
        58
        /* : */
      )) {
        this.regexp_disjunction(state);
        if (state.eat(
          41
          /* ) */
        )) {
          return true;
        }
        state.raise("Unterminated group");
      }
    }
    state.pos = start2;
  }
  return false;
};
pp$1.regexp_eatCapturingGroup = function(state) {
  if (state.eat(
    40
    /* ( */
  )) {
    if (this.options.ecmaVersion >= 9) {
      this.regexp_groupSpecifier(state);
    } else if (state.current() === 63) {
      state.raise("Invalid group");
    }
    this.regexp_disjunction(state);
    if (state.eat(
      41
      /* ) */
    )) {
      state.numCapturingParens += 1;
      return true;
    }
    state.raise("Unterminated group");
  }
  return false;
};
pp$1.regexp_eatModifiers = function(state) {
  var modifiers = "";
  var ch = 0;
  while ((ch = state.current()) !== -1 && isRegularExpressionModifier(ch)) {
    modifiers += codePointToString(ch);
    state.advance();
  }
  return modifiers;
};
function isRegularExpressionModifier(ch) {
  return ch === 105 || ch === 109 || ch === 115;
}
pp$1.regexp_eatExtendedAtom = function(state) {
  return state.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
};
pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  return false;
};
pp$1.regexp_eatSyntaxCharacter = function(state) {
  var ch = state.current();
  if (isSyntaxCharacter(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
function isSyntaxCharacter(ch) {
  return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatPatternCharacters = function(state) {
  var start2 = state.pos;
  var ch = 0;
  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
    state.advance();
  }
  return state.pos !== start2;
};
pp$1.regexp_eatExtendedPatternCharacter = function(state) {
  var ch = state.current();
  if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_groupSpecifier = function(state) {
  if (state.eat(
    63
    /* ? */
  )) {
    if (!this.regexp_eatGroupName(state)) {
      state.raise("Invalid group");
    }
    var trackDisjunction = this.options.ecmaVersion >= 16;
    var known = state.groupNames[state.lastStringValue];
    if (known) {
      if (trackDisjunction) {
        for (var i = 0, list4 = known; i < list4.length; i += 1) {
          var altID = list4[i];
          if (!altID.separatedFrom(state.branchID)) {
            state.raise("Duplicate capture group name");
          }
        }
      } else {
        state.raise("Duplicate capture group name");
      }
    }
    if (trackDisjunction) {
      (known || (state.groupNames[state.lastStringValue] = [])).push(state.branchID);
    } else {
      state.groupNames[state.lastStringValue] = true;
    }
  }
};
pp$1.regexp_eatGroupName = function(state) {
  state.lastStringValue = "";
  if (state.eat(
    60
    /* < */
  )) {
    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(
      62
      /* > */
    )) {
      return true;
    }
    state.raise("Invalid capture group name");
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierName = function(state) {
  state.lastStringValue = "";
  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString(state.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierStart = function(state) {
  var start2 = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);
  if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierStart(ch)) {
    state.lastIntValue = ch;
    return true;
  }
  state.pos = start2;
  return false;
};
function isRegExpIdentifierStart(ch) {
  return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
}
pp$1.regexp_eatRegExpIdentifierPart = function(state) {
  var start2 = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);
  if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierPart(ch)) {
    state.lastIntValue = ch;
    return true;
  }
  state.pos = start2;
  return false;
};
function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
}
pp$1.regexp_eatAtomEscape = function(state) {
  if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
    return true;
  }
  if (state.switchU) {
    if (state.current() === 99) {
      state.raise("Invalid unicode escape");
    }
    state.raise("Invalid escape");
  }
  return false;
};
pp$1.regexp_eatBackReference = function(state) {
  var start2 = state.pos;
  if (this.regexp_eatDecimalEscape(state)) {
    var n = state.lastIntValue;
    if (state.switchU) {
      if (n > state.maxBackReference) {
        state.maxBackReference = n;
      }
      return true;
    }
    if (n <= state.numCapturingParens) {
      return true;
    }
    state.pos = start2;
  }
  return false;
};
pp$1.regexp_eatKGroupName = function(state) {
  if (state.eat(
    107
    /* k */
  )) {
    if (this.regexp_eatGroupName(state)) {
      state.backReferenceNames.push(state.lastStringValue);
      return true;
    }
    state.raise("Invalid named reference");
  }
  return false;
};
pp$1.regexp_eatCharacterEscape = function(state) {
  return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
};
pp$1.regexp_eatCControlLetter = function(state) {
  var start2 = state.pos;
  if (state.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatControlLetter(state)) {
      return true;
    }
    state.pos = start2;
  }
  return false;
};
pp$1.regexp_eatZero = function(state) {
  if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
    state.lastIntValue = 0;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlEscape = function(state) {
  var ch = state.current();
  if (ch === 116) {
    state.lastIntValue = 9;
    state.advance();
    return true;
  }
  if (ch === 110) {
    state.lastIntValue = 10;
    state.advance();
    return true;
  }
  if (ch === 118) {
    state.lastIntValue = 11;
    state.advance();
    return true;
  }
  if (ch === 102) {
    state.lastIntValue = 12;
    state.advance();
    return true;
  }
  if (ch === 114) {
    state.lastIntValue = 13;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlLetter = function(state) {
  var ch = state.current();
  if (isControlLetter(ch)) {
    state.lastIntValue = ch % 32;
    state.advance();
    return true;
  }
  return false;
};
function isControlLetter(ch) {
  return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
}
pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
  if (forceU === void 0) forceU = false;
  var start2 = state.pos;
  var switchU = forceU || state.switchU;
  if (state.eat(
    117
    /* u */
  )) {
    if (this.regexp_eatFixedHexDigits(state, 4)) {
      var lead = state.lastIntValue;
      if (switchU && lead >= 55296 && lead <= 56319) {
        var leadSurrogateEnd = state.pos;
        if (state.eat(
          92
          /* \ */
        ) && state.eat(
          117
          /* u */
        ) && this.regexp_eatFixedHexDigits(state, 4)) {
          var trail = state.lastIntValue;
          if (trail >= 56320 && trail <= 57343) {
            state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
            return true;
          }
        }
        state.pos = leadSurrogateEnd;
        state.lastIntValue = lead;
      }
      return true;
    }
    if (switchU && state.eat(
      123
      /* { */
    ) && this.regexp_eatHexDigits(state) && state.eat(
      125
      /* } */
    ) && isValidUnicode(state.lastIntValue)) {
      return true;
    }
    if (switchU) {
      state.raise("Invalid unicode escape");
    }
    state.pos = start2;
  }
  return false;
};
function isValidUnicode(ch) {
  return ch >= 0 && ch <= 1114111;
}
pp$1.regexp_eatIdentityEscape = function(state) {
  if (state.switchU) {
    if (this.regexp_eatSyntaxCharacter(state)) {
      return true;
    }
    if (state.eat(
      47
      /* / */
    )) {
      state.lastIntValue = 47;
      return true;
    }
    return false;
  }
  var ch = state.current();
  if (ch !== 99 && (!state.switchN || ch !== 107)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatDecimalEscape = function(state) {
  state.lastIntValue = 0;
  var ch = state.current();
  if (ch >= 49 && ch <= 57) {
    do {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
      state.advance();
    } while ((ch = state.current()) >= 48 && ch <= 57);
    return true;
  }
  return false;
};
var CharSetNone = 0;
var CharSetOk = 1;
var CharSetString = 2;
pp$1.regexp_eatCharacterClassEscape = function(state) {
  var ch = state.current();
  if (isCharacterClassEscape(ch)) {
    state.lastIntValue = -1;
    state.advance();
    return CharSetOk;
  }
  var negate = false;
  if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 80) || ch === 112)) {
    state.lastIntValue = -1;
    state.advance();
    var result;
    if (state.eat(
      123
      /* { */
    ) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(
      125
      /* } */
    )) {
      if (negate && result === CharSetString) {
        state.raise("Invalid property name");
      }
      return result;
    }
    state.raise("Invalid property name");
  }
  return CharSetNone;
};
function isCharacterClassEscape(ch) {
  return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
}
pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
  var start2 = state.pos;
  if (this.regexp_eatUnicodePropertyName(state) && state.eat(
    61
    /* = */
  )) {
    var name2 = state.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(state)) {
      var value = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state, name2, value);
      return CharSetOk;
    }
  }
  state.pos = start2;
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
  }
  return CharSetNone;
};
pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name2, value) {
  if (!hasOwn(state.unicodeProperties.nonBinary, name2)) {
    state.raise("Invalid property name");
  }
  if (!state.unicodeProperties.nonBinary[name2].test(value)) {
    state.raise("Invalid property value");
  }
};
pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
  if (state.unicodeProperties.binary.test(nameOrValue)) {
    return CharSetOk;
  }
  if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {
    return CharSetString;
  }
  state.raise("Invalid property name");
};
pp$1.regexp_eatUnicodePropertyName = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyNameCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== "";
};
function isUnicodePropertyNameCharacter(ch) {
  return isControlLetter(ch) || ch === 95;
}
pp$1.regexp_eatUnicodePropertyValue = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyValueCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== "";
};
function isUnicodePropertyValueCharacter(ch) {
  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
}
pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
  return this.regexp_eatUnicodePropertyValue(state);
};
pp$1.regexp_eatCharacterClass = function(state) {
  if (state.eat(
    91
    /* [ */
  )) {
    var negate = state.eat(
      94
      /* ^ */
    );
    var result = this.regexp_classContents(state);
    if (!state.eat(
      93
      /* ] */
    )) {
      state.raise("Unterminated character class");
    }
    if (negate && result === CharSetString) {
      state.raise("Negated character class may contain strings");
    }
    return true;
  }
  return false;
};
pp$1.regexp_classContents = function(state) {
  if (state.current() === 93) {
    return CharSetOk;
  }
  if (state.switchV) {
    return this.regexp_classSetExpression(state);
  }
  this.regexp_nonEmptyClassRanges(state);
  return CharSetOk;
};
pp$1.regexp_nonEmptyClassRanges = function(state) {
  while (this.regexp_eatClassAtom(state)) {
    var left = state.lastIntValue;
    if (state.eat(
      45
      /* - */
    ) && this.regexp_eatClassAtom(state)) {
      var right = state.lastIntValue;
      if (state.switchU && (left === -1 || right === -1)) {
        state.raise("Invalid character class");
      }
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
    }
  }
};
pp$1.regexp_eatClassAtom = function(state) {
  var start2 = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatClassEscape(state)) {
      return true;
    }
    if (state.switchU) {
      var ch$1 = state.current();
      if (ch$1 === 99 || isOctalDigit(ch$1)) {
        state.raise("Invalid class escape");
      }
      state.raise("Invalid escape");
    }
    state.pos = start2;
  }
  var ch = state.current();
  if (ch !== 93) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatClassEscape = function(state) {
  var start2 = state.pos;
  if (state.eat(
    98
    /* b */
  )) {
    state.lastIntValue = 8;
    return true;
  }
  if (state.switchU && state.eat(
    45
    /* - */
  )) {
    state.lastIntValue = 45;
    return true;
  }
  if (!state.switchU && state.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatClassControlLetter(state)) {
      return true;
    }
    state.pos = start2;
  }
  return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
};
pp$1.regexp_classSetExpression = function(state) {
  var result = CharSetOk, subResult;
  if (this.regexp_eatClassSetRange(state)) ;
  else if (subResult = this.regexp_eatClassSetOperand(state)) {
    if (subResult === CharSetString) {
      result = CharSetString;
    }
    var start2 = state.pos;
    while (state.eatChars(
      [38, 38]
      /* && */
    )) {
      if (state.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state))) {
        if (subResult !== CharSetString) {
          result = CharSetOk;
        }
        continue;
      }
      state.raise("Invalid character in character class");
    }
    if (start2 !== state.pos) {
      return result;
    }
    while (state.eatChars(
      [45, 45]
      /* -- */
    )) {
      if (this.regexp_eatClassSetOperand(state)) {
        continue;
      }
      state.raise("Invalid character in character class");
    }
    if (start2 !== state.pos) {
      return result;
    }
  } else {
    state.raise("Invalid character in character class");
  }
  for (; ; ) {
    if (this.regexp_eatClassSetRange(state)) {
      continue;
    }
    subResult = this.regexp_eatClassSetOperand(state);
    if (!subResult) {
      return result;
    }
    if (subResult === CharSetString) {
      result = CharSetString;
    }
  }
};
pp$1.regexp_eatClassSetRange = function(state) {
  var start2 = state.pos;
  if (this.regexp_eatClassSetCharacter(state)) {
    var left = state.lastIntValue;
    if (state.eat(
      45
      /* - */
    ) && this.regexp_eatClassSetCharacter(state)) {
      var right = state.lastIntValue;
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
      return true;
    }
    state.pos = start2;
  }
  return false;
};
pp$1.regexp_eatClassSetOperand = function(state) {
  if (this.regexp_eatClassSetCharacter(state)) {
    return CharSetOk;
  }
  return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
};
pp$1.regexp_eatNestedClass = function(state) {
  var start2 = state.pos;
  if (state.eat(
    91
    /* [ */
  )) {
    var negate = state.eat(
      94
      /* ^ */
    );
    var result = this.regexp_classContents(state);
    if (state.eat(
      93
      /* ] */
    )) {
      if (negate && result === CharSetString) {
        state.raise("Negated character class may contain strings");
      }
      return result;
    }
    state.pos = start2;
  }
  if (state.eat(
    92
    /* \ */
  )) {
    var result$1 = this.regexp_eatCharacterClassEscape(state);
    if (result$1) {
      return result$1;
    }
    state.pos = start2;
  }
  return null;
};
pp$1.regexp_eatClassStringDisjunction = function(state) {
  var start2 = state.pos;
  if (state.eatChars(
    [92, 113]
    /* \q */
  )) {
    if (state.eat(
      123
      /* { */
    )) {
      var result = this.regexp_classStringDisjunctionContents(state);
      if (state.eat(
        125
        /* } */
      )) {
        return result;
      }
    } else {
      state.raise("Invalid escape");
    }
    state.pos = start2;
  }
  return null;
};
pp$1.regexp_classStringDisjunctionContents = function(state) {
  var result = this.regexp_classString(state);
  while (state.eat(
    124
    /* | */
  )) {
    if (this.regexp_classString(state) === CharSetString) {
      result = CharSetString;
    }
  }
  return result;
};
pp$1.regexp_classString = function(state) {
  var count = 0;
  while (this.regexp_eatClassSetCharacter(state)) {
    count++;
  }
  return count === 1 ? CharSetOk : CharSetString;
};
pp$1.regexp_eatClassSetCharacter = function(state) {
  var start2 = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {
      return true;
    }
    if (state.eat(
      98
      /* b */
    )) {
      state.lastIntValue = 8;
      return true;
    }
    state.pos = start2;
    return false;
  }
  var ch = state.current();
  if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) {
    return false;
  }
  if (isClassSetSyntaxCharacter(ch)) {
    return false;
  }
  state.advance();
  state.lastIntValue = ch;
  return true;
};
function isClassSetReservedDoublePunctuatorCharacter(ch) {
  return ch === 33 || ch >= 35 && ch <= 38 || ch >= 42 && ch <= 44 || ch === 46 || ch >= 58 && ch <= 64 || ch === 94 || ch === 96 || ch === 126;
}
function isClassSetSyntaxCharacter(ch) {
  return ch === 40 || ch === 41 || ch === 45 || ch === 47 || ch >= 91 && ch <= 93 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
  var ch = state.current();
  if (isClassSetReservedPunctuator(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
function isClassSetReservedPunctuator(ch) {
  return ch === 33 || ch === 35 || ch === 37 || ch === 38 || ch === 44 || ch === 45 || ch >= 58 && ch <= 62 || ch === 64 || ch === 96 || ch === 126;
}
pp$1.regexp_eatClassControlLetter = function(state) {
  var ch = state.current();
  if (isDecimalDigit(ch) || ch === 95) {
    state.lastIntValue = ch % 32;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatHexEscapeSequence = function(state) {
  var start2 = state.pos;
  if (state.eat(
    120
    /* x */
  )) {
    if (this.regexp_eatFixedHexDigits(state, 2)) {
      return true;
    }
    if (state.switchU) {
      state.raise("Invalid escape");
    }
    state.pos = start2;
  }
  return false;
};
pp$1.regexp_eatDecimalDigits = function(state) {
  var start2 = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isDecimalDigit(ch = state.current())) {
    state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
    state.advance();
  }
  return state.pos !== start2;
};
function isDecimalDigit(ch) {
  return ch >= 48 && ch <= 57;
}
pp$1.regexp_eatHexDigits = function(state) {
  var start2 = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isHexDigit(ch = state.current())) {
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return state.pos !== start2;
};
function isHexDigit(ch) {
  return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
}
function hexToInt(ch) {
  if (ch >= 65 && ch <= 70) {
    return 10 + (ch - 65);
  }
  if (ch >= 97 && ch <= 102) {
    return 10 + (ch - 97);
  }
  return ch - 48;
}
pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
  if (this.regexp_eatOctalDigit(state)) {
    var n1 = state.lastIntValue;
    if (this.regexp_eatOctalDigit(state)) {
      var n2 = state.lastIntValue;
      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n2;
      }
    } else {
      state.lastIntValue = n1;
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatOctalDigit = function(state) {
  var ch = state.current();
  if (isOctalDigit(ch)) {
    state.lastIntValue = ch - 48;
    state.advance();
    return true;
  }
  state.lastIntValue = 0;
  return false;
};
function isOctalDigit(ch) {
  return ch >= 48 && ch <= 55;
}
pp$1.regexp_eatFixedHexDigits = function(state, length) {
  var start2 = state.pos;
  state.lastIntValue = 0;
  for (var i = 0; i < length; ++i) {
    var ch = state.current();
    if (!isHexDigit(ch)) {
      state.pos = start2;
      return false;
    }
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return true;
};
var Token = function Token2(p2) {
  this.type = p2.type;
  this.value = p2.value;
  this.start = p2.start;
  this.end = p2.end;
  if (p2.options.locations) {
    this.loc = new SourceLocation(p2, p2.startLoc, p2.endLoc);
  }
  if (p2.options.ranges) {
    this.range = [p2.start, p2.end];
  }
};
var pp = Parser.prototype;
pp.next = function(ignoreEscapeSequenceInKeyword) {
  if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
  }
  if (this.options.onToken) {
    this.options.onToken(new Token(this));
  }
  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};
pp.getToken = function() {
  this.next();
  return new Token(this);
};
if (typeof Symbol !== "undefined") {
  pp[Symbol.iterator] = function() {
    var this$1$1 = this;
    return {
      next: function() {
        var token = this$1$1.getToken();
        return {
          done: token.type === types$1.eof,
          value: token
        };
      }
    };
  };
}
pp.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) {
    this.skipSpace();
  }
  this.start = this.pos;
  if (this.options.locations) {
    this.startLoc = this.curPosition();
  }
  if (this.pos >= this.input.length) {
    return this.finishToken(types$1.eof);
  }
  if (curContext.override) {
    return curContext.override(this);
  } else {
    this.readToken(this.fullCharCodeAtPos());
  }
};
pp.readToken = function(code2) {
  if (isIdentifierStart(code2, this.options.ecmaVersion >= 6) || code2 === 92) {
    return this.readWord();
  }
  return this.getTokenFromCode(code2);
};
pp.fullCharCodeAtPos = function() {
  var code2 = this.input.charCodeAt(this.pos);
  if (code2 <= 55295 || code2 >= 56320) {
    return code2;
  }
  var next2 = this.input.charCodeAt(this.pos + 1);
  return next2 <= 56319 || next2 >= 57344 ? code2 : (code2 << 10) + next2 - 56613888;
};
pp.skipBlockComment = function() {
  var startLoc = this.options.onComment && this.curPosition();
  var start2 = this.pos, end2 = this.input.indexOf("*/", this.pos += 2);
  if (end2 === -1) {
    this.raise(this.pos - 2, "Unterminated comment");
  }
  this.pos = end2 + 2;
  if (this.options.locations) {
    for (var nextBreak = void 0, pos = start2; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1; ) {
      ++this.curLine;
      pos = this.lineStart = nextBreak;
    }
  }
  if (this.options.onComment) {
    this.options.onComment(
      true,
      this.input.slice(start2 + 2, end2),
      start2,
      this.pos,
      startLoc,
      this.curPosition()
    );
  }
};
pp.skipLineComment = function(startSkip) {
  var start2 = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && !isNewLine(ch)) {
    ch = this.input.charCodeAt(++this.pos);
  }
  if (this.options.onComment) {
    this.options.onComment(
      false,
      this.input.slice(start2 + startSkip, this.pos),
      start2,
      this.pos,
      startLoc,
      this.curPosition()
    );
  }
};
pp.skipSpace = function() {
  loop: while (this.pos < this.input.length) {
    var ch = this.input.charCodeAt(this.pos);
    switch (ch) {
      case 32:
      case 160:
        ++this.pos;
        break;
      case 13:
        if (this.input.charCodeAt(this.pos + 1) === 10) {
          ++this.pos;
        }
      case 10:
      case 8232:
      case 8233:
        ++this.pos;
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        break;
      case 47:
        switch (this.input.charCodeAt(this.pos + 1)) {
          case 42:
            this.skipBlockComment();
            break;
          case 47:
            this.skipLineComment(2);
            break;
          default:
            break loop;
        }
        break;
      default:
        if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
          ++this.pos;
        } else {
          break loop;
        }
    }
  }
};
pp.finishToken = function(type2, val) {
  this.end = this.pos;
  if (this.options.locations) {
    this.endLoc = this.curPosition();
  }
  var prevType = this.type;
  this.type = type2;
  this.value = val;
  this.updateContext(prevType);
};
pp.readToken_dot = function() {
  var next2 = this.input.charCodeAt(this.pos + 1);
  if (next2 >= 48 && next2 <= 57) {
    return this.readNumber(true);
  }
  var next22 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next2 === 46 && next22 === 46) {
    this.pos += 3;
    return this.finishToken(types$1.ellipsis);
  } else {
    ++this.pos;
    return this.finishToken(types$1.dot);
  }
};
pp.readToken_slash = function() {
  var next2 = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) {
    ++this.pos;
    return this.readRegexp();
  }
  if (next2 === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.slash, 1);
};
pp.readToken_mult_modulo_exp = function(code2) {
  var next2 = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code2 === 42 ? types$1.star : types$1.modulo;
  if (this.options.ecmaVersion >= 7 && code2 === 42 && next2 === 42) {
    ++size;
    tokentype = types$1.starstar;
    next2 = this.input.charCodeAt(this.pos + 2);
  }
  if (next2 === 61) {
    return this.finishOp(types$1.assign, size + 1);
  }
  return this.finishOp(tokentype, size);
};
pp.readToken_pipe_amp = function(code2) {
  var next2 = this.input.charCodeAt(this.pos + 1);
  if (next2 === code2) {
    if (this.options.ecmaVersion >= 12) {
      var next22 = this.input.charCodeAt(this.pos + 2);
      if (next22 === 61) {
        return this.finishOp(types$1.assign, 3);
      }
    }
    return this.finishOp(code2 === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
  }
  if (next2 === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(code2 === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
};
pp.readToken_caret = function() {
  var next2 = this.input.charCodeAt(this.pos + 1);
  if (next2 === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.bitwiseXOR, 1);
};
pp.readToken_plus_min = function(code2) {
  var next2 = this.input.charCodeAt(this.pos + 1);
  if (next2 === code2) {
    if (next2 === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken();
    }
    return this.finishOp(types$1.incDec, 2);
  }
  if (next2 === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.plusMin, 1);
};
pp.readToken_lt_gt = function(code2) {
  var next2 = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next2 === code2) {
    size = code2 === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) {
      return this.finishOp(types$1.assign, size + 1);
    }
    return this.finishOp(types$1.bitShift, size);
  }
  if (next2 === 33 && code2 === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken();
  }
  if (next2 === 61) {
    size = 2;
  }
  return this.finishOp(types$1.relational, size);
};
pp.readToken_eq_excl = function(code2) {
  var next2 = this.input.charCodeAt(this.pos + 1);
  if (next2 === 61) {
    return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
  }
  if (code2 === 61 && next2 === 62 && this.options.ecmaVersion >= 6) {
    this.pos += 2;
    return this.finishToken(types$1.arrow);
  }
  return this.finishOp(code2 === 61 ? types$1.eq : types$1.prefix, 1);
};
pp.readToken_question = function() {
  var ecmaVersion = this.options.ecmaVersion;
  if (ecmaVersion >= 11) {
    var next2 = this.input.charCodeAt(this.pos + 1);
    if (next2 === 46) {
      var next22 = this.input.charCodeAt(this.pos + 2);
      if (next22 < 48 || next22 > 57) {
        return this.finishOp(types$1.questionDot, 2);
      }
    }
    if (next2 === 63) {
      if (ecmaVersion >= 12) {
        var next2$1 = this.input.charCodeAt(this.pos + 2);
        if (next2$1 === 61) {
          return this.finishOp(types$1.assign, 3);
        }
      }
      return this.finishOp(types$1.coalesce, 2);
    }
  }
  return this.finishOp(types$1.question, 1);
};
pp.readToken_numberSign = function() {
  var ecmaVersion = this.options.ecmaVersion;
  var code2 = 35;
  if (ecmaVersion >= 13) {
    ++this.pos;
    code2 = this.fullCharCodeAtPos();
    if (isIdentifierStart(code2, true) || code2 === 92) {
      return this.finishToken(types$1.privateId, this.readWord1());
    }
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code2) + "'");
};
pp.getTokenFromCode = function(code2) {
  switch (code2) {
    // The interpretation of a dot depends on whether it is followed
    // by a digit or another two dots.
    case 46:
      return this.readToken_dot();
    // Punctuation tokens.
    case 40:
      ++this.pos;
      return this.finishToken(types$1.parenL);
    case 41:
      ++this.pos;
      return this.finishToken(types$1.parenR);
    case 59:
      ++this.pos;
      return this.finishToken(types$1.semi);
    case 44:
      ++this.pos;
      return this.finishToken(types$1.comma);
    case 91:
      ++this.pos;
      return this.finishToken(types$1.bracketL);
    case 93:
      ++this.pos;
      return this.finishToken(types$1.bracketR);
    case 123:
      ++this.pos;
      return this.finishToken(types$1.braceL);
    case 125:
      ++this.pos;
      return this.finishToken(types$1.braceR);
    case 58:
      ++this.pos;
      return this.finishToken(types$1.colon);
    case 96:
      if (this.options.ecmaVersion < 6) {
        break;
      }
      ++this.pos;
      return this.finishToken(types$1.backQuote);
    case 48:
      var next2 = this.input.charCodeAt(this.pos + 1);
      if (next2 === 120 || next2 === 88) {
        return this.readRadixNumber(16);
      }
      if (this.options.ecmaVersion >= 6) {
        if (next2 === 111 || next2 === 79) {
          return this.readRadixNumber(8);
        }
        if (next2 === 98 || next2 === 66) {
          return this.readRadixNumber(2);
        }
      }
    // Anything else beginning with a digit is an integer, octal
    // number, or float.
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      return this.readNumber(false);
    // Quotes produce strings.
    case 34:
    case 39:
      return this.readString(code2);
    // Operators are parsed inline in tiny state machines. '=' (61) is
    // often referred to. `finishOp` simply skips the amount of
    // characters it is given as second argument, and returns a token
    // of the type given by its first argument.
    case 47:
      return this.readToken_slash();
    case 37:
    case 42:
      return this.readToken_mult_modulo_exp(code2);
    case 124:
    case 38:
      return this.readToken_pipe_amp(code2);
    case 94:
      return this.readToken_caret();
    case 43:
    case 45:
      return this.readToken_plus_min(code2);
    case 60:
    case 62:
      return this.readToken_lt_gt(code2);
    case 61:
    case 33:
      return this.readToken_eq_excl(code2);
    case 63:
      return this.readToken_question();
    case 126:
      return this.finishOp(types$1.prefix, 1);
    case 35:
      return this.readToken_numberSign();
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code2) + "'");
};
pp.finishOp = function(type2, size) {
  var str2 = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type2, str2);
};
pp.readRegexp = function() {
  var escaped, inClass, start2 = this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(start2, "Unterminated regular expression");
    }
    var ch = this.input.charAt(this.pos);
    if (lineBreak.test(ch)) {
      this.raise(start2, "Unterminated regular expression");
    }
    if (!escaped) {
      if (ch === "[") {
        inClass = true;
      } else if (ch === "]" && inClass) {
        inClass = false;
      } else if (ch === "/" && !inClass) {
        break;
      }
      escaped = ch === "\\";
    } else {
      escaped = false;
    }
    ++this.pos;
  }
  var pattern = this.input.slice(start2, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();
  if (this.containsEsc) {
    this.unexpected(flagsStart);
  }
  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state.reset(start2, pattern, flags);
  this.validateRegExpFlags(state);
  this.validateRegExpPattern(state);
  var value = null;
  try {
    value = new RegExp(pattern, flags);
  } catch (e2) {
  }
  return this.finishToken(types$1.regexp, { pattern, flags, value });
};
pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
  var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
  var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
  var start2 = this.pos, total = 0, lastCode = 0;
  for (var i = 0, e2 = len == null ? Infinity : len; i < e2; ++i, ++this.pos) {
    var code2 = this.input.charCodeAt(this.pos), val = void 0;
    if (allowSeparators && code2 === 95) {
      if (isLegacyOctalNumericLiteral) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
      }
      if (lastCode === 95) {
        this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
      }
      if (i === 0) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
      }
      lastCode = code2;
      continue;
    }
    if (code2 >= 97) {
      val = code2 - 97 + 10;
    } else if (code2 >= 65) {
      val = code2 - 65 + 10;
    } else if (code2 >= 48 && code2 <= 57) {
      val = code2 - 48;
    } else {
      val = Infinity;
    }
    if (val >= radix) {
      break;
    }
    lastCode = code2;
    total = total * radix + val;
  }
  if (allowSeparators && lastCode === 95) {
    this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
  }
  if (this.pos === start2 || len != null && this.pos - start2 !== len) {
    return null;
  }
  return total;
};
function stringToNumber(str2, isLegacyOctalNumericLiteral) {
  if (isLegacyOctalNumericLiteral) {
    return parseInt(str2, 8);
  }
  return parseFloat(str2.replace(/_/g, ""));
}
function stringToBigInt(str2) {
  if (typeof BigInt !== "function") {
    return null;
  }
  return BigInt(str2.replace(/_/g, ""));
}
pp.readRadixNumber = function(radix) {
  var start2 = this.pos;
  this.pos += 2;
  var val = this.readInt(radix);
  if (val == null) {
    this.raise(this.start + 2, "Expected number in radix " + radix);
  }
  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
    val = stringToBigInt(this.input.slice(start2, this.pos));
    ++this.pos;
  } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  return this.finishToken(types$1.num, val);
};
pp.readNumber = function(startsWithDot) {
  var start2 = this.pos;
  if (!startsWithDot && this.readInt(10, void 0, true) === null) {
    this.raise(start2, "Invalid number");
  }
  var octal = this.pos - start2 >= 2 && this.input.charCodeAt(start2) === 48;
  if (octal && this.strict) {
    this.raise(start2, "Invalid number");
  }
  var next2 = this.input.charCodeAt(this.pos);
  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next2 === 110) {
    var val$1 = stringToBigInt(this.input.slice(start2, this.pos));
    ++this.pos;
    if (isIdentifierStart(this.fullCharCodeAtPos())) {
      this.raise(this.pos, "Identifier directly after number");
    }
    return this.finishToken(types$1.num, val$1);
  }
  if (octal && /[89]/.test(this.input.slice(start2, this.pos))) {
    octal = false;
  }
  if (next2 === 46 && !octal) {
    ++this.pos;
    this.readInt(10);
    next2 = this.input.charCodeAt(this.pos);
  }
  if ((next2 === 69 || next2 === 101) && !octal) {
    next2 = this.input.charCodeAt(++this.pos);
    if (next2 === 43 || next2 === 45) {
      ++this.pos;
    }
    if (this.readInt(10) === null) {
      this.raise(start2, "Invalid number");
    }
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  var val = stringToNumber(this.input.slice(start2, this.pos), octal);
  return this.finishToken(types$1.num, val);
};
pp.readCodePoint = function() {
  var ch = this.input.charCodeAt(this.pos), code2;
  if (ch === 123) {
    if (this.options.ecmaVersion < 6) {
      this.unexpected();
    }
    var codePos = ++this.pos;
    code2 = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code2 > 1114111) {
      this.invalidStringToken(codePos, "Code point out of bounds");
    }
  } else {
    code2 = this.readHexChar(4);
  }
  return code2;
};
pp.readString = function(quote) {
  var out = "", chunkStart = ++this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated string constant");
    }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === quote) {
      break;
    }
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else if (ch === 8232 || ch === 8233) {
      if (this.options.ecmaVersion < 10) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
      if (this.options.locations) {
        this.curLine++;
        this.lineStart = this.pos;
      }
    } else {
      if (isNewLine(ch)) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types$1.string, out);
};
var INVALID_TEMPLATE_ESCAPE_ERROR = {};
pp.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err;
    }
  }
  this.inTemplateElement = false;
};
pp.invalidStringToken = function(position2, message2) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR;
  } else {
    this.raise(position2, message2);
  }
};
pp.readTmplToken = function() {
  var out = "", chunkStart = this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated template");
    }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
      if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
        if (ch === 36) {
          this.pos += 2;
          return this.finishToken(types$1.dollarBraceL);
        } else {
          ++this.pos;
          return this.finishToken(types$1.backQuote);
        }
      }
      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(types$1.template, out);
    }
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch) {
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
          }
        case 10:
          out += "\n";
          break;
        default:
          out += String.fromCharCode(ch);
          break;
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
};
pp.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++) {
    switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break;
      case "$":
        if (this.input[this.pos + 1] !== "{") {
          break;
        }
      // fall through
      case "`":
        return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
      case "\r":
        if (this.input[this.pos + 1] === "\n") {
          ++this.pos;
        }
      // fall through
      case "\n":
      case "\u2028":
      case "\u2029":
        ++this.curLine;
        this.lineStart = this.pos + 1;
        break;
    }
  }
  this.raise(this.start, "Unterminated template");
};
pp.readEscapedChar = function(inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
    case 110:
      return "\n";
    // 'n' -> '\n'
    case 114:
      return "\r";
    // 'r' -> '\r'
    case 120:
      return String.fromCharCode(this.readHexChar(2));
    // 'x'
    case 117:
      return codePointToString(this.readCodePoint());
    // 'u'
    case 116:
      return "	";
    // 't' -> '\t'
    case 98:
      return "\b";
    // 'b' -> '\b'
    case 118:
      return "\v";
    // 'v' -> '\u000b'
    case 102:
      return "\f";
    // 'f' -> '\f'
    case 13:
      if (this.input.charCodeAt(this.pos) === 10) {
        ++this.pos;
      }
    // '\r\n'
    case 10:
      if (this.options.locations) {
        this.lineStart = this.pos;
        ++this.curLine;
      }
      return "";
    case 56:
    case 57:
      if (this.strict) {
        this.invalidStringToken(
          this.pos - 1,
          "Invalid escape sequence"
        );
      }
      if (inTemplate) {
        var codePos = this.pos - 1;
        this.invalidStringToken(
          codePos,
          "Invalid escape sequence in template string"
        );
      }
    default:
      if (ch >= 48 && ch <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);
        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }
        this.pos += octalStr.length - 1;
        ch = this.input.charCodeAt(this.pos);
        if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
          this.invalidStringToken(
            this.pos - 1 - octalStr.length,
            inTemplate ? "Octal literal in template string" : "Octal literal in strict mode"
          );
        }
        return String.fromCharCode(octal);
      }
      if (isNewLine(ch)) {
        if (this.options.locations) {
          this.lineStart = this.pos;
          ++this.curLine;
        }
        return "";
      }
      return String.fromCharCode(ch);
  }
};
pp.readHexChar = function(len) {
  var codePos = this.pos;
  var n = this.readInt(16, len);
  if (n === null) {
    this.invalidStringToken(codePos, "Bad character escape sequence");
  }
  return n;
};
pp.readWord1 = function() {
  this.containsEsc = false;
  var word2 = "", first2 = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch = this.fullCharCodeAtPos();
    if (isIdentifierChar(ch, astral)) {
      this.pos += ch <= 65535 ? 1 : 2;
    } else if (ch === 92) {
      this.containsEsc = true;
      word2 += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) !== 117) {
        this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
      }
      ++this.pos;
      var esc = this.readCodePoint();
      if (!(first2 ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
        this.invalidStringToken(escStart, "Invalid Unicode escape");
      }
      word2 += codePointToString(esc);
      chunkStart = this.pos;
    } else {
      break;
    }
    first2 = false;
  }
  return word2 + this.input.slice(chunkStart, this.pos);
};
pp.readWord = function() {
  var word2 = this.readWord1();
  var type2 = types$1.name;
  if (this.keywords.test(word2)) {
    type2 = keywords[word2];
  }
  return this.finishToken(type2, word2);
};
var version = "8.15.0";
Parser.acorn = {
  Parser,
  version,
  defaultOptions,
  Position,
  SourceLocation,
  getLineInfo,
  Node,
  TokenType,
  tokTypes: types$1,
  keywordTypes: keywords,
  TokContext,
  tokContexts: types,
  isIdentifierChar,
  isIdentifierStart,
  Token,
  isNewLine,
  lineBreak,
  lineBreakG,
  nonASCIIwhitespace
};
function parse3(input, options2) {
  return Parser.parse(input, options2);
}
function parseExpressionAt2(input, pos, options2) {
  return Parser.parseExpressionAt(input, pos, options2);
}
function tokenizer2(input, options2) {
  return Parser.tokenizer(input, options2);
}

// node_modules/.deno/@sveltejs+acorn-typescript@1.0.7/node_modules/@sveltejs/acorn-typescript/index.js
var startsExpr2 = true;
function kwLike(_name, options2 = {}) {
  return new TokenType("name", options2);
}
var acornTypeScriptMap = /* @__PURE__ */ new WeakMap();
var keywordTypeValues = Object.values(keywords);
function generateAcornTypeScript(_acorn) {
  const acorn = _acorn.Parser.acorn || _acorn;
  let acornTypeScript = acornTypeScriptMap.get(acorn);
  if (!acornTypeScript) {
    let tokenIsLiteralPropertyName = function(token) {
      return token === types$1.name || token === types$1.string || token === types$1.num || keywordTypeValues.includes(token) || tsKwTokenTypeValues.includes(token);
    }, tokenIsKeywordOrIdentifier = function(token) {
      return token === types$1.name || keywordTypeValues.includes(token) || tsKwTokenTypeValues.includes(token);
    }, tokenIsIdentifier = function(token) {
      return token === types$1.name || tsKwTokenTypeValues.includes(token);
    }, tokenIsTSDeclarationStart = function(token) {
      return token === tsKwTokenType.abstract || token === tsKwTokenType.declare || token === tsKwTokenType.enum || token === tsKwTokenType.module || token === tsKwTokenType.namespace || token === tsKwTokenType.interface || token === tsKwTokenType.type;
    }, tokenIsTSTypeOperator = function(token) {
      return token === tsKwTokenType.keyof || token === tsKwTokenType.readonly || token === tsKwTokenType.unique;
    }, tokenIsTemplate = function(token) {
      return token === types$1.invalidTemplate;
    };
    const tsKwTokenType = generateTsKwTokenType();
    const tsKwTokenTypeValues = Object.values(tsKwTokenType);
    const tsTokenType = generateTsTokenType();
    const tsTokenContext = generateTsTokenContext();
    const tsKeywordsRegExp = new RegExp(`^(?:${Object.keys(tsKwTokenType).join("|")})$`);
    tsTokenType.jsxTagStart.updateContext = function() {
      this.context.push(tsTokenContext.tc_expr);
      this.context.push(tsTokenContext.tc_oTag);
      this.exprAllowed = false;
    };
    tsTokenType.jsxTagEnd.updateContext = function(prevType) {
      let out = this.context.pop();
      if (out === tsTokenContext.tc_oTag && prevType === types$1.slash || out === tsTokenContext.tc_cTag) {
        this.context.pop();
        this.exprAllowed = this.curContext() === tsTokenContext.tc_expr;
      } else {
        this.exprAllowed = true;
      }
    };
    acornTypeScript = {
      tokTypes: {
        ...tsKwTokenType,
        ...tsTokenType
      },
      tokContexts: {
        ...tsTokenContext
      },
      keywordsRegExp: tsKeywordsRegExp,
      tokenIsLiteralPropertyName,
      tokenIsKeywordOrIdentifier,
      tokenIsIdentifier,
      tokenIsTSDeclarationStart,
      tokenIsTSTypeOperator,
      tokenIsTemplate
    };
  }
  return acornTypeScript;
}
function generateTsTokenContext() {
  return {
    tc_oTag: new TokContext("<tag", false, false),
    tc_cTag: new TokContext("</tag", false, false),
    tc_expr: new TokContext("<tag>...</tag>", true, true)
  };
}
function generateTsTokenType() {
  return {
    // @ts-expect-error
    at: new TokenType("@"),
    // @ts-expect-error
    jsxName: new TokenType("jsxName"),
    // @ts-expect-error
    jsxText: new TokenType("jsxText", { beforeExpr: true }),
    // @ts-expect-error
    jsxTagStart: new TokenType("jsxTagStart", { startsExpr: true }),
    // @ts-expect-error
    jsxTagEnd: new TokenType("jsxTagEnd")
  };
}
function generateTsKwTokenType() {
  return {
    assert: kwLike("assert", { startsExpr: startsExpr2 }),
    asserts: kwLike("asserts", { startsExpr: startsExpr2 }),
    global: kwLike("global", { startsExpr: startsExpr2 }),
    keyof: kwLike("keyof", { startsExpr: startsExpr2 }),
    readonly: kwLike("readonly", { startsExpr: startsExpr2 }),
    unique: kwLike("unique", { startsExpr: startsExpr2 }),
    abstract: kwLike("abstract", { startsExpr: startsExpr2 }),
    declare: kwLike("declare", { startsExpr: startsExpr2 }),
    enum: kwLike("enum", { startsExpr: startsExpr2 }),
    module: kwLike("module", { startsExpr: startsExpr2 }),
    namespace: kwLike("namespace", { startsExpr: startsExpr2 }),
    interface: kwLike("interface", { startsExpr: startsExpr2 }),
    type: kwLike("type", { startsExpr: startsExpr2 })
  };
}
var TS_SCOPE_OTHER = 512;
var TS_SCOPE_TS_MODULE = 1024;
var BIND_KIND_VALUE = 1;
var BIND_KIND_TYPE = 2;
var BIND_SCOPE_VAR = 4;
var BIND_SCOPE_LEXICAL = 8;
var BIND_SCOPE_FUNCTION = 16;
var BIND_FLAGS_NONE = 64;
var BIND_FLAGS_CLASS = 128;
var BIND_FLAGS_TS_ENUM = 256;
var BIND_FLAGS_TS_CONST_ENUM = 512;
var BIND_FLAGS_TS_EXPORT_ONLY = 1024;
var BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS;
var BIND_LEXICAL2 = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0;
var BIND_VAR2 = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0;
var BIND_FUNCTION2 = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0;
var BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS;
var BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0 | 0;
var BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM;
var BIND_TS_AMBIENT = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY;
var BIND_NONE2 = 0 | 0 | 0 | BIND_FLAGS_NONE;
var BIND_OUTSIDE2 = BIND_KIND_VALUE | 0 | 0 | BIND_FLAGS_NONE;
var BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM;
var BIND_TS_NAMESPACE = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY;
var CLASS_ELEMENT_FLAG_STATIC = 4;
var CLASS_ELEMENT_KIND_GETTER = 2;
var CLASS_ELEMENT_KIND_SETTER = 1;
var CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;
var CLASS_ELEMENT_STATIC_GETTER = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC;
var CLASS_ELEMENT_STATIC_SETTER = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC;
var skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y;
var skipWhiteSpaceToLineBreak = new RegExp(
  // Unfortunately JS doesn't support Perl's atomic /(?>pattern)/ or
  // possessive quantifiers, so we use a trick to prevent backtracking
  // when the look-ahead for line terminator fails.
  "(?=(" + // Capture the whitespace and comments that should be skipped inside
  // a look-ahead assertion, and then re-match the group as a unit.
  skipWhiteSpaceInLine.source + "))\\1" + // Look-ahead for either line terminator, start of multi-line comment,
  // or end of string.
  /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source,
  "y"
  // sticky
);
var DestructuringErrors3 = class {
  constructor() {
    this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
  }
};
function isPrivateNameConflicted2(privateNameMap, element3) {
  const name2 = element3.key.name;
  const curr = privateNameMap[name2];
  let next2 = "true";
  if (element3.type === "MethodDefinition" && (element3.kind === "get" || element3.kind === "set")) {
    next2 = (element3.static ? "s" : "i") + element3.kind;
  }
  if (curr === "iget" && next2 === "iset" || curr === "iset" && next2 === "iget" || curr === "sget" && next2 === "sset" || curr === "sset" && next2 === "sget") {
    privateNameMap[name2] = "true";
    return false;
  } else if (!curr) {
    privateNameMap[name2] = next2;
    return false;
  } else {
    return true;
  }
}
function checkKeyName2(node, name2) {
  const { computed, key: key2 } = node;
  return !computed && (key2.type === "Identifier" && key2.name === name2 || key2.type === "Literal" && key2.value === name2);
}
var TypeScriptError = {
  AbstractMethodHasImplementation: ({ methodName }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,
  AbstractPropertyHasInitializer: ({ propertyName }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,
  AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
  AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
  CannotFindName: ({ name: name2 }) => `Cannot find name '${name2}'.`,
  ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
  ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
  ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
  ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
  DeclareAccessor: ({ kind }) => `'declare' is not allowed in ${kind}ters.`,
  DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
  DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
  DuplicateAccessibilityModifier: (
    // `Accessibility modifier already seen: ${modifier}` would be more helpful.
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    (() => `Accessibility modifier already seen.`)
  ),
  DuplicateModifier: ({ modifier }) => `Duplicate modifier: '${modifier}'.`,
  // `token` matches the terminology used by typescript:
  // https://github.com/microsoft/TypeScript/blob/main/src/compiler/types.ts#L2915
  EmptyHeritageClauseType: ({ token }) => `'${token}' list cannot be empty.`,
  EmptyTypeArguments: "Type argument list cannot be empty.",
  EmptyTypeParameters: "Type parameter list cannot be empty.",
  ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
  ImportAliasHasImportType: "An import alias can not use 'import type'.",
  IncompatibleModifiers: ({ modifiers }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,
  IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
  IndexSignatureHasAccessibility: ({ modifier }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,
  IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
  IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
  IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
  InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
  InvalidModifierOnTypeMember: ({ modifier }) => `'${modifier}' modifier cannot appear on a type member.`,
  InvalidModifierOnTypeParameter: ({ modifier }) => `'${modifier}' modifier cannot appear on a type parameter.`,
  InvalidModifierOnTypeParameterPositions: ({ modifier }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,
  InvalidModifiersOrder: ({ orderedModifiers }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,
  InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
  InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
  MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
  NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
  NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
  OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
  OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
  PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
  PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
  PrivateElementHasAccessibility: ({ modifier }) => `Private elements cannot have an accessibility modifier ('${modifier}').`,
  PrivateMethodsHasAccessibility: ({ modifier }) => `Private methods cannot have an accessibility modifier ('${modifier}').`,
  ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
  ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
  ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
  SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
  SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
  SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
  SingleTypeParameterWithoutTrailingComma: ({ typeParameterName }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,
  StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
  TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
  TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
  TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
  TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
  UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
  UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
  GenericsEndWithComma: `Trailing comma is not allowed at the end of generics.`,
  UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
  UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
  UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
  UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
  UnsupportedSignatureParameterKind: ({ type: type2 }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type2}.`,
  LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations."
};
var DecoratorsError = {
  UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
  DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
  TrailingDecorator: "Decorators must be attached to a class element.",
  SpreadElementDecorator: `Decorators can't be used with SpreadElement`
};
function generateParseDecorators(Parse, acornTypeScript, acorn) {
  const { tokTypes: tt } = acorn;
  const { tokTypes: tokTypes2 } = acornTypeScript;
  return class ParseDecorators extends Parse {
    takeDecorators(node) {
      const decorators = this.decoratorStack[this.decoratorStack.length - 1];
      if (decorators.length) {
        node.decorators = decorators;
        this.resetStartLocationFromNode(node, decorators[0]);
        this.decoratorStack[this.decoratorStack.length - 1] = [];
      }
    }
    parseDecorators(allowExport) {
      const currentContextDecorators = this.decoratorStack[this.decoratorStack.length - 1];
      while (this.match(tokTypes2.at)) {
        const decorator = this.parseDecorator();
        currentContextDecorators.push(decorator);
      }
      if (this.match(tt._export)) {
        if (!allowExport) {
          this.unexpected();
        }
      } else if (!this.canHaveLeadingDecorator()) {
        this.raise(this.start, DecoratorsError.UnexpectedLeadingDecorator);
      }
    }
    parseDecorator() {
      const node = this.startNode();
      this.next();
      this.decoratorStack.push([]);
      const startPos = this.start;
      const startLoc = this.startLoc;
      let expr;
      if (this.match(tt.parenL)) {
        const startPos2 = this.start;
        const startLoc2 = this.startLoc;
        this.next();
        expr = this.parseExpression();
        this.expect(tt.parenR);
        if (this.options.preserveParens) {
          let par2 = this.startNodeAt(startPos2, startLoc2);
          par2.expression = expr;
          expr = this.finishNode(par2, "ParenthesizedExpression");
        }
      } else {
        expr = this.parseIdent(false);
        while (this.eat(tt.dot)) {
          const node2 = this.startNodeAt(startPos, startLoc);
          node2.object = expr;
          node2.property = this.parseIdent(true);
          node2.computed = false;
          expr = this.finishNode(node2, "MemberExpression");
        }
      }
      node.expression = this.parseMaybeDecoratorArguments(expr);
      this.decoratorStack.pop();
      return this.finishNode(node, "Decorator");
    }
    parseMaybeDecoratorArguments(expr) {
      if (this.eat(tt.parenL)) {
        const node = this.startNodeAtNode(expr);
        node.callee = expr;
        node.arguments = this.parseExprList(tt.parenR, false);
        return this.finishNode(node, "CallExpression");
      }
      return expr;
    }
  };
}
var xhtml_default = {
  quot: '"',
  amp: "&",
  apos: "'",
  lt: "<",
  gt: ">",
  nbsp: "",
  iexcl: "",
  cent: "",
  pound: "",
  curren: "",
  yen: "",
  brvbar: "",
  sect: "",
  uml: "",
  copy: "",
  ordf: "",
  laquo: "",
  not: "",
  shy: "",
  reg: "",
  macr: "",
  deg: "",
  plusmn: "",
  sup2: "",
  sup3: "",
  acute: "",
  micro: "",
  para: "",
  middot: "",
  cedil: "",
  sup1: "",
  ordm: "",
  raquo: "",
  frac14: "",
  frac12: "",
  frac34: "",
  iquest: "",
  Agrave: "",
  Aacute: "",
  Acirc: "",
  Atilde: "",
  Auml: "",
  Aring: "",
  AElig: "",
  Ccedil: "",
  Egrave: "",
  Eacute: "",
  Ecirc: "",
  Euml: "",
  Igrave: "",
  Iacute: "",
  Icirc: "",
  Iuml: "",
  ETH: "",
  Ntilde: "",
  Ograve: "",
  Oacute: "",
  Ocirc: "",
  Otilde: "",
  Ouml: "",
  times: "",
  Oslash: "",
  Ugrave: "",
  Uacute: "",
  Ucirc: "",
  Uuml: "",
  Yacute: "",
  THORN: "",
  szlig: "",
  agrave: "",
  aacute: "",
  acirc: "",
  atilde: "",
  auml: "",
  aring: "",
  aelig: "",
  ccedil: "",
  egrave: "",
  eacute: "",
  ecirc: "",
  euml: "",
  igrave: "",
  iacute: "",
  icirc: "",
  iuml: "",
  eth: "",
  ntilde: "",
  ograve: "",
  oacute: "",
  ocirc: "",
  otilde: "",
  ouml: "",
  divide: "",
  oslash: "",
  ugrave: "",
  uacute: "",
  ucirc: "",
  uuml: "",
  yacute: "",
  thorn: "",
  yuml: "",
  OElig: "",
  oelig: "",
  Scaron: "",
  scaron: "",
  Yuml: "",
  fnof: "",
  circ: "",
  tilde: "",
  Alpha: "",
  Beta: "",
  Gamma: "",
  Delta: "",
  Epsilon: "",
  Zeta: "",
  Eta: "",
  Theta: "",
  Iota: "",
  Kappa: "",
  Lambda: "",
  Mu: "",
  Nu: "",
  Xi: "",
  Omicron: "",
  Pi: "",
  Rho: "",
  Sigma: "",
  Tau: "",
  Upsilon: "",
  Phi: "",
  Chi: "",
  Psi: "",
  Omega: "",
  alpha: "",
  beta: "",
  gamma: "",
  delta: "",
  epsilon: "",
  zeta: "",
  eta: "",
  theta: "",
  iota: "",
  kappa: "",
  lambda: "",
  mu: "",
  nu: "",
  xi: "",
  omicron: "",
  pi: "",
  rho: "",
  sigmaf: "",
  sigma: "",
  tau: "",
  upsilon: "",
  phi: "",
  chi: "",
  psi: "",
  omega: "",
  thetasym: "",
  upsih: "",
  piv: "",
  ensp: "",
  emsp: "",
  thinsp: "",
  zwnj: "",
  zwj: "",
  lrm: "",
  rlm: "",
  ndash: "",
  mdash: "",
  lsquo: "",
  rsquo: "",
  sbquo: "",
  ldquo: "",
  rdquo: "",
  bdquo: "",
  dagger: "",
  Dagger: "",
  bull: "",
  hellip: "",
  permil: "",
  prime: "",
  Prime: "",
  lsaquo: "",
  rsaquo: "",
  oline: "",
  frasl: "",
  euro: "",
  image: "",
  weierp: "",
  real: "",
  trade: "",
  alefsym: "",
  larr: "",
  uarr: "",
  rarr: "",
  darr: "",
  harr: "",
  crarr: "",
  lArr: "",
  uArr: "",
  rArr: "",
  dArr: "",
  hArr: "",
  forall: "",
  part: "",
  exist: "",
  empty: "",
  nabla: "",
  isin: "",
  notin: "",
  ni: "",
  prod: "",
  sum: "",
  minus: "",
  lowast: "",
  radic: "",
  prop: "",
  infin: "",
  ang: "",
  and: "",
  or: "",
  cap: "",
  cup: "",
  int: "",
  there4: "",
  sim: "",
  cong: "",
  asymp: "",
  ne: "",
  equiv: "",
  le: "",
  ge: "",
  sub: "",
  sup: "",
  nsub: "",
  sube: "",
  supe: "",
  oplus: "",
  otimes: "",
  perp: "",
  sdot: "",
  lceil: "",
  rceil: "",
  lfloor: "",
  rfloor: "",
  lang: "",
  rang: "",
  loz: "",
  spades: "",
  clubs: "",
  hearts: "",
  diams: ""
};
var hexNumber = /^[\da-fA-F]+$/;
var decimalNumber = /^\d+$/;
function getQualifiedJSXName(object4) {
  if (!object4) return object4;
  if (object4.type === "JSXIdentifier") return object4.name;
  if (object4.type === "JSXNamespacedName") return object4.namespace.name + ":" + object4.name.name;
  if (object4.type === "JSXMemberExpression")
    return getQualifiedJSXName(object4.object) + "." + getQualifiedJSXName(object4.property);
}
function generateJsxParser(acorn, acornTypeScript, Parser5, jsxOptions) {
  const tt = acorn.tokTypes;
  const tok = acornTypeScript.tokTypes;
  const isNewLine2 = acorn.isNewLine;
  const isIdentifierChar2 = acorn.isIdentifierChar;
  const options2 = Object.assign(
    {
      allowNamespaces: true,
      allowNamespacedObjects: true
    },
    jsxOptions || {}
  );
  return class JsxParser extends Parser5 {
    // Reads inline JSX contents token.
    jsx_readToken() {
      let out = "", chunkStart = this.pos;
      for (; ; ) {
        if (this.pos >= this.input.length) this.raise(this.start, "Unterminated JSX contents");
        let ch = this.input.charCodeAt(this.pos);
        switch (ch) {
          case 60:
          // '<'
          case 123:
            if (this.pos === this.start) {
              if (ch === 60 && this.exprAllowed) {
                ++this.pos;
                return this.finishToken(tok.jsxTagStart);
              }
              return this.getTokenFromCode(ch);
            }
            out += this.input.slice(chunkStart, this.pos);
            return this.finishToken(tok.jsxText, out);
          case 38:
            out += this.input.slice(chunkStart, this.pos);
            out += this.jsx_readEntity();
            chunkStart = this.pos;
            break;
          case 62:
          // '>'
          case 125:
            this.raise(
              this.pos,
              "Unexpected token `" + this.input[this.pos] + "`. Did you mean `" + (ch === 62 ? "&gt;" : "&rbrace;") + '` or `{"' + this.input[this.pos] + '"}`?'
            );
          default:
            if (isNewLine2(ch)) {
              out += this.input.slice(chunkStart, this.pos);
              out += this.jsx_readNewLine(true);
              chunkStart = this.pos;
            } else {
              ++this.pos;
            }
        }
      }
    }
    jsx_readNewLine(normalizeCRLF) {
      let ch = this.input.charCodeAt(this.pos);
      let out;
      ++this.pos;
      if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {
        ++this.pos;
        out = normalizeCRLF ? "\n" : "\r\n";
      } else {
        out = String.fromCharCode(ch);
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      return out;
    }
    jsx_readString(quote) {
      let out = "", chunkStart = ++this.pos;
      for (; ; ) {
        if (this.pos >= this.input.length) this.raise(this.start, "Unterminated string constant");
        let ch = this.input.charCodeAt(this.pos);
        if (ch === quote) break;
        if (ch === 38) {
          out += this.input.slice(chunkStart, this.pos);
          out += this.jsx_readEntity();
          chunkStart = this.pos;
        } else if (isNewLine2(ch)) {
          out += this.input.slice(chunkStart, this.pos);
          out += this.jsx_readNewLine(false);
          chunkStart = this.pos;
        } else {
          ++this.pos;
        }
      }
      out += this.input.slice(chunkStart, this.pos++);
      return this.finishToken(tt.string, out);
    }
    jsx_readEntity() {
      let str2 = "", count = 0, entity;
      let ch = this.input[this.pos];
      if (ch !== "&") this.raise(this.pos, "Entity must start with an ampersand");
      let startPos = ++this.pos;
      while (this.pos < this.input.length && count++ < 10) {
        ch = this.input[this.pos++];
        if (ch === ";") {
          if (str2[0] === "#") {
            if (str2[1] === "x") {
              str2 = str2.substr(2);
              if (hexNumber.test(str2)) entity = String.fromCharCode(parseInt(str2, 16));
            } else {
              str2 = str2.substr(1);
              if (decimalNumber.test(str2)) entity = String.fromCharCode(parseInt(str2, 10));
            }
          } else {
            entity = xhtml_default[str2];
          }
          break;
        }
        str2 += ch;
      }
      if (!entity) {
        this.pos = startPos;
        return "&";
      }
      return entity;
    }
    // Read a JSX identifier (valid tag or attribute name).
    //
    // Optimized version since JSX identifiers can't contain
    // escape characters and so can be read as single slice.
    // Also assumes that first character was already checked
    // by isIdentifierStart in readToken.
    jsx_readWord() {
      let ch, start2 = this.pos;
      do {
        ch = this.input.charCodeAt(++this.pos);
      } while (isIdentifierChar2(ch) || ch === 45);
      return this.finishToken(tok.jsxName, this.input.slice(start2, this.pos));
    }
    // Parse next token as JSX identifier
    jsx_parseIdentifier() {
      let node = this.startNode();
      if (this.type === tok.jsxName) node.name = this.value;
      else if (this.type.keyword) node.name = this.type.keyword;
      else this.unexpected();
      this.next();
      return this.finishNode(node, "JSXIdentifier");
    }
    // Parse namespaced identifier.
    jsx_parseNamespacedName() {
      let startPos = this.start, startLoc = this.startLoc;
      let name2 = this.jsx_parseIdentifier();
      if (!options2.allowNamespaces || !this.eat(tt.colon)) return name2;
      var node = this.startNodeAt(startPos, startLoc);
      node.namespace = name2;
      node.name = this.jsx_parseIdentifier();
      return this.finishNode(node, "JSXNamespacedName");
    }
    // Parses element name in any form - namespaced, member
    // or single identifier.
    jsx_parseElementName() {
      if (this.type === tok.jsxTagEnd) return "";
      let startPos = this.start, startLoc = this.startLoc;
      let node = this.jsx_parseNamespacedName();
      if (this.type === tt.dot && node.type === "JSXNamespacedName" && !options2.allowNamespacedObjects) {
        this.unexpected();
      }
      while (this.eat(tt.dot)) {
        let newNode = this.startNodeAt(startPos, startLoc);
        newNode.object = node;
        newNode.property = this.jsx_parseIdentifier();
        node = this.finishNode(newNode, "JSXMemberExpression");
      }
      return node;
    }
    // Parses any type of JSX attribute value.
    jsx_parseAttributeValue() {
      switch (this.type) {
        case tt.braceL:
          let node = this.jsx_parseExpressionContainer();
          if (node.expression.type === "JSXEmptyExpression")
            this.raise(node.start, "JSX attributes must only be assigned a non-empty expression");
          return node;
        case tok.jsxTagStart:
        case tt.string:
          return this.parseExprAtom();
        default:
          this.raise(this.start, "JSX value should be either an expression or a quoted JSX text");
      }
    }
    // JSXEmptyExpression is unique type since it doesn't actually parse anything,
    // and so it should start at the end of last read token (left brace) and finish
    // at the beginning of the next one (right brace).
    jsx_parseEmptyExpression() {
      let node = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);
      return this.finishNodeAt(node, "JSXEmptyExpression", this.start, this.startLoc);
    }
    // Parses JSX expression enclosed into curly brackets.
    jsx_parseExpressionContainer() {
      let node = this.startNode();
      this.next();
      node.expression = this.type === tt.braceR ? this.jsx_parseEmptyExpression() : this.parseExpression();
      this.expect(tt.braceR);
      return this.finishNode(node, "JSXExpressionContainer");
    }
    // Parses following JSX attribute name-value pair.
    jsx_parseAttribute() {
      let node = this.startNode();
      if (this.eat(tt.braceL)) {
        this.expect(tt.ellipsis);
        node.argument = this.parseMaybeAssign();
        this.expect(tt.braceR);
        return this.finishNode(node, "JSXSpreadAttribute");
      }
      node.name = this.jsx_parseNamespacedName();
      node.value = this.eat(tt.eq) ? this.jsx_parseAttributeValue() : null;
      return this.finishNode(node, "JSXAttribute");
    }
    // Parses JSX opening tag starting after '<'.
    jsx_parseOpeningElementAt(startPos, startLoc) {
      let node = this.startNodeAt(startPos, startLoc);
      node.attributes = [];
      let nodeName = this.jsx_parseElementName();
      if (nodeName) node.name = nodeName;
      while (this.type !== tt.slash && this.type !== tok.jsxTagEnd)
        node.attributes.push(this.jsx_parseAttribute());
      node.selfClosing = this.eat(tt.slash);
      this.expect(tok.jsxTagEnd);
      return this.finishNode(node, nodeName ? "JSXOpeningElement" : "JSXOpeningFragment");
    }
    // Parses JSX closing tag starting after '</'.
    jsx_parseClosingElementAt(startPos, startLoc) {
      let node = this.startNodeAt(startPos, startLoc);
      let nodeName = this.jsx_parseElementName();
      if (nodeName) node.name = nodeName;
      this.expect(tok.jsxTagEnd);
      return this.finishNode(node, nodeName ? "JSXClosingElement" : "JSXClosingFragment");
    }
    // Parses entire JSX element, including it's opening tag
    // (starting after '<'), attributes, contents and closing tag.
    jsx_parseElementAt(startPos, startLoc) {
      let node = this.startNodeAt(startPos, startLoc);
      let children = [];
      let openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);
      let closingElement = null;
      if (!openingElement.selfClosing) {
        contents: for (; ; ) {
          switch (this.type) {
            case tok.jsxTagStart:
              startPos = this.start;
              startLoc = this.startLoc;
              this.next();
              if (this.eat(tt.slash)) {
                closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);
                break contents;
              }
              children.push(this.jsx_parseElementAt(startPos, startLoc));
              break;
            case tok.jsxText:
              children.push(this.parseExprAtom());
              break;
            case tt.braceL:
              children.push(this.jsx_parseExpressionContainer());
              break;
            default:
              this.unexpected();
          }
        }
        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
          this.raise(
            closingElement.start,
            "Expected corresponding JSX closing tag for <" + getQualifiedJSXName(openingElement.name) + ">"
          );
        }
      }
      let fragmentOrElement = openingElement.name ? "Element" : "Fragment";
      node["opening" + fragmentOrElement] = openingElement;
      node["closing" + fragmentOrElement] = closingElement;
      node.children = children;
      if (this.type === tt.relational && this.value === "<") {
        this.raise(this.start, "Adjacent JSX elements must be wrapped in an enclosing tag");
      }
      return this.finishNode(node, "JSX" + fragmentOrElement);
    }
    // Parse JSX text
    jsx_parseText() {
      let node = this.parseLiteral(this.value);
      node.type = "JSXText";
      return node;
    }
    // Parses entire JSX element from current position.
    jsx_parseElement() {
      let startPos = this.start, startLoc = this.startLoc;
      this.next();
      return this.jsx_parseElementAt(startPos, startLoc);
    }
  };
}
function generateParseImportAssertions(Parse, acornTypeScript, acorn) {
  const { tokTypes: tokTypes2 } = acornTypeScript;
  const { tokTypes: tt } = acorn;
  return class ImportAttributes extends Parse {
    parseMaybeImportAttributes(node) {
      if (this.type === tt._with || this.type === tokTypes2.assert) {
        this.next();
        const attributes = this.parseImportAttributes();
        if (attributes) {
          node.attributes = attributes;
        }
      }
    }
    parseImportAttributes() {
      this.expect(tt.braceL);
      const attrs2 = this.parseWithEntries();
      this.expect(tt.braceR);
      return attrs2;
    }
    parseWithEntries() {
      const attrs2 = [];
      const attrNames = /* @__PURE__ */ new Set();
      do {
        if (this.type === tt.braceR) {
          break;
        }
        const node = this.startNode();
        let withionKeyNode;
        if (this.type === tt.string) {
          withionKeyNode = this.parseLiteral(this.value);
        } else {
          withionKeyNode = this.parseIdent(true);
        }
        this.next();
        node.key = withionKeyNode;
        if (attrNames.has(node.key.name)) {
          this.raise(this.pos, "Duplicated key in attributes");
        }
        attrNames.add(node.key.name);
        if (this.type !== tt.string) {
          this.raise(this.pos, "Only string is supported as an attribute value");
        }
        node.value = this.parseLiteral(this.value);
        attrs2.push(this.finishNode(node, "ImportAttribute"));
      } while (this.eat(tt.comma));
      return attrs2;
    }
  };
}
var skipWhiteSpace2 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
function assert(x) {
  if (!x) {
    throw new Error("Assert fail");
  }
}
function tsIsClassAccessor(modifier) {
  return modifier === "accessor";
}
function tsIsVarianceAnnotations(modifier) {
  return modifier === "in" || modifier === "out";
}
var FUNC_STATEMENT2 = 1;
var FUNC_HANGING_STATEMENT2 = 2;
var FUNC_NULLABLE_ID2 = 4;
var acornScope = {
  SCOPE_TOP: 1,
  SCOPE_FUNCTION: 2,
  SCOPE_ASYNC: 4,
  SCOPE_GENERATOR: 8,
  SCOPE_ARROW: 16,
  SCOPE_SIMPLE_CATCH: 32,
  SCOPE_SUPER: 64,
  SCOPE_DIRECT_SUPER: 128,
  SCOPE_CLASS_STATIC_BLOCK: 256,
  SCOPE_VAR: 256,
  BIND_NONE: 0,
  // Not a binding
  BIND_VAR: 1,
  // Var-style binding
  BIND_LEXICAL: 2,
  // Let- or const-style binding
  BIND_FUNCTION: 3,
  // Function declaration
  BIND_SIMPLE_CATCH: 4,
  // Simple (identifier pattern) catch binding
  BIND_OUTSIDE: 5,
  // Special case for function names as bound inside the
  BIND_TS_TYPE: 6,
  BIND_TS_INTERFACE: 7,
  BIND_TS_NAMESPACE: 8,
  BIND_FLAGS_TS_EXPORT_ONLY: 1024,
  BIND_FLAGS_TS_IMPORT: 4096,
  BIND_FLAGS_TS_ENUM: 256,
  BIND_FLAGS_TS_CONST_ENUM: 512,
  BIND_FLAGS_CLASS: 128
  // function
};
function functionFlags2(async, generator) {
  return acornScope.SCOPE_FUNCTION | (async ? acornScope.SCOPE_ASYNC : 0) | (generator ? acornScope.SCOPE_GENERATOR : 0);
}
function isPossiblyLiteralEnum(expression) {
  if (expression.type !== "MemberExpression") return false;
  const { computed, property } = expression;
  if (computed && (property.type !== "TemplateLiteral" || property.expressions.length > 0)) {
    return false;
  }
  return isUncomputedMemberExpressionChain(expression.object);
}
function isUncomputedMemberExpressionChain(expression) {
  if (expression.type === "Identifier") return true;
  if (expression.type !== "MemberExpression") return false;
  if (expression.computed) return false;
  return isUncomputedMemberExpressionChain(expression.object);
}
function tsIsAccessModifier(modifier) {
  return modifier === "private" || modifier === "public" || modifier === "protected";
}
function tokenCanStartExpression(token) {
  return Boolean(token.startsExpr);
}
function nonNull(x) {
  if (x == null) {
    throw new Error(`Unexpected ${x} value.`);
  }
  return x;
}
function keywordTypeFromName(value) {
  switch (value) {
    case "any":
      return "TSAnyKeyword";
    case "boolean":
      return "TSBooleanKeyword";
    case "bigint":
      return "TSBigIntKeyword";
    case "never":
      return "TSNeverKeyword";
    case "number":
      return "TSNumberKeyword";
    case "object":
      return "TSObjectKeyword";
    case "string":
      return "TSStringKeyword";
    case "symbol":
      return "TSSymbolKeyword";
    case "undefined":
      return "TSUndefinedKeyword";
    case "unknown":
      return "TSUnknownKeyword";
    default:
      return void 0;
  }
}
function tsPlugin(options2) {
  const { dts = false } = options2 || {};
  const disallowAmbiguousJSXLike = !!options2?.jsx;
  return function(Parser5) {
    const _acorn = Parser5.acorn || acorn_exports;
    const acornTypeScript = generateAcornTypeScript(_acorn);
    const tt = _acorn.tokTypes;
    const keywordTypes2 = _acorn.keywordTypes;
    const isIdentifierStart2 = _acorn.isIdentifierStart;
    const lineBreak2 = _acorn.lineBreak;
    const isNewLine2 = _acorn.isNewLine;
    const tokContexts = _acorn.tokContexts;
    const isIdentifierChar2 = _acorn.isIdentifierChar;
    const {
      tokTypes: tokTypes2,
      tokContexts: tsTokContexts,
      keywordsRegExp,
      tokenIsLiteralPropertyName,
      tokenIsTemplate,
      tokenIsTSDeclarationStart,
      tokenIsIdentifier,
      tokenIsKeywordOrIdentifier,
      tokenIsTSTypeOperator
    } = acornTypeScript;
    function nextLineBreak2(code2, from, end2 = code2.length) {
      for (let i = from; i < end2; i++) {
        let next2 = code2.charCodeAt(i);
        if (isNewLine2(next2))
          return i < end2 - 1 && next2 === 13 && code2.charCodeAt(i + 1) === 10 ? i + 2 : i + 1;
      }
      return -1;
    }
    Parser5 = generateParseDecorators(Parser5, acornTypeScript, _acorn);
    if (options2?.jsx) {
      Parser5 = generateJsxParser(
        _acorn,
        acornTypeScript,
        Parser5,
        typeof options2.jsx === "boolean" ? {} : options2.jsx
      );
    }
    Parser5 = generateParseImportAssertions(Parser5, acornTypeScript, _acorn);
    class TypeScriptParser extends Parser5 {
      constructor(options22, input, startPos) {
        super(options22, input, startPos);
        this.preValue = null;
        this.preToken = null;
        this.isLookahead = false;
        this.isAmbientContext = false;
        this.inAbstractClass = false;
        this.inType = false;
        this.inDisallowConditionalTypesContext = false;
        this.maybeInArrowParameters = false;
        this.shouldParseArrowReturnType = void 0;
        this.shouldParseAsyncArrowReturnType = void 0;
        this.decoratorStack = [[]];
        this.importsStack = [[]];
        this.importOrExportOuterKind = void 0;
        this.tsParseConstModifier = (node) => {
          this.tsParseModifiers({
            modified: node,
            allowedModifiers: ["const"],
            // for better error recovery
            disallowedModifiers: ["in", "out"],
            errorTemplate: TypeScriptError.InvalidModifierOnTypeParameterPositions
          });
        };
        this.ecmaVersion = this.options.ecmaVersion;
      }
      // support in Class static
      static get acornTypeScript() {
        return acornTypeScript;
      }
      // support in runtime, get acornTypeScript be this
      get acornTypeScript() {
        return acornTypeScript;
      }
      getTokenFromCodeInType(code2) {
        if (code2 === 62) {
          return this.finishOp(tt.relational, 1);
        }
        if (code2 === 60) {
          return this.finishOp(tt.relational, 1);
        }
        return super.getTokenFromCode(code2);
      }
      readToken(code2) {
        if (!this.inType) {
          let context2 = this.curContext();
          if (context2 === tsTokContexts.tc_expr) return this.jsx_readToken();
          if (context2 === tsTokContexts.tc_oTag || context2 === tsTokContexts.tc_cTag) {
            if (isIdentifierStart2(code2)) return this.jsx_readWord();
            if (code2 == 62) {
              ++this.pos;
              return this.finishToken(tokTypes2.jsxTagEnd);
            }
            if ((code2 === 34 || code2 === 39) && context2 == tsTokContexts.tc_oTag)
              return this.jsx_readString(code2);
          }
          if (code2 === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33) {
            ++this.pos;
            if (options2?.jsx) {
              return this.finishToken(tokTypes2.jsxTagStart);
            } else {
              return this.finishToken(tt.relational, "<");
            }
          }
        }
        return super.readToken(code2);
      }
      getTokenFromCode(code2) {
        if (this.inType) {
          return this.getTokenFromCodeInType(code2);
        }
        if (code2 === 64) {
          ++this.pos;
          return this.finishToken(tokTypes2.at);
        }
        return super.getTokenFromCode(code2);
      }
      isAbstractClass() {
        return this.ts_isContextual(tokTypes2.abstract) && this.lookahead().type === tt._class;
      }
      finishNode(node, type2) {
        if (node.type !== "" && node.end !== 0) {
          return node;
        }
        return super.finishNode(node, type2);
      }
      // tryParse will clone parser state.
      // It is expensive and should be used with cautions
      tryParse(fn, oldState = this.cloneCurLookaheadState()) {
        const abortSignal = { node: null };
        try {
          const node = fn((node2 = null) => {
            abortSignal.node = node2;
            throw abortSignal;
          });
          return {
            node,
            error: null,
            thrown: false,
            aborted: false,
            failState: null
          };
        } catch (error) {
          const failState = this.getCurLookaheadState();
          this.setLookaheadState(oldState);
          if (error instanceof SyntaxError) {
            return {
              node: null,
              error,
              thrown: true,
              aborted: false,
              failState
            };
          }
          if (error === abortSignal) {
            return {
              node: abortSignal.node,
              error: null,
              thrown: false,
              aborted: true,
              failState
            };
          }
          throw error;
        }
      }
      setOptionalParametersError(refExpressionErrors, resultError) {
        refExpressionErrors.optionalParametersLoc = resultError?.loc ?? this.startLoc;
      }
      // used after we have finished parsing types
      reScan_lt_gt() {
        if (this.type === tt.relational) {
          this.pos -= 1;
          this.readToken_lt_gt(this.fullCharCodeAtPos());
        }
      }
      reScan_lt() {
        const { type: type2 } = this;
        if (type2 === tt.bitShift) {
          this.pos -= 2;
          this.finishOp(tt.relational, 1);
          return tt.relational;
        }
        return type2;
      }
      resetEndLocation(node, endPos = this.lastTokEnd, endLoc = this.lastTokEndLoc) {
        node.end = endPos;
        node.loc.end = endLoc;
        if (this.options.ranges) node.range[1] = endPos;
      }
      startNodeAtNode(type2) {
        return super.startNodeAt(type2.start, type2.loc.start);
      }
      nextTokenStart() {
        return this.nextTokenStartSince(this.pos);
      }
      tsHasSomeModifiers(member2, modifiers) {
        return modifiers.some((modifier) => {
          if (tsIsAccessModifier(modifier)) {
            return member2.accessibility === modifier;
          }
          return !!member2[modifier];
        });
      }
      tsIsStartOfStaticBlocks() {
        return this.isContextual("static") && this.lookaheadCharCode() === 123;
      }
      tsCheckForInvalidTypeCasts(items) {
        items.forEach((node) => {
          if (node?.type === "TSTypeCastExpression") {
            this.raise(node.typeAnnotation.start, TypeScriptError.UnexpectedTypeAnnotation);
          }
        });
      }
      atPossibleAsyncArrow(base) {
        return base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.potentialArrowAt;
      }
      tsIsIdentifier() {
        return tokenIsIdentifier(this.type);
      }
      tsTryParseTypeOrTypePredicateAnnotation() {
        return this.match(tt.colon) ? this.tsParseTypeOrTypePredicateAnnotation(tt.colon) : void 0;
      }
      tsTryParseGenericAsyncArrowFunction(startPos, startLoc, forInit) {
        if (!this.tsMatchLeftRelational()) {
          return void 0;
        }
        const oldMaybeInArrowParameters = this.maybeInArrowParameters;
        this.maybeInArrowParameters = true;
        const res2 = this.tsTryParseAndCatch(() => {
          const node = this.startNodeAt(startPos, startLoc);
          node.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
          super.parseFunctionParams(node);
          node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
          this.expect(tt.arrow);
          return node;
        });
        this.maybeInArrowParameters = oldMaybeInArrowParameters;
        if (!res2) {
          return void 0;
        }
        return super.parseArrowExpression(
          res2,
          /* params are already set */
          null,
          /* async */
          true,
          /* forInit */
          forInit
        );
      }
      // Used when parsing type arguments from ES productions, where the first token
      // has been created without state.inType. Thus we need to rescan the lt token.
      tsParseTypeArgumentsInExpression() {
        if (this.reScan_lt() !== tt.relational) {
          return void 0;
        }
        return this.tsParseTypeArguments();
      }
      tsInNoContext(cb) {
        const oldContext = this.context;
        this.context = [oldContext[0]];
        try {
          return cb();
        } finally {
          this.context = oldContext;
        }
      }
      tsTryParseTypeAnnotation() {
        return this.match(tt.colon) ? this.tsParseTypeAnnotation() : void 0;
      }
      isUnparsedContextual(nameStart, name2) {
        const nameEnd = nameStart + name2.length;
        if (this.input.slice(nameStart, nameEnd) === name2) {
          const nextCh = this.input.charCodeAt(nameEnd);
          return !(isIdentifierChar2(nextCh) || // check if `nextCh is between 0xd800 - 0xdbff,
          // if `nextCh` is NaN, `NaN & 0xfc00` is 0, the function
          // returns true
          (nextCh & 64512) === 55296);
        }
        return false;
      }
      isAbstractConstructorSignature() {
        return this.ts_isContextual(tokTypes2.abstract) && this.lookahead().type === tt._new;
      }
      nextTokenStartSince(pos) {
        skipWhiteSpace2.lastIndex = pos;
        return skipWhiteSpace2.test(this.input) ? skipWhiteSpace2.lastIndex : pos;
      }
      lookaheadCharCode() {
        return this.input.charCodeAt(this.nextTokenStart());
      }
      compareLookaheadState(state, state2) {
        for (const key2 of Object.keys(state)) {
          if (state[key2] !== state2[key2]) return false;
        }
        return true;
      }
      createLookaheadState() {
        this.value = null;
        this.context = [this.curContext()];
      }
      getCurLookaheadState() {
        return {
          endLoc: this.endLoc,
          lastTokEnd: this.lastTokEnd,
          lastTokStart: this.lastTokStart,
          lastTokStartLoc: this.lastTokStartLoc,
          pos: this.pos,
          value: this.value,
          type: this.type,
          start: this.start,
          end: this.end,
          context: this.context,
          startLoc: this.startLoc,
          lastTokEndLoc: this.lastTokEndLoc,
          curLine: this.curLine,
          lineStart: this.lineStart,
          curPosition: this.curPosition,
          containsEsc: this.containsEsc
        };
      }
      cloneCurLookaheadState() {
        return {
          pos: this.pos,
          value: this.value,
          type: this.type,
          start: this.start,
          end: this.end,
          context: this.context && this.context.slice(),
          startLoc: this.startLoc,
          lastTokEndLoc: this.lastTokEndLoc,
          endLoc: this.endLoc,
          lastTokEnd: this.lastTokEnd,
          lastTokStart: this.lastTokStart,
          lastTokStartLoc: this.lastTokStartLoc,
          curLine: this.curLine,
          lineStart: this.lineStart,
          curPosition: this.curPosition,
          containsEsc: this.containsEsc
        };
      }
      setLookaheadState(state) {
        this.pos = state.pos;
        this.value = state.value;
        this.endLoc = state.endLoc;
        this.lastTokEnd = state.lastTokEnd;
        this.lastTokStart = state.lastTokStart;
        this.lastTokStartLoc = state.lastTokStartLoc;
        this.type = state.type;
        this.start = state.start;
        this.end = state.end;
        this.context = state.context;
        this.startLoc = state.startLoc;
        this.lastTokEndLoc = state.lastTokEndLoc;
        this.curLine = state.curLine;
        this.lineStart = state.lineStart;
        this.curPosition = state.curPosition;
        this.containsEsc = state.containsEsc;
      }
      // Utilities
      tsLookAhead(f) {
        const state = this.getCurLookaheadState();
        const res2 = f();
        this.setLookaheadState(state);
        return res2;
      }
      lookahead(number2) {
        const oldState = this.getCurLookaheadState();
        this.createLookaheadState();
        this.isLookahead = true;
        if (number2 !== void 0) {
          for (let i = 0; i < number2; i++) {
            this.nextToken();
          }
        } else {
          this.nextToken();
        }
        this.isLookahead = false;
        const curState = this.getCurLookaheadState();
        this.setLookaheadState(oldState);
        return curState;
      }
      readWord() {
        let word2 = this.readWord1();
        let type2 = tt.name;
        if (this.keywords.test(word2)) {
          type2 = keywordTypes2[word2];
        } else if (new RegExp(keywordsRegExp).test(word2)) {
          type2 = tokTypes2[word2];
        }
        return this.finishToken(type2, word2);
      }
      skipBlockComment() {
        let startLoc;
        if (!this.isLookahead) startLoc = this.options.onComment && this.curPosition();
        let start2 = this.pos, end2 = this.input.indexOf("*/", this.pos += 2);
        if (end2 === -1) this.raise(this.pos - 2, "Unterminated comment");
        this.pos = end2 + 2;
        if (this.options.locations) {
          for (let nextBreak, pos = start2; (nextBreak = nextLineBreak2(this.input, pos, this.pos)) > -1; ) {
            ++this.curLine;
            pos = this.lineStart = nextBreak;
          }
        }
        if (this.isLookahead) return;
        if (this.options.onComment) {
          this.options.onComment(
            true,
            this.input.slice(start2 + 2, end2),
            start2,
            this.pos,
            startLoc,
            this.curPosition()
          );
        }
      }
      skipLineComment(startSkip) {
        let start2 = this.pos;
        let startLoc;
        if (!this.isLookahead) startLoc = this.options.onComment && this.curPosition();
        let ch = this.input.charCodeAt(this.pos += startSkip);
        while (this.pos < this.input.length && !isNewLine2(ch)) {
          ch = this.input.charCodeAt(++this.pos);
        }
        if (this.isLookahead) return;
        if (this.options.onComment)
          this.options.onComment(
            false,
            this.input.slice(start2 + startSkip, this.pos),
            start2,
            this.pos,
            startLoc,
            this.curPosition()
          );
      }
      finishToken(type2, val) {
        this.preValue = this.value;
        this.preToken = this.type;
        this.end = this.pos;
        if (this.options.locations) this.endLoc = this.curPosition();
        let prevType = this.type;
        this.type = type2;
        this.value = val;
        if (!this.isLookahead) {
          this.updateContext(prevType);
        }
      }
      resetStartLocation(node, start2, startLoc) {
        node.start = start2;
        node.loc.start = startLoc;
        if (this.options.ranges) node.range[0] = start2;
      }
      isLineTerminator() {
        return this.eat(tt.semi) || super.canInsertSemicolon();
      }
      hasFollowingLineBreak() {
        skipWhiteSpaceToLineBreak.lastIndex = this.end;
        return skipWhiteSpaceToLineBreak.test(this.input);
      }
      addExtra(node, key2, value, enumerable = true) {
        if (!node) return;
        const extra = node.extra = node.extra || {};
        if (enumerable) {
          extra[key2] = value;
        } else {
          Object.defineProperty(extra, key2, { enumerable, value });
        }
      }
      /**
       * Test if current token is a literal property name
       * https://tc39.es/ecma262/#prod-LiteralPropertyName
       * LiteralPropertyName:
       *   IdentifierName
       *   StringLiteral
       *   NumericLiteral
       *   BigIntLiteral
       */
      isLiteralPropertyName() {
        return tokenIsLiteralPropertyName(this.type);
      }
      hasPrecedingLineBreak() {
        return lineBreak2.test(this.input.slice(this.lastTokEnd, this.start));
      }
      createIdentifier(node, name2) {
        node.name = name2;
        return this.finishNode(node, "Identifier");
      }
      /**
       * Reset the start location of node to the start location of locationNode
       */
      resetStartLocationFromNode(node, locationNode) {
        this.resetStartLocation(node, locationNode.start, locationNode.loc.start);
      }
      // This is used in flow and typescript plugin
      // Determine whether a parameter is a this param
      isThisParam(param) {
        return param.type === "Identifier" && param.name === "this";
      }
      isLookaheadContextual(name2) {
        const next2 = this.nextTokenStart();
        return this.isUnparsedContextual(next2, name2);
      }
      /**
       * ts type isContextual
       * @param {TokenType} type
       * @param {TokenType} token
       * @returns {boolean}
       * */
      ts_type_isContextual(type2, token) {
        return type2 === token && !this.containsEsc;
      }
      /**
       * ts isContextual
       * @param {TokenType} token
       * @returns {boolean}
       * */
      ts_isContextual(token) {
        return this.type === token && !this.containsEsc;
      }
      ts_isContextualWithState(state, token) {
        return state.type === token && !state.containsEsc;
      }
      isContextualWithState(keyword, state) {
        return state.type === tt.name && state.value === keyword && !state.containsEsc;
      }
      tsIsStartOfMappedType() {
        this.next();
        if (this.eat(tt.plusMin)) {
          return this.ts_isContextual(tokTypes2.readonly);
        }
        if (this.ts_isContextual(tokTypes2.readonly)) {
          this.next();
        }
        if (!this.match(tt.bracketL)) {
          return false;
        }
        this.next();
        if (!this.tsIsIdentifier()) {
          return false;
        }
        this.next();
        return this.match(tt._in);
      }
      tsInDisallowConditionalTypesContext(cb) {
        const oldInDisallowConditionalTypesContext = this.inDisallowConditionalTypesContext;
        this.inDisallowConditionalTypesContext = true;
        try {
          return cb();
        } finally {
          this.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
        }
      }
      tsTryParseType() {
        return this.tsEatThenParseType(tt.colon);
      }
      /**
       * Whether current token matches given type
       *
       * @param {TokenType} type
       * @returns {boolean}
       * @memberof Tokenizer
       */
      match(type2) {
        return this.type === type2;
      }
      matchJsx(type2) {
        return this.type === acornTypeScript.tokTypes[type2];
      }
      ts_eatWithState(type2, nextCount, state) {
        const targetType = state.type;
        if (type2 === targetType) {
          for (let i = 0; i < nextCount; i++) {
            this.next();
          }
          return true;
        } else {
          return false;
        }
      }
      ts_eatContextualWithState(name2, nextCount, state) {
        if (keywordsRegExp.test(name2)) {
          if (this.ts_isContextualWithState(state, tokTypes2[name2])) {
            for (let i = 0; i < nextCount; i++) {
              this.next();
            }
            return true;
          }
          return false;
        } else {
          if (!this.isContextualWithState(name2, state)) return false;
          for (let i = 0; i < nextCount; i++) {
            this.next();
          }
          return true;
        }
      }
      canHaveLeadingDecorator() {
        return this.match(tt._class);
      }
      eatContextual(name2) {
        if (keywordsRegExp.test(name2)) {
          if (this.ts_isContextual(tokTypes2[name2])) {
            this.next();
            return true;
          }
          return false;
        } else {
          return super.eatContextual(name2);
        }
      }
      tsIsExternalModuleReference() {
        return this.isContextual("require") && this.lookaheadCharCode() === 40;
      }
      tsParseExternalModuleReference() {
        const node = this.startNode();
        this.expectContextual("require");
        this.expect(tt.parenL);
        if (!this.match(tt.string)) {
          this.unexpected();
        }
        node.expression = this.parseExprAtom();
        this.expect(tt.parenR);
        return this.finishNode(node, "TSExternalModuleReference");
      }
      tsParseEntityName(allowReservedWords = true) {
        let entity = this.parseIdent(allowReservedWords);
        while (this.eat(tt.dot)) {
          const node = this.startNodeAtNode(entity);
          node.left = entity;
          node.right = this.parseIdent(allowReservedWords);
          entity = this.finishNode(node, "TSQualifiedName");
        }
        return entity;
      }
      tsParseEnumMember() {
        const node = this.startNode();
        node.id = this.match(tt.string) ? this.parseLiteral(this.value) : this.parseIdent(
          /* liberal */
          true
        );
        if (this.eat(tt.eq)) {
          node.initializer = this.parseMaybeAssign();
        }
        return this.finishNode(node, "TSEnumMember");
      }
      tsParseEnumDeclaration(node, properties = {}) {
        if (properties.const) node.const = true;
        if (properties.declare) node.declare = true;
        this.expectContextual("enum");
        node.id = this.parseIdent();
        this.checkLValSimple(node.id);
        this.expect(tt.braceL);
        node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
        this.expect(tt.braceR);
        return this.finishNode(node, "TSEnumDeclaration");
      }
      tsParseModuleBlock() {
        const node = this.startNode();
        this.enterScope(TS_SCOPE_OTHER);
        this.expect(tt.braceL);
        node.body = [];
        while (this.type !== tt.braceR) {
          let stmt2 = this.parseStatement(null, true);
          node.body.push(stmt2);
        }
        this.next();
        super.exitScope();
        return this.finishNode(node, "TSModuleBlock");
      }
      tsParseAmbientExternalModuleDeclaration(node) {
        if (this.ts_isContextual(tokTypes2.global)) {
          node.global = true;
          node.id = this.parseIdent();
        } else if (this.match(tt.string)) {
          node.id = this.parseLiteral(this.value);
        } else {
          this.unexpected();
        }
        if (this.match(tt.braceL)) {
          this.enterScope(TS_SCOPE_TS_MODULE);
          node.body = this.tsParseModuleBlock();
          super.exitScope();
        } else {
          super.semicolon();
        }
        return this.finishNode(node, "TSModuleDeclaration");
      }
      tsTryParseDeclare(nany) {
        if (this.isLineTerminator()) {
          return;
        }
        let starttype = this.type;
        let kind;
        if (this.isContextual("let")) {
          starttype = tt._var;
          kind = "let";
        }
        return this.tsInAmbientContext(() => {
          if (starttype === tt._function) {
            nany.declare = true;
            return this.parseFunctionStatement(
              nany,
              /* async */
              false,
              /* declarationPosition */
              true
            );
          }
          if (starttype === tt._class) {
            nany.declare = true;
            return this.parseClass(nany, true);
          }
          if (starttype === tokTypes2.enum) {
            return this.tsParseEnumDeclaration(nany, { declare: true });
          }
          if (starttype === tokTypes2.global) {
            return this.tsParseAmbientExternalModuleDeclaration(nany);
          }
          if (starttype === tt._const || starttype === tt._var) {
            if (!this.match(tt._const) || !this.isLookaheadContextual("enum")) {
              nany.declare = true;
              return this.parseVarStatement(nany, kind || this.value, true);
            }
            this.expect(tt._const);
            return this.tsParseEnumDeclaration(nany, {
              const: true,
              declare: true
            });
          }
          if (starttype === tokTypes2.interface) {
            const result = this.tsParseInterfaceDeclaration(nany, {
              declare: true
            });
            if (result) return result;
          }
          if (tokenIsIdentifier(starttype)) {
            return this.tsParseDeclaration(
              nany,
              this.value,
              /* next */
              true
            );
          }
        });
      }
      tsIsListTerminator(kind) {
        switch (kind) {
          case "EnumMembers":
          case "TypeMembers":
            return this.match(tt.braceR);
          case "HeritageClauseElement":
            return this.match(tt.braceL);
          case "TupleElementTypes":
            return this.match(tt.bracketR);
          case "TypeParametersOrArguments":
            return this.tsMatchRightRelational();
        }
      }
      /**
       * If !expectSuccess, returns undefined instead of failing to parse.
       * If expectSuccess, parseElement should always return a defined value.
       */
      tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
        const result = [];
        let trailingCommaPos = -1;
        for (; ; ) {
          if (this.tsIsListTerminator(kind)) {
            break;
          }
          trailingCommaPos = -1;
          const element3 = parseElement();
          if (element3 == null) {
            return void 0;
          }
          result.push(element3);
          if (this.eat(tt.comma)) {
            trailingCommaPos = this.lastTokStart;
            continue;
          }
          if (this.tsIsListTerminator(kind)) {
            break;
          }
          if (expectSuccess) {
            this.expect(tt.comma);
          }
          return void 0;
        }
        if (refTrailingCommaPos) {
          refTrailingCommaPos.value = trailingCommaPos;
        }
        return result;
      }
      tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
        return nonNull(
          this.tsParseDelimitedListWorker(
            kind,
            parseElement,
            /* expectSuccess */
            true,
            refTrailingCommaPos
          )
        );
      }
      tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
        if (!skipFirstToken) {
          if (bracket) {
            this.expect(tt.bracketL);
          } else {
            this.expect(tt.relational);
          }
        }
        const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);
        if (bracket) {
          this.expect(tt.bracketR);
        } else {
          this.expect(tt.relational);
        }
        return result;
      }
      tsParseTypeParameterName() {
        const typeName = this.parseIdent();
        return typeName.name;
      }
      tsEatThenParseType(token) {
        return !this.match(token) ? void 0 : this.tsNextThenParseType();
      }
      tsExpectThenParseType(token) {
        return this.tsDoThenParseType(() => this.expect(token));
      }
      tsNextThenParseType() {
        return this.tsDoThenParseType(() => this.next());
      }
      tsDoThenParseType(cb) {
        return this.tsInType(() => {
          cb();
          return this.tsParseType();
        });
      }
      tsSkipParameterStart() {
        if (tokenIsIdentifier(this.type) || this.match(tt._this)) {
          this.next();
          return true;
        }
        if (this.match(tt.braceL)) {
          try {
            this.parseObj(true);
            return true;
          } catch {
            return false;
          }
        }
        if (this.match(tt.bracketL)) {
          this.next();
          try {
            this.parseBindingList(tt.bracketR, true, true);
            return true;
          } catch {
            return false;
          }
        }
        return false;
      }
      tsIsUnambiguouslyStartOfFunctionType() {
        this.next();
        if (this.match(tt.parenR) || this.match(tt.ellipsis)) {
          return true;
        }
        if (this.tsSkipParameterStart()) {
          if (this.match(tt.colon) || this.match(tt.comma) || this.match(tt.question) || this.match(tt.eq)) {
            return true;
          }
          if (this.match(tt.parenR)) {
            this.next();
            if (this.match(tt.arrow)) {
              return true;
            }
          }
        }
        return false;
      }
      tsIsStartOfFunctionType() {
        if (this.tsMatchLeftRelational()) {
          return true;
        }
        return this.match(tt.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
      }
      tsInAllowConditionalTypesContext(cb) {
        const oldInDisallowConditionalTypesContext = this.inDisallowConditionalTypesContext;
        this.inDisallowConditionalTypesContext = false;
        try {
          return cb();
        } finally {
          this.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
        }
      }
      tsParseBindingListForSignature() {
        return super.parseBindingList(tt.parenR, true, true).map((pattern) => {
          if (pattern.type !== "Identifier" && pattern.type !== "RestElement" && pattern.type !== "ObjectPattern" && pattern.type !== "ArrayPattern") {
            this.raise(
              pattern.start,
              TypeScriptError.UnsupportedSignatureParameterKind({ type: pattern.type })
            );
          }
          return pattern;
        });
      }
      tsParseTypePredicateAsserts() {
        if (this.type !== tokTypes2.asserts) {
          return false;
        }
        const containsEsc = this.containsEsc;
        this.next();
        if (!tokenIsIdentifier(this.type) && !this.match(tt._this)) {
          return false;
        }
        if (containsEsc) {
          this.raise(this.lastTokStart, "Escape sequence in keyword asserts");
        }
        return true;
      }
      tsParseThisTypeNode() {
        const node = this.startNode();
        this.next();
        return this.finishNode(node, "TSThisType");
      }
      tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {
        this.tsInType(() => {
          if (eatColon) this.expect(tt.colon);
          t.typeAnnotation = this.tsParseType();
        });
        return this.finishNode(t, "TSTypeAnnotation");
      }
      tsParseThisTypePredicate(lhs) {
        this.next();
        const node = this.startNodeAtNode(lhs);
        node.parameterName = lhs;
        node.typeAnnotation = this.tsParseTypeAnnotation(
          /* eatColon */
          false
        );
        node.asserts = false;
        return this.finishNode(node, "TSTypePredicate");
      }
      tsParseThisTypeOrThisTypePredicate() {
        const thisKeyword = this.tsParseThisTypeNode();
        if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
          return this.tsParseThisTypePredicate(thisKeyword);
        } else {
          return thisKeyword;
        }
      }
      tsParseTypePredicatePrefix() {
        const id2 = this.parseIdent();
        if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
          this.next();
          return id2;
        }
      }
      tsParseTypeOrTypePredicateAnnotation(returnToken) {
        return this.tsInType(() => {
          const t = this.startNode();
          this.expect(returnToken);
          const node = this.startNode();
          const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
          if (asserts && this.match(tt._this)) {
            let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
            if (thisTypePredicate.type === "TSThisType") {
              node.parameterName = thisTypePredicate;
              node.asserts = true;
              node.typeAnnotation = null;
              thisTypePredicate = this.finishNode(node, "TSTypePredicate");
            } else {
              this.resetStartLocationFromNode(thisTypePredicate, node);
              thisTypePredicate.asserts = true;
            }
            t.typeAnnotation = thisTypePredicate;
            return this.finishNode(t, "TSTypeAnnotation");
          }
          const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
          if (!typePredicateVariable) {
            if (!asserts) {
              return this.tsParseTypeAnnotation(
                /* eatColon */
                false,
                t
              );
            }
            node.parameterName = this.parseIdent();
            node.asserts = asserts;
            node.typeAnnotation = null;
            t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
            return this.finishNode(t, "TSTypeAnnotation");
          }
          const type2 = this.tsParseTypeAnnotation(
            /* eatColon */
            false
          );
          node.parameterName = typePredicateVariable;
          node.typeAnnotation = type2;
          node.asserts = asserts;
          t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
          return this.finishNode(t, "TSTypeAnnotation");
        });
      }
      // Note: In TypeScript implementation we must provide `yieldContext` and `awaitContext`,
      // but here it's always false, because this is only used for types.
      tsFillSignature(returnToken, signature) {
        const returnTokenRequired = returnToken === tt.arrow;
        const paramsKey = "parameters";
        const returnTypeKey = "typeAnnotation";
        signature.typeParameters = this.tsTryParseTypeParameters();
        this.expect(tt.parenL);
        signature[paramsKey] = this.tsParseBindingListForSignature();
        if (returnTokenRequired) {
          signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        } else if (this.match(returnToken)) {
          signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        }
      }
      tsTryNextParseConstantContext() {
        if (this.lookahead().type !== tt._const) return null;
        this.next();
        const typeReference = this.tsParseTypeReference();
        if (typeReference.typeParameters || typeReference.typeArguments) {
          this.raise(
            typeReference.typeName.start,
            TypeScriptError.CannotFindName({
              name: "const"
            })
          );
        }
        return typeReference;
      }
      tsParseFunctionOrConstructorType(type2, abstract) {
        const node = this.startNode();
        if (type2 === "TSConstructorType") {
          node.abstract = !!abstract;
          if (abstract) this.next();
          this.next();
        }
        this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(tt.arrow, node));
        return this.finishNode(node, type2);
      }
      tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
        const node = this.startNode();
        const hasLeadingOperator = this.eat(operator);
        const types3 = [];
        do {
          types3.push(parseConstituentType());
        } while (this.eat(operator));
        if (types3.length === 1 && !hasLeadingOperator) {
          return types3[0];
        }
        node.types = types3;
        return this.finishNode(node, kind);
      }
      tsCheckTypeAnnotationForReadOnly(node) {
        switch (node.typeAnnotation.type) {
          case "TSTupleType":
          case "TSArrayType":
            return;
          default:
            this.raise(node.start, TypeScriptError.UnexpectedReadonly);
        }
      }
      tsParseTypeOperator() {
        const node = this.startNode();
        const operator = this.value;
        this.next();
        node.operator = operator;
        node.typeAnnotation = this.tsParseTypeOperatorOrHigher();
        if (operator === "readonly") {
          this.tsCheckTypeAnnotationForReadOnly(node);
        }
        return this.finishNode(node, "TSTypeOperator");
      }
      tsParseConstraintForInferType() {
        if (this.eat(tt._extends)) {
          const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
          if (this.inDisallowConditionalTypesContext || !this.match(tt.question)) {
            return constraint;
          }
        }
      }
      tsParseInferType() {
        const node = this.startNode();
        this.expectContextual("infer");
        const typeParameter = this.startNode();
        typeParameter.name = this.tsParseTypeParameterName();
        typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());
        node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
        return this.finishNode(node, "TSInferType");
      }
      tsParseLiteralTypeNode() {
        const node = this.startNode();
        node.literal = (() => {
          switch (this.type) {
            case tt.num:
            // we don't need bigint type here
            // case tt.bigint:
            case tt.string:
            case tt._true:
            case tt._false:
              return this.parseExprAtom();
            default:
              this.unexpected();
          }
        })();
        return this.finishNode(node, "TSLiteralType");
      }
      tsParseImportType() {
        const node = this.startNode();
        this.expect(tt._import);
        this.expect(tt.parenL);
        if (!this.match(tt.string)) {
          this.raise(this.start, TypeScriptError.UnsupportedImportTypeArgument);
        }
        node.argument = this.parseExprAtom();
        this.expect(tt.parenR);
        if (this.eat(tt.dot)) {
          node.qualifier = this.tsParseEntityName();
        }
        if (this.tsMatchLeftRelational()) {
          node.typeArguments = this.tsParseTypeArguments();
        }
        return this.finishNode(node, "TSImportType");
      }
      tsParseTypeQuery() {
        const node = this.startNode();
        this.expect(tt._typeof);
        if (this.match(tt._import)) {
          node.exprName = this.tsParseImportType();
        } else {
          node.exprName = this.tsParseEntityName();
        }
        if (!this.hasPrecedingLineBreak() && this.tsMatchLeftRelational()) {
          node.typeArguments = this.tsParseTypeArguments();
        }
        return this.finishNode(node, "TSTypeQuery");
      }
      tsParseMappedTypeParameter() {
        const node = this.startNode();
        node.name = this.tsParseTypeParameterName();
        node.constraint = this.tsExpectThenParseType(tt._in);
        return this.finishNode(node, "TSTypeParameter");
      }
      tsParseMappedType() {
        const node = this.startNode();
        this.expect(tt.braceL);
        if (this.match(tt.plusMin)) {
          node.readonly = this.value;
          this.next();
          this.expectContextual("readonly");
        } else if (this.eatContextual("readonly")) {
          node.readonly = true;
        }
        this.expect(tt.bracketL);
        node.typeParameter = this.tsParseMappedTypeParameter();
        node.nameType = this.eatContextual("as") ? this.tsParseType() : null;
        this.expect(tt.bracketR);
        if (this.match(tt.plusMin)) {
          node.optional = this.value;
          this.next();
          this.expect(tt.question);
        } else if (this.eat(tt.question)) {
          node.optional = true;
        }
        node.typeAnnotation = this.tsTryParseType();
        this.semicolon();
        this.expect(tt.braceR);
        return this.finishNode(node, "TSMappedType");
      }
      tsParseTypeLiteral() {
        const node = this.startNode();
        node.members = this.tsParseObjectTypeMembers();
        return this.finishNode(node, "TSTypeLiteral");
      }
      tsParseTupleElementType() {
        const startLoc = this.startLoc;
        const startPos = this["start"];
        const rest2 = this.eat(tt.ellipsis);
        let type2 = this.tsParseType();
        const optional = this.eat(tt.question);
        const labeled2 = this.eat(tt.colon);
        if (labeled2) {
          const labeledNode = this.startNodeAtNode(type2);
          labeledNode.optional = optional;
          if (type2.type === "TSTypeReference" && !type2.typeArguments && type2.typeName.type === "Identifier") {
            labeledNode.label = type2.typeName;
          } else {
            this.raise(type2.start, TypeScriptError.InvalidTupleMemberLabel);
            labeledNode.label = type2;
          }
          labeledNode.elementType = this.tsParseType();
          type2 = this.finishNode(labeledNode, "TSNamedTupleMember");
        } else if (optional) {
          const optionalTypeNode = this.startNodeAtNode(type2);
          optionalTypeNode.typeAnnotation = type2;
          type2 = this.finishNode(optionalTypeNode, "TSOptionalType");
        }
        if (rest2) {
          const restNode = this.startNodeAt(startPos, startLoc);
          restNode.typeAnnotation = type2;
          type2 = this.finishNode(restNode, "TSRestType");
        }
        return type2;
      }
      tsParseTupleType() {
        const node = this.startNode();
        node.elementTypes = this.tsParseBracketedList(
          "TupleElementTypes",
          this.tsParseTupleElementType.bind(this),
          /* bracket */
          true,
          /* skipFirstToken */
          false
        );
        let seenOptionalElement = false;
        node.elementTypes.forEach((elementNode) => {
          const { type: type2 } = elementNode;
          if (seenOptionalElement && type2 !== "TSRestType" && type2 !== "TSOptionalType" && !(type2 === "TSNamedTupleMember" && elementNode.optional)) {
            this.raise(elementNode.start, TypeScriptError.OptionalTypeBeforeRequired);
          }
          seenOptionalElement ||= type2 === "TSNamedTupleMember" && elementNode.optional || type2 === "TSOptionalType";
          if (type2 === "TSRestType") {
            elementNode = elementNode.typeAnnotation;
          }
        });
        return this.finishNode(node, "TSTupleType");
      }
      tsParseTemplateLiteralType() {
        const node = this.startNode();
        node.literal = this.parseTemplate({ isTagged: false });
        return this.finishNode(node, "TSLiteralType");
      }
      tsParseTypeReference() {
        const node = this.startNode();
        node.typeName = this.tsParseEntityName();
        if (!this.hasPrecedingLineBreak() && this.tsMatchLeftRelational()) {
          node.typeArguments = this.tsParseTypeArguments();
        }
        return this.finishNode(node, "TSTypeReference");
      }
      tsMatchLeftRelational() {
        return this.match(tt.relational) && this.value === "<";
      }
      tsMatchRightRelational() {
        return this.match(tt.relational) && this.value === ">";
      }
      tsParseParenthesizedType() {
        const node = this.startNode();
        this.expect(tt.parenL);
        node.typeAnnotation = this.tsParseType();
        this.expect(tt.parenR);
        return this.finishNode(node, "TSParenthesizedType");
      }
      tsParseNonArrayType() {
        switch (this.type) {
          case tt.string:
          case tt.num:
          // we don't need bigint type here
          // case tt.bigint:
          case tt._true:
          case tt._false:
            return this.tsParseLiteralTypeNode();
          case tt.plusMin:
            if (this.value === "-") {
              const node = this.startNode();
              const nextToken = this.lookahead();
              if (nextToken.type !== tt.num) {
                this.unexpected();
              }
              node.literal = this.parseMaybeUnary();
              return this.finishNode(node, "TSLiteralType");
            }
            break;
          case tt._this:
            return this.tsParseThisTypeOrThisTypePredicate();
          case tt._typeof:
            return this.tsParseTypeQuery();
          case tt._import:
            return this.tsParseImportType();
          case tt.braceL:
            return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
          case tt.bracketL:
            return this.tsParseTupleType();
          case tt.parenL:
            return this.tsParseParenthesizedType();
          // parse template string here
          case tt.backQuote:
          case tt.dollarBraceL:
            return this.tsParseTemplateLiteralType();
          default: {
            const { type: type2 } = this;
            if (tokenIsIdentifier(type2) || type2 === tt._void || type2 === tt._null) {
              const nodeType = type2 === tt._void ? "TSVoidKeyword" : type2 === tt._null ? "TSNullKeyword" : keywordTypeFromName(this.value);
              if (nodeType !== void 0 && this.lookaheadCharCode() !== 46) {
                const node = this.startNode();
                this.next();
                return this.finishNode(node, nodeType);
              }
              return this.tsParseTypeReference();
            }
          }
        }
        this.unexpected();
      }
      tsParseArrayTypeOrHigher() {
        let type2 = this.tsParseNonArrayType();
        while (!this.hasPrecedingLineBreak() && this.eat(tt.bracketL)) {
          if (this.match(tt.bracketR)) {
            const node = this.startNodeAtNode(type2);
            node.elementType = type2;
            this.expect(tt.bracketR);
            type2 = this.finishNode(node, "TSArrayType");
          } else {
            const node = this.startNodeAtNode(type2);
            node.objectType = type2;
            node.indexType = this.tsParseType();
            this.expect(tt.bracketR);
            type2 = this.finishNode(node, "TSIndexedAccessType");
          }
        }
        return type2;
      }
      tsParseTypeOperatorOrHigher() {
        const isTypeOperator = tokenIsTSTypeOperator(this.type) && !this.containsEsc;
        return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual("infer") ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
      }
      tsParseIntersectionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType(
          "TSIntersectionType",
          this.tsParseTypeOperatorOrHigher.bind(this),
          tt.bitwiseAND
        );
      }
      tsParseUnionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType(
          "TSUnionType",
          this.tsParseIntersectionTypeOrHigher.bind(this),
          tt.bitwiseOR
        );
      }
      tsParseNonConditionalType() {
        if (this.tsIsStartOfFunctionType()) {
          return this.tsParseFunctionOrConstructorType("TSFunctionType");
        }
        if (this.match(tt._new)) {
          return this.tsParseFunctionOrConstructorType("TSConstructorType");
        } else if (this.isAbstractConstructorSignature()) {
          return this.tsParseFunctionOrConstructorType(
            "TSConstructorType",
            /* abstract */
            true
          );
        }
        return this.tsParseUnionTypeOrHigher();
      }
      /** Be sure to be in a type context before calling this, using `tsInType`. */
      tsParseType() {
        assert(this.inType);
        const type2 = this.tsParseNonConditionalType();
        if (this.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(tt._extends)) {
          return type2;
        }
        const node = this.startNodeAtNode(type2);
        node.checkType = type2;
        node.extendsType = this.tsInDisallowConditionalTypesContext(
          () => this.tsParseNonConditionalType()
        );
        this.expect(tt.question);
        node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
        this.expect(tt.colon);
        node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
        return this.finishNode(node, "TSConditionalType");
      }
      tsIsUnambiguouslyIndexSignature() {
        this.next();
        if (tokenIsIdentifier(this.type)) {
          this.next();
          return this.match(tt.colon);
        }
        return false;
      }
      /**
       * Runs `cb` in a type context.
       * This should be called one token *before* the first type token,
       * so that the call to `next()` is run in type context.
       */
      tsInType(cb) {
        const oldInType = this.inType;
        this.inType = true;
        try {
          return cb();
        } finally {
          this.inType = oldInType;
        }
      }
      tsTryParseIndexSignature(node) {
        if (!(this.match(tt.bracketL) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
          return void 0;
        }
        this.expect(tt.bracketL);
        const id2 = this.parseIdent();
        id2.typeAnnotation = this.tsParseTypeAnnotation();
        this.resetEndLocation(id2);
        this.expect(tt.bracketR);
        node.parameters = [id2];
        const type2 = this.tsTryParseTypeAnnotation();
        if (type2) node.typeAnnotation = type2;
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node, "TSIndexSignature");
      }
      // for better error recover
      tsParseNoneModifiers(node) {
        this.tsParseModifiers({
          modified: node,
          allowedModifiers: [],
          disallowedModifiers: ["in", "out"],
          errorTemplate: TypeScriptError.InvalidModifierOnTypeParameterPositions
        });
      }
      tsParseTypeParameter(parseModifiers = this.tsParseNoneModifiers.bind(this)) {
        const node = this.startNode();
        parseModifiers(node);
        node.name = this.tsParseTypeParameterName();
        node.constraint = this.tsEatThenParseType(tt._extends);
        node.default = this.tsEatThenParseType(tt.eq);
        return this.finishNode(node, "TSTypeParameter");
      }
      tsParseTypeParameters(parseModifiers) {
        const node = this.startNode();
        if (this.tsMatchLeftRelational() || this.matchJsx("jsxTagStart")) {
          this.next();
        } else {
          this.unexpected();
        }
        const refTrailingCommaPos = { value: -1 };
        node.params = this.tsParseBracketedList(
          "TypeParametersOrArguments",
          this.tsParseTypeParameter.bind(this, parseModifiers),
          /* bracket */
          false,
          /* skipFirstToken */
          true,
          refTrailingCommaPos
        );
        if (node.params.length === 0) {
          this.raise(this.start, TypeScriptError.EmptyTypeParameters);
        }
        if (refTrailingCommaPos.value !== -1) {
          this.addExtra(node, "trailingComma", refTrailingCommaPos.value);
        }
        return this.finishNode(node, "TSTypeParameterDeclaration");
      }
      tsTryParseTypeParameters(parseModifiers) {
        if (this.tsMatchLeftRelational()) {
          return this.tsParseTypeParameters(parseModifiers);
        }
      }
      tsTryParse(f) {
        const state = this.getCurLookaheadState();
        const result = f();
        if (result !== void 0 && result !== false) {
          return result;
        } else {
          this.setLookaheadState(state);
          return void 0;
        }
      }
      tsTokenCanFollowModifier() {
        return (this.match(tt.bracketL) || this.match(tt.braceL) || this.match(tt.star) || this.match(tt.ellipsis) || this.match(tt.privateId) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
      }
      tsNextTokenCanFollowModifier() {
        this.next(true);
        return this.tsTokenCanFollowModifier();
      }
      /** Parses a modifier matching one the given modifier names. */
      tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {
        const modifier = this.value;
        if (allowedModifiers.indexOf(modifier) !== -1 && !this.containsEsc) {
          if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {
            return void 0;
          }
          if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
            return modifier;
          }
        }
        return void 0;
      }
      tsParseModifiersByMap({
        modified,
        map: map2
      }) {
        for (const key2 of Object.keys(map2)) {
          modified[key2] = map2[key2];
        }
      }
      /** Parses a list of modifiers, in any order.
       *  If you need a specific order, you must call this function multiple times:
       *    this.tsParseModifiers({ modified: node, allowedModifiers: ['public'] });
       *    this.tsParseModifiers({ modified: node, allowedModifiers: ["abstract", "readonly"] });
       */
      tsParseModifiers({
        modified,
        allowedModifiers,
        disallowedModifiers,
        stopOnStartOfClassStaticBlock,
        errorTemplate = TypeScriptError.InvalidModifierOnTypeMember
      }) {
        const modifiedMap = {};
        const enforceOrder = (loc, modifier, before2, after2) => {
          if (modifier === before2 && modified[after2]) {
            this.raise(
              loc.column,
              TypeScriptError.InvalidModifiersOrder({ orderedModifiers: [before2, after2] })
            );
          }
        };
        const incompatible = (loc, modifier, mod1, mod2) => {
          if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
            this.raise(
              loc.column,
              TypeScriptError.IncompatibleModifiers({ modifiers: [mod1, mod2] })
            );
          }
        };
        for (; ; ) {
          const startLoc = this.startLoc;
          const modifier = this.tsParseModifier(
            allowedModifiers.concat(disallowedModifiers ?? []),
            stopOnStartOfClassStaticBlock
          );
          if (!modifier) break;
          if (tsIsAccessModifier(modifier)) {
            if (modified.accessibility) {
              this.raise(this.start, TypeScriptError.DuplicateAccessibilityModifier());
            } else {
              enforceOrder(startLoc, modifier, modifier, "override");
              enforceOrder(startLoc, modifier, modifier, "static");
              enforceOrder(startLoc, modifier, modifier, "readonly");
              enforceOrder(startLoc, modifier, modifier, "accessor");
              modifiedMap.accessibility = modifier;
              modified["accessibility"] = modifier;
            }
          } else if (tsIsVarianceAnnotations(modifier)) {
            if (modified[modifier]) {
              this.raise(this.start, TypeScriptError.DuplicateModifier({ modifier }));
            } else {
              enforceOrder(startLoc, modifier, "in", "out");
              modifiedMap[modifier] = modifier;
              modified[modifier] = true;
            }
          } else if (tsIsClassAccessor(modifier)) {
            if (modified[modifier]) {
              this.raise(this.start, TypeScriptError.DuplicateModifier({ modifier }));
            } else {
              incompatible(startLoc, modifier, "accessor", "readonly");
              incompatible(startLoc, modifier, "accessor", "static");
              incompatible(startLoc, modifier, "accessor", "override");
              modifiedMap[modifier] = modifier;
              modified[modifier] = true;
            }
          } else if (modifier === "const") {
            if (modified[modifier]) {
              this.raise(this.start, TypeScriptError.DuplicateModifier({ modifier }));
            } else {
              modifiedMap[modifier] = modifier;
              modified[modifier] = true;
            }
          } else {
            if (Object.hasOwnProperty.call(modified, modifier)) {
              this.raise(this.start, TypeScriptError.DuplicateModifier({ modifier }));
            } else {
              enforceOrder(startLoc, modifier, "static", "readonly");
              enforceOrder(startLoc, modifier, "static", "override");
              enforceOrder(startLoc, modifier, "override", "readonly");
              enforceOrder(startLoc, modifier, "abstract", "override");
              incompatible(startLoc, modifier, "declare", "override");
              incompatible(startLoc, modifier, "static", "abstract");
              modifiedMap[modifier] = modifier;
              modified[modifier] = true;
            }
          }
          if (disallowedModifiers?.includes(modifier)) {
            this.raise(this.start, errorTemplate);
          }
        }
        return modifiedMap;
      }
      tsParseInOutModifiers(node) {
        this.tsParseModifiers({
          modified: node,
          allowedModifiers: ["in", "out"],
          disallowedModifiers: [
            "public",
            "private",
            "protected",
            "readonly",
            "declare",
            "abstract",
            "override"
          ],
          errorTemplate: TypeScriptError.InvalidModifierOnTypeParameter
        });
      }
      // Handle type assertions
      parseMaybeUnary(refExpressionErrors, sawUnary, incDec, forInit) {
        if (!options2?.jsx && this.tsMatchLeftRelational()) {
          return this.tsParseTypeAssertion();
        } else {
          return super.parseMaybeUnary(refExpressionErrors, sawUnary, incDec, forInit);
        }
      }
      tsParseTypeAssertion() {
        if (disallowAmbiguousJSXLike) {
          this.raise(this.start, TypeScriptError.ReservedTypeAssertion);
        }
        const result = this.tryParse(() => {
          const node = this.startNode();
          const _const = this.tsTryNextParseConstantContext();
          node.typeAnnotation = _const || this.tsNextThenParseType();
          this.expect(tt.relational);
          node.expression = this.parseMaybeUnary();
          return this.finishNode(node, "TSTypeAssertion");
        });
        if (result.error) {
          return this.tsParseTypeParameters(this.tsParseConstModifier);
        } else {
          return result.node;
        }
      }
      tsParseTypeArguments() {
        const node = this.startNode();
        node.params = this.tsInType(
          () => (
            // Temporarily remove a JSX parsing context, which makes us scan different tokens.
            this.tsInNoContext(() => {
              this.expect(tt.relational);
              return this.tsParseDelimitedList(
                "TypeParametersOrArguments",
                this.tsParseType.bind(this)
              );
            })
          )
        );
        if (node.params.length === 0) {
          this.raise(this.start, TypeScriptError.EmptyTypeArguments);
        }
        this.exprAllowed = false;
        this.expect(tt.relational);
        return this.finishNode(node, "TSTypeParameterInstantiation");
      }
      tsParseHeritageClause(token) {
        const originalStart = this.start;
        const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", () => {
          const node = this.startNode();
          node.expression = this.tsParseEntityName();
          if (this.tsMatchLeftRelational()) {
            node.typeParameters = this.tsParseTypeArguments();
          }
          return this.finishNode(node, "TSExpressionWithTypeArguments");
        });
        if (!delimitedList.length) {
          this.raise(originalStart, TypeScriptError.EmptyHeritageClauseType({ token }));
        }
        return delimitedList;
      }
      tsParseTypeMemberSemicolon() {
        if (!this.eat(tt.comma) && !this.isLineTerminator()) {
          this.expect(tt.semi);
        }
      }
      tsTryParseAndCatch(f) {
        const result = this.tryParse(
          (abort) => (
            // @ts-expect-error todo(flow->ts)
            f() || abort()
          )
        );
        if (result.aborted || !result.node) return void 0;
        if (result.error) this.setLookaheadState(result.failState);
        return result.node;
      }
      tsParseSignatureMember(kind, node) {
        this.tsFillSignature(tt.colon, node);
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node, kind);
      }
      tsParsePropertyOrMethodSignature(node, readonly) {
        if (this.eat(tt.question)) node.optional = true;
        const nodeAny = node;
        if (this.match(tt.parenL) || this.tsMatchLeftRelational()) {
          if (readonly) {
            this.raise(node.start, TypeScriptError.ReadonlyForMethodSignature);
          }
          const method2 = nodeAny;
          if (method2.kind && this.tsMatchLeftRelational()) {
            this.raise(this.start, TypeScriptError.AccesorCannotHaveTypeParameters);
          }
          this.tsFillSignature(tt.colon, method2);
          this.tsParseTypeMemberSemicolon();
          const paramsKey = "parameters";
          const returnTypeKey = "typeAnnotation";
          if (method2.kind === "get") {
            if (method2[paramsKey].length > 0) {
              this.raise(this.start, "A 'get' accesor must not have any formal parameters.");
              if (this.isThisParam(method2[paramsKey][0])) {
                this.raise(this.start, TypeScriptError.AccesorCannotDeclareThisParameter);
              }
            }
          } else if (method2.kind === "set") {
            if (method2[paramsKey].length !== 1) {
              this.raise(this.start, "A 'get' accesor must not have any formal parameters.");
            } else {
              const firstParameter = method2[paramsKey][0];
              if (this.isThisParam(firstParameter)) {
                this.raise(this.start, TypeScriptError.AccesorCannotDeclareThisParameter);
              }
              if (firstParameter.type === "Identifier" && firstParameter.optional) {
                this.raise(this.start, TypeScriptError.SetAccesorCannotHaveOptionalParameter);
              }
              if (firstParameter.type === "RestElement") {
                this.raise(this.start, TypeScriptError.SetAccesorCannotHaveRestParameter);
              }
            }
            if (method2[returnTypeKey]) {
              this.raise(
                method2[returnTypeKey].start,
                TypeScriptError.SetAccesorCannotHaveReturnType
              );
            }
          } else {
            method2.kind = "method";
          }
          return this.finishNode(method2, "TSMethodSignature");
        } else {
          const property = nodeAny;
          if (readonly) property.readonly = true;
          const type2 = this.tsTryParseTypeAnnotation();
          if (type2) property.typeAnnotation = type2;
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(property, "TSPropertySignature");
        }
      }
      tsParseTypeMember() {
        const node = this.startNode();
        if (this.match(tt.parenL) || this.tsMatchLeftRelational()) {
          return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
        }
        if (this.match(tt._new)) {
          const id2 = this.startNode();
          this.next();
          if (this.match(tt.parenL) || this.tsMatchLeftRelational()) {
            return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
          } else {
            node.key = this.createIdentifier(id2, "new");
            return this.tsParsePropertyOrMethodSignature(node, false);
          }
        }
        this.tsParseModifiers({
          modified: node,
          allowedModifiers: ["readonly"],
          disallowedModifiers: [
            "declare",
            "abstract",
            "private",
            "protected",
            "public",
            "static",
            "override"
          ]
        });
        const idx = this.tsTryParseIndexSignature(node);
        if (idx) {
          return idx;
        }
        this.parsePropertyName(node);
        if (!node.computed && node.key.type === "Identifier" && (node.key.name === "get" || node.key.name === "set") && this.tsTokenCanFollowModifier()) {
          node.kind = node.key.name;
          this.parsePropertyName(node);
        }
        return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);
      }
      tsParseList(kind, parseElement) {
        const result = [];
        while (!this.tsIsListTerminator(kind)) {
          result.push(parseElement());
        }
        return result;
      }
      tsParseObjectTypeMembers() {
        this.expect(tt.braceL);
        const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
        this.expect(tt.braceR);
        return members;
      }
      tsParseInterfaceDeclaration(node, properties = {}) {
        if (this.hasFollowingLineBreak()) return null;
        this.expectContextual("interface");
        if (properties.declare) node.declare = true;
        if (tokenIsIdentifier(this.type)) {
          node.id = this.parseIdent();
          this.checkLValSimple(node.id, acornScope.BIND_TS_INTERFACE);
        } else {
          node.id = null;
          this.raise(this.start, TypeScriptError.MissingInterfaceName);
        }
        node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));
        if (this.eat(tt._extends)) {
          node.extends = this.tsParseHeritageClause("extends");
        }
        const body2 = this.startNode();
        body2.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
        node.body = this.finishNode(body2, "TSInterfaceBody");
        return this.finishNode(node, "TSInterfaceDeclaration");
      }
      tsParseAbstractDeclaration(node) {
        if (this.match(tt._class)) {
          node.abstract = true;
          return this.parseClass(node, true);
        } else if (this.ts_isContextual(tokTypes2.interface)) {
          if (!this.hasFollowingLineBreak()) {
            node.abstract = true;
            return this.tsParseInterfaceDeclaration(node);
          }
        } else {
          this.unexpected(node.start);
        }
      }
      tsIsDeclarationStart() {
        return tokenIsTSDeclarationStart(this.type);
      }
      tsParseExpressionStatement(node, expr) {
        switch (expr.name) {
          case "declare": {
            const declaration2 = this.tsTryParseDeclare(node);
            if (declaration2) {
              declaration2.declare = true;
              return declaration2;
            }
            break;
          }
          case "global":
            if (this.match(tt.braceL)) {
              this.enterScope(TS_SCOPE_TS_MODULE);
              const mod = node;
              mod.global = true;
              mod.id = expr;
              mod.body = this.tsParseModuleBlock();
              super.exitScope();
              return this.finishNode(mod, "TSModuleDeclaration");
            }
            break;
          default:
            return this.tsParseDeclaration(
              node,
              expr.name,
              /* next */
              false
            );
        }
      }
      tsParseModuleReference() {
        return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(
          /* allowReservedWords */
          false
        );
      }
      tsIsExportDefaultSpecifier() {
        const { type: type2 } = this;
        const isAsync = this.isAsyncFunction();
        const isLet = this.isLet();
        if (tokenIsIdentifier(type2)) {
          if (isAsync && !this.containsEsc || isLet) {
            return false;
          }
          if ((type2 === tokTypes2.type || type2 === tokTypes2.interface) && !this.containsEsc) {
            const ahead = this.lookahead();
            if (tokenIsIdentifier(ahead.type) && !this.isContextualWithState("from", ahead) || ahead.type === tt.braceL) {
              return false;
            }
          }
        } else if (!this.match(tt._default)) {
          return false;
        }
        const next2 = this.nextTokenStart();
        const hasFrom = this.isUnparsedContextual(next2, "from");
        if (this.input.charCodeAt(next2) === 44 || tokenIsIdentifier(this.type) && hasFrom) {
          return true;
        }
        if (this.match(tt._default) && hasFrom) {
          const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next2 + 4));
          return nextAfterFrom === 34 || nextAfterFrom === 39;
        }
        return false;
      }
      tsInAmbientContext(cb) {
        const oldIsAmbientContext = this.isAmbientContext;
        this.isAmbientContext = true;
        try {
          return cb();
        } finally {
          this.isAmbientContext = oldIsAmbientContext;
        }
      }
      tsCheckLineTerminator(next2) {
        if (next2) {
          if (this.hasFollowingLineBreak()) return false;
          this.next();
          return true;
        }
        return !this.isLineTerminator();
      }
      tsParseModuleOrNamespaceDeclaration(node, nested = false) {
        node.id = this.parseIdent();
        if (!nested) {
          this.checkLValSimple(node.id, acornScope.BIND_TS_NAMESPACE);
        }
        if (this.eat(tt.dot)) {
          const inner = this.startNode();
          this.tsParseModuleOrNamespaceDeclaration(inner, true);
          node.body = inner;
        } else {
          this.enterScope(TS_SCOPE_TS_MODULE);
          node.body = this.tsParseModuleBlock();
          super.exitScope();
        }
        return this.finishNode(node, "TSModuleDeclaration");
      }
      checkLValSimple(expr, bindingType = acornScope.BIND_NONE, checkClashes) {
        if (expr.type === "TSNonNullExpression" || expr.type === "TSAsExpression") {
          expr = expr.expression;
        }
        return super.checkLValSimple(expr, bindingType, checkClashes);
      }
      tsParseTypeAliasDeclaration(node) {
        node.id = this.parseIdent();
        this.checkLValSimple(node.id, acornScope.BIND_TS_TYPE);
        node.typeAnnotation = this.tsInType(() => {
          node.typeParameters = this.tsTryParseTypeParameters(
            this.tsParseInOutModifiers.bind(this)
          );
          this.expect(tt.eq);
          if (this.ts_isContextual(tokTypes2.interface) && this.lookahead().type !== tt.dot) {
            const node2 = this.startNode();
            this.next();
            return this.finishNode(node2, "TSIntrinsicKeyword");
          }
          return this.tsParseType();
        });
        this.semicolon();
        return this.finishNode(node, "TSTypeAliasDeclaration");
      }
      // Common to tsTryParseDeclare, tsTryParseExportDeclaration, and tsParseExpressionStatement.
      tsParseDeclaration(node, value, next2) {
        switch (value) {
          case "abstract":
            if (this.tsCheckLineTerminator(next2) && (this.match(tt._class) || tokenIsIdentifier(this.type))) {
              return this.tsParseAbstractDeclaration(node);
            }
            break;
          case "module":
            if (this.tsCheckLineTerminator(next2)) {
              if (this.match(tt.string)) {
                return this.tsParseAmbientExternalModuleDeclaration(node);
              } else if (tokenIsIdentifier(this.type)) {
                return this.tsParseModuleOrNamespaceDeclaration(node);
              }
            }
            break;
          case "namespace":
            if (this.tsCheckLineTerminator(next2) && tokenIsIdentifier(this.type)) {
              return this.tsParseModuleOrNamespaceDeclaration(node);
            }
            break;
          case "type":
            if (this.tsCheckLineTerminator(next2) && tokenIsIdentifier(this.type)) {
              return this.tsParseTypeAliasDeclaration(node);
            }
            break;
        }
      }
      // Note: this won't be called unless the keyword is allowed in
      // `shouldParseExportDeclaration`.
      tsTryParseExportDeclaration() {
        return this.tsParseDeclaration(
          this.startNode(),
          this.value,
          /* next */
          true
        );
      }
      tsParseImportEqualsDeclaration(node, isExport) {
        node.isExport = isExport || false;
        node.id = this.parseIdent();
        this.checkLValSimple(node.id, acornScope.BIND_LEXICAL);
        super.expect(tt.eq);
        const moduleReference = this.tsParseModuleReference();
        if (node.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") {
          this.raise(moduleReference.start, TypeScriptError.ImportAliasHasImportType);
        }
        node.moduleReference = moduleReference;
        super.semicolon();
        return this.finishNode(node, "TSImportEqualsDeclaration");
      }
      isExportDefaultSpecifier() {
        if (this.tsIsDeclarationStart()) return false;
        const { type: type2 } = this;
        if (tokenIsIdentifier(type2)) {
          if (this.isContextual("async") || this.isContextual("let")) {
            return false;
          }
          if ((type2 === tokTypes2.type || type2 === tokTypes2.interface) && !this.containsEsc) {
            const ahead = this.lookahead();
            if (tokenIsIdentifier(ahead.type) && !this.isContextualWithState("from", ahead) || ahead.type === tt.braceL) {
              return false;
            }
          }
        } else if (!this.match(tt._default)) {
          return false;
        }
        const next2 = this.nextTokenStart();
        const hasFrom = this.isUnparsedContextual(next2, "from");
        if (this.input.charCodeAt(next2) === 44 || tokenIsIdentifier(this.type) && hasFrom) {
          return true;
        }
        if (this.match(tt._default) && hasFrom) {
          const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next2 + 4));
          return nextAfterFrom === 34 || nextAfterFrom === 39;
        }
        return false;
      }
      parseTemplate({ isTagged = false } = {}) {
        let node = this.startNode();
        this.next();
        node.expressions = [];
        let curElt = this.parseTemplateElement({ isTagged });
        node.quasis = [curElt];
        while (!curElt.tail) {
          if (this.type === tt.eof) this.raise(this.pos, "Unterminated template literal");
          this.expect(tt.dollarBraceL);
          node.expressions.push(this.inType ? this.tsParseType() : this.parseExpression());
          this.expect(tt.braceR);
          node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
        }
        this.next();
        return this.finishNode(node, "TemplateLiteral");
      }
      parseFunction(node, statement, allowExpressionBody, isAsync, forInit) {
        this.initFunction(node);
        if (this.ecmaVersion >= 9 || this.ecmaVersion >= 6 && !isAsync) {
          if (this.type === tt.star && statement & FUNC_HANGING_STATEMENT2) {
            this.unexpected();
          }
          node.generator = this.eat(tt.star);
        }
        if (this.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        if (statement & FUNC_STATEMENT2) {
          node.id = statement & FUNC_NULLABLE_ID2 && this.type !== tt.name ? null : this.parseIdent();
        }
        let oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        const oldMaybeInArrowParameters = this.maybeInArrowParameters;
        this.maybeInArrowParameters = false;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags2(node.async, node.generator));
        if (!(statement & FUNC_STATEMENT2)) {
          node.id = this.type === tt.name ? this.parseIdent() : null;
        }
        this.parseFunctionParams(node);
        const isDeclaration = statement & FUNC_STATEMENT2;
        this.parseFunctionBody(node, allowExpressionBody, false, forInit, {
          isFunctionDeclaration: isDeclaration
        });
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        if (statement & FUNC_STATEMENT2 && node.id && !(statement & FUNC_HANGING_STATEMENT2)) {
          if (node.body) {
            this.checkLValSimple(
              node.id,
              this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? acornScope.BIND_VAR : acornScope.BIND_LEXICAL : acornScope.BIND_FUNCTION
            );
          } else {
            this.checkLValSimple(node.id, acornScope.BIND_NONE);
          }
        }
        this.maybeInArrowParameters = oldMaybeInArrowParameters;
        return this.finishNode(node, isDeclaration ? "FunctionDeclaration" : "FunctionExpression");
      }
      parseFunctionBody(node, isArrowFunction = false, isMethod = false, forInit = false, tsConfig) {
        if (this.match(tt.colon)) {
          node.returnType = this.tsParseTypeOrTypePredicateAnnotation(tt.colon);
        }
        const bodilessType = tsConfig?.isFunctionDeclaration ? "TSDeclareFunction" : tsConfig?.isClassMethod ? "TSDeclareMethod" : void 0;
        if (bodilessType && !this.match(tt.braceL) && this.isLineTerminator()) {
          return this.finishNode(node, bodilessType);
        }
        if (bodilessType === "TSDeclareFunction" && this.isAmbientContext) {
          this.raise(node.start, TypeScriptError.DeclareFunctionHasImplementation);
          if (node.declare) {
            super.parseFunctionBody(node, isArrowFunction, isMethod, false);
            return this.finishNode(node, bodilessType);
          }
        }
        super.parseFunctionBody(node, isArrowFunction, isMethod, forInit);
        return node;
      }
      parseNew() {
        if (this.containsEsc) this.raiseRecoverable(this.start, "Escape sequence in keyword new");
        let node = this.startNode();
        let meta2 = this.parseIdent(true);
        if (this.ecmaVersion >= 6 && this.eat(tt.dot)) {
          node.meta = meta2;
          let containsEsc = this.containsEsc;
          node.property = this.parseIdent(true);
          if (node.property.name !== "target")
            this.raiseRecoverable(
              node.property.start,
              "The only valid meta property for new is 'new.target'"
            );
          if (containsEsc)
            this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
          if (!this["allowNewDotTarget"])
            this.raiseRecoverable(
              node.start,
              "'new.target' can only be used in functions and class static block"
            );
          return this.finishNode(node, "MetaProperty");
        }
        let startPos = this.start, startLoc = this.startLoc, isImport = this.type === tt._import;
        node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true, false);
        if (isImport && node.callee.type === "ImportExpression") {
          this.raise(startPos, "Cannot use new with import()");
        }
        const { callee } = node;
        if (callee.type === "TSInstantiationExpression" && !callee.extra?.parenthesized) {
          node.typeArguments = callee.typeArguments;
          node.callee = callee.expression;
        }
        if (this.eat(tt.parenL))
          node.arguments = this.parseExprList(tt.parenR, this.ecmaVersion >= 8, false);
        else node.arguments = [];
        return this.finishNode(node, "NewExpression");
      }
      parseExprOp(left, leftStartPos, leftStartLoc, minPrec, forInit) {
        if (tt._in.binop > minPrec && !this.hasPrecedingLineBreak()) {
          let nodeType;
          if (this.isContextual("as")) {
            nodeType = "TSAsExpression";
          }
          if (this.isContextual("satisfies")) {
            nodeType = "TSSatisfiesExpression";
          }
          if (nodeType) {
            const node = this.startNodeAt(leftStartPos, leftStartLoc);
            node.expression = left;
            const _const = this.tsTryNextParseConstantContext();
            if (_const) {
              node.typeAnnotation = _const;
            } else {
              node.typeAnnotation = this.tsNextThenParseType();
            }
            this.finishNode(node, nodeType);
            this.reScan_lt_gt();
            return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
          }
        }
        return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec, forInit);
      }
      parseImportSpecifiers() {
        let nodes = [], first2 = true;
        if (acornTypeScript.tokenIsIdentifier(this.type)) {
          nodes.push(this.parseImportDefaultSpecifier());
          if (!this.eat(tt.comma)) return nodes;
        }
        if (this.type === tt.star) {
          nodes.push(this.parseImportNamespaceSpecifier());
          return nodes;
        }
        this.expect(tt.braceL);
        while (!this.eat(tt.braceR)) {
          if (!first2) {
            this.expect(tt.comma);
            if (this.afterTrailingComma(tt.braceR)) break;
          } else first2 = false;
          nodes.push(this.parseImportSpecifier());
        }
        return nodes;
      }
      /**
       * @param {Node} node this may be ImportDeclaration |
       * TsImportEqualsDeclaration
       * @returns AnyImport
       * */
      parseImport(node) {
        let enterHead = this.lookahead();
        node.importKind = "value";
        this.importOrExportOuterKind = "value";
        if (tokenIsIdentifier(enterHead.type) || this.match(tt.star) || this.match(tt.braceL)) {
          let ahead = this.lookahead(2);
          if (
            // import type, { a } from "b";
            ahead.type !== tt.comma && // import type from "a";
            !this.isContextualWithState("from", ahead) && // import type = require("a");
            ahead.type !== tt.eq && this.ts_eatContextualWithState("type", 1, enterHead)
          ) {
            this.importOrExportOuterKind = "type";
            node.importKind = "type";
            enterHead = this.lookahead();
            ahead = this.lookahead(2);
          }
          if (tokenIsIdentifier(enterHead.type) && ahead.type === tt.eq) {
            this.next();
            const importNode = this.tsParseImportEqualsDeclaration(node);
            this.importOrExportOuterKind = "value";
            return importNode;
          }
        }
        this.next();
        if (this.type === tt.string) {
          node.specifiers = [];
          node.source = this.parseExprAtom();
        } else {
          node.specifiers = this.parseImportSpecifiers();
          this.expectContextual("from");
          node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();
        }
        this.parseMaybeImportAttributes(node);
        this.semicolon();
        this.finishNode(node, "ImportDeclaration");
        this.importOrExportOuterKind = "value";
        if (node.importKind === "type" && node.specifiers.length > 1 && node.specifiers[0].type === "ImportDefaultSpecifier") {
          this.raise(node.start, TypeScriptError.TypeImportCannotSpecifyDefaultAndNamed);
        }
        return node;
      }
      parseExportDefaultDeclaration() {
        if (this.isAbstractClass()) {
          const cls = this.startNode();
          this.next();
          cls.abstract = true;
          return this.parseClass(cls, true);
        }
        if (this.match(tokTypes2.interface)) {
          const result = this.tsParseInterfaceDeclaration(this.startNode());
          if (result) return result;
        }
        return super.parseExportDefaultDeclaration();
      }
      parseExportAllDeclaration(node, exports) {
        if (this.ecmaVersion >= 11) {
          if (this.eatContextual("as")) {
            node.exported = this.parseModuleExportName();
            this.checkExport(exports, node.exported, this.lastTokStart);
          } else {
            node.exported = null;
          }
        }
        this.expectContextual("from");
        if (this.type !== tt.string) this.unexpected();
        node.source = this.parseExprAtom();
        this.parseMaybeImportAttributes(node);
        this.semicolon();
        return this.finishNode(node, "ExportAllDeclaration");
      }
      parseDynamicImport(node) {
        this.next();
        node.source = this.parseMaybeAssign();
        if (this.eat(tt.comma)) {
          const expr = this.parseExpression();
          node.arguments = [expr];
        }
        if (!this.eat(tt.parenR)) {
          const errorPos = this.start;
          if (this.eat(tt.comma) && this.eat(tt.parenR)) {
            this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
          } else {
            this.unexpected(errorPos);
          }
        }
        return this.finishNode(node, "ImportExpression");
      }
      parseExport(node, exports) {
        let enterHead = this.lookahead();
        if (this.ts_eatWithState(tt._import, 2, enterHead)) {
          if (this.ts_isContextual(tokTypes2.type) && this.lookaheadCharCode() !== 61) {
            node.importKind = "type";
            this.importOrExportOuterKind = "type";
            this.next();
          } else {
            node.importKind = "value";
            this.importOrExportOuterKind = "value";
          }
          const exportEqualsNode = this.tsParseImportEqualsDeclaration(
            node,
            /* isExport */
            true
          );
          this.importOrExportOuterKind = void 0;
          return exportEqualsNode;
        } else if (this.ts_eatWithState(tt.eq, 2, enterHead)) {
          const assign = node;
          assign.expression = this.parseExpression();
          this.semicolon();
          this.importOrExportOuterKind = void 0;
          return this.finishNode(assign, "TSExportAssignment");
        } else if (this.ts_eatContextualWithState("as", 2, enterHead)) {
          const decl = node;
          this.expectContextual("namespace");
          decl.id = this.parseIdent();
          this.semicolon();
          this.importOrExportOuterKind = void 0;
          return this.finishNode(decl, "TSNamespaceExportDeclaration");
        } else {
          const lookahead2 = this.lookahead(2).type;
          if (this.ts_isContextualWithState(enterHead, tokTypes2.type) && (lookahead2 === tt.braceL || // export type { ... }
          lookahead2 === tt.star)) {
            this.next();
            this.importOrExportOuterKind = "type";
            node.exportKind = "type";
          } else {
            this.importOrExportOuterKind = "value";
            node.exportKind = "value";
          }
          this.next();
          if (this.eat(tt.star)) {
            return this.parseExportAllDeclaration(node, exports);
          }
          if (this.eat(tt._default)) {
            this.checkExport(exports, "default", this.lastTokStart);
            node.declaration = this.parseExportDefaultDeclaration();
            return this.finishNode(node, "ExportDefaultDeclaration");
          }
          if (this.shouldParseExportStatement()) {
            node.declaration = this.parseExportDeclaration(node);
            if (node.declaration.type === "VariableDeclaration")
              this.checkVariableExport(exports, node.declaration.declarations);
            else this.checkExport(exports, node.declaration.id, node.declaration.id.start);
            node.specifiers = [];
            node.source = null;
          } else {
            node.declaration = null;
            node.specifiers = this.parseExportSpecifiers(exports);
            if (this.eatContextual("from")) {
              if (this.type !== tt.string) this.unexpected();
              node.source = this.parseExprAtom();
              this.parseMaybeImportAttributes(node);
            } else {
              for (let spec of node.specifiers) {
                this.checkUnreserved(spec.local);
                this.checkLocalExport(spec.local);
                if (spec.local.type === "Literal") {
                  this.raise(
                    spec.local.start,
                    "A string literal cannot be used as an exported binding without `from`."
                  );
                }
              }
              node.source = null;
            }
            this.semicolon();
          }
          return this.finishNode(node, "ExportNamedDeclaration");
        }
      }
      checkExport(exports, name2, _) {
        if (!exports) {
          return;
        }
        if (typeof name2 !== "string") {
          name2 = name2.type === "Identifier" ? name2.name : name2.value;
        }
        exports[name2] = true;
      }
      parseMaybeDefault(startPos, startLoc, left) {
        const node = super.parseMaybeDefault(startPos, startLoc, left);
        if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
          this.raise(node.typeAnnotation.start, TypeScriptError.TypeAnnotationAfterAssign);
        }
        return node;
      }
      typeCastToParameter(node) {
        node.expression.typeAnnotation = node.typeAnnotation;
        this.resetEndLocation(
          node.expression,
          node.typeAnnotation.end,
          node.typeAnnotation.loc?.end
        );
        return node.expression;
      }
      toAssignableList(exprList, isBinding) {
        if (!exprList) exprList = [];
        for (let i = 0; i < exprList.length; i++) {
          const expr = exprList[i];
          if (expr?.type === "TSTypeCastExpression") {
            exprList[i] = this.typeCastToParameter(expr);
          }
        }
        return super.toAssignableList(exprList, isBinding);
      }
      reportReservedArrowTypeParam(node) {
        if (node.params.length === 1 && !node.extra?.trailingComma && disallowAmbiguousJSXLike) {
          this.raise(node.start, TypeScriptError.ReservedArrowTypeParam);
        }
      }
      parseExprAtom(refDestructuringErrors, forInit, forNew) {
        if (this.type === tokTypes2.jsxText) {
          return this.jsx_parseText();
        } else if (this.type === tokTypes2.jsxTagStart) {
          return this.jsx_parseElement();
        } else if (this.type === tokTypes2.at) {
          this.parseDecorators();
          return this.parseExprAtom();
        } else if (tokenIsIdentifier(this.type)) {
          let canBeArrow = this.potentialArrowAt === this.start;
          let startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
          let id2 = this.parseIdent(false);
          if (this.ecmaVersion >= 8 && !containsEsc && id2.name === "async" && !this.canInsertSemicolon() && this.eat(tt._function)) {
            this.overrideContext(tokContexts.f_expr);
            return this.parseFunction(
              this.startNodeAt(startPos, startLoc),
              0,
              false,
              true,
              forInit
            );
          }
          if (canBeArrow && !this.canInsertSemicolon()) {
            if (this.eat(tt.arrow))
              return this.parseArrowExpression(
                this.startNodeAt(startPos, startLoc),
                [id2],
                false,
                forInit
              );
            if (this.ecmaVersion >= 8 && id2.name === "async" && this.type === tt.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
              id2 = this.parseIdent(false);
              if (this.canInsertSemicolon() || !this.eat(tt.arrow)) this.unexpected();
              return this.parseArrowExpression(
                this.startNodeAt(startPos, startLoc),
                [id2],
                true,
                forInit
              );
            }
          }
          return id2;
        } else {
          return super.parseExprAtom(refDestructuringErrors, forInit, forNew);
        }
      }
      parseExprAtomDefault() {
        if (tokenIsIdentifier(this.type)) {
          const canBeArrow = this["potentialArrowAt"] === this.start;
          const containsEsc = this.containsEsc;
          const id2 = this.parseIdent();
          if (!containsEsc && id2.name === "async" && !this.canInsertSemicolon()) {
            const { type: type2 } = this;
            if (type2 === tt._function) {
              this.next();
              return this.parseFunction(this.startNodeAtNode(id2), void 0, true, true);
            } else if (tokenIsIdentifier(type2)) {
              if (this.lookaheadCharCode() === 61) {
                const paramId = this.parseIdent(false);
                if (this.canInsertSemicolon() || !this.eat(tt.arrow)) this.unexpected();
                return this.parseArrowExpression(this.startNodeAtNode(id2), [paramId], true);
              } else {
                return id2;
              }
            }
          }
          if (canBeArrow && this.match(tt.arrow) && !this.canInsertSemicolon()) {
            this.next();
            return this.parseArrowExpression(this.startNodeAtNode(id2), [id2], false);
          }
          return id2;
        } else {
          this.unexpected();
        }
      }
      parseIdentNode() {
        let node = this.startNode();
        if (tokenIsKeywordOrIdentifier(this.type) && // Taken from super-class method
        !((this.type.keyword === "class" || this.type.keyword === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46))) {
          node.name = this.value;
        } else {
          return super.parseIdentNode();
        }
        return node;
      }
      parseVarStatement(node, kind, allowMissingInitializer = false) {
        const { isAmbientContext } = this;
        this.next();
        super.parseVar(node, false, kind, allowMissingInitializer || isAmbientContext);
        this.semicolon();
        const declaration2 = this.finishNode(node, "VariableDeclaration");
        if (!isAmbientContext) return declaration2;
        for (const { id: id2, init: init2 } of declaration2.declarations) {
          if (!init2) continue;
          if (kind !== "const" || !!id2.typeAnnotation) {
            this.raise(init2.start, TypeScriptError.InitializerNotAllowedInAmbientContext);
          } else if (init2.type !== "StringLiteral" && init2.type !== "BooleanLiteral" && init2.type !== "NumericLiteral" && init2.type !== "BigIntLiteral" && (init2.type !== "TemplateLiteral" || init2.expressions.length > 0) && !isPossiblyLiteralEnum(init2)) {
            this.raise(
              init2.start,
              TypeScriptError.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference
            );
          }
        }
        return declaration2;
      }
      parseStatement(context2, topLevel, exports) {
        if (this.match(tokTypes2.at)) {
          this.parseDecorators(true);
        }
        if (this.match(tt._const) && this.isLookaheadContextual("enum")) {
          const node = this.startNode();
          this.expect(tt._const);
          return this.tsParseEnumDeclaration(node, { const: true });
        }
        if (this.ts_isContextual(tokTypes2.enum)) {
          return this.tsParseEnumDeclaration(this.startNode());
        }
        if (this.ts_isContextual(tokTypes2.interface)) {
          const result = this.tsParseInterfaceDeclaration(this.startNode());
          if (result) return result;
        }
        return super.parseStatement(context2, topLevel, exports);
      }
      // NOTE: unused function
      parseAccessModifier() {
        return this.tsParseModifier(["public", "protected", "private"]);
      }
      parsePostMemberNameModifiers(methodOrProp) {
        const optional = this.eat(tt.question);
        if (optional) methodOrProp.optional = true;
        if (methodOrProp.readonly && this.match(tt.parenL)) {
          this.raise(methodOrProp.start, TypeScriptError.ClassMethodHasReadonly);
        }
        if (methodOrProp.declare && this.match(tt.parenL)) {
          this.raise(methodOrProp.start, TypeScriptError.ClassMethodHasDeclare);
        }
      }
      // Note: The reason we do this in `parseExpressionStatement` and not `parseStatement`
      // is that e.g. `type()` is valid JS, so we must try parsing that first.
      // If it's really a type, we will parse `type` as the statement, and can correct it here
      // by parsing the rest.
      parseExpressionStatement(node, expr) {
        const decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr) : void 0;
        return decl || super.parseExpressionStatement(node, expr);
      }
      shouldParseExportStatement() {
        if (this.tsIsDeclarationStart()) return true;
        if (this.match(tokTypes2.at)) {
          return true;
        }
        return super.shouldParseExportStatement();
      }
      parseConditional(expr, startPos, startLoc, forInit, refDestructuringErrors) {
        if (this.eat(tt.question)) {
          let node = this.startNodeAt(startPos, startLoc);
          node.test = expr;
          node.consequent = this.parseMaybeAssign();
          this.expect(tt.colon);
          node.alternate = this.parseMaybeAssign(forInit);
          return this.finishNode(node, "ConditionalExpression");
        }
        return expr;
      }
      parseMaybeConditional(forInit, refDestructuringErrors) {
        let startPos = this.start, startLoc = this.startLoc;
        let expr = this.parseExprOps(forInit, refDestructuringErrors);
        if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
        if (!this.maybeInArrowParameters || !this.match(tt.question)) {
          return this.parseConditional(expr, startPos, startLoc, forInit, refDestructuringErrors);
        }
        const result = this.tryParse(
          () => this.parseConditional(expr, startPos, startLoc, forInit, refDestructuringErrors)
        );
        if (!result.node) {
          if (result.error) {
            this.setOptionalParametersError(refDestructuringErrors, result.error);
          }
          return expr;
        }
        if (result.error) this.setLookaheadState(result.failState);
        return result.node;
      }
      parseParenItem(node) {
        const startPos = this.start;
        const startLoc = this.startLoc;
        node = super.parseParenItem(node);
        if (this.eat(tt.question)) {
          node.optional = true;
          this.resetEndLocation(node);
        }
        if (this.match(tt.colon)) {
          const typeCastNode = this.startNodeAt(startPos, startLoc);
          typeCastNode.expression = node;
          typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
          return this.finishNode(typeCastNode, "TSTypeCastExpression");
        }
        return node;
      }
      parseExportDeclaration(node) {
        if (!this.isAmbientContext && this.ts_isContextual(tokTypes2.declare)) {
          return this.tsInAmbientContext(() => this.parseExportDeclaration(node));
        }
        const startPos = this.start;
        const startLoc = this.startLoc;
        const isDeclare = this.eatContextual("declare");
        if (isDeclare && (this.ts_isContextual(tokTypes2.declare) || !this.shouldParseExportStatement())) {
          this.raise(this.start, TypeScriptError.ExpectedAmbientAfterExportDeclare);
        }
        const isIdentifier = tokenIsIdentifier(this.type);
        const declaration2 = isIdentifier && this.tsTryParseExportDeclaration() || this.parseStatement(null);
        if (!declaration2) return null;
        if (declaration2.type === "TSInterfaceDeclaration" || declaration2.type === "TSTypeAliasDeclaration" || isDeclare) {
          node.exportKind = "type";
        }
        if (isDeclare) {
          this.resetStartLocation(declaration2, startPos, startLoc);
          declaration2.declare = true;
        }
        return declaration2;
      }
      parseClassId(node, isStatement) {
        if (!isStatement && this.isContextual("implements")) {
          return;
        }
        super.parseClassId(node, isStatement);
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));
        if (typeParameters) node.typeParameters = typeParameters;
      }
      parseClassPropertyAnnotation(node) {
        if (!node.optional) {
          if (this.value === "!" && this.eat(tt.prefix)) {
            node.definite = true;
          } else if (this.eat(tt.question)) {
            node.optional = true;
          }
        }
        const type2 = this.tsTryParseTypeAnnotation();
        if (type2) node.typeAnnotation = type2;
      }
      parseClassField(field) {
        const isPrivate = field.key.type === "PrivateIdentifier";
        if (isPrivate) {
          if (field.abstract) {
            this.raise(field.start, TypeScriptError.PrivateElementHasAbstract);
          }
          if (field.accessibility) {
            this.raise(
              field.start,
              TypeScriptError.PrivateElementHasAccessibility({
                modifier: field.accessibility
              })
            );
          }
          this.parseClassPropertyAnnotation(field);
        } else {
          this.parseClassPropertyAnnotation(field);
          if (this.isAmbientContext && !(field.readonly && !field.typeAnnotation) && this.match(tt.eq)) {
            this.raise(this.start, TypeScriptError.DeclareClassFieldHasInitializer);
          }
          if (field.abstract && this.match(tt.eq)) {
            const { key: key2 } = field;
            this.raise(
              this.start,
              TypeScriptError.AbstractPropertyHasInitializer({
                propertyName: key2.type === "Identifier" && !field.computed ? key2.name : `[${this.input.slice(key2.start, key2.end)}]`
              })
            );
          }
        }
        return super.parseClassField(field);
      }
      parseClassMethod(method2, isGenerator, isAsync, allowsDirectSuper) {
        const isConstructor = method2.kind === "constructor";
        const isPrivate = method2.key.type === "PrivateIdentifier";
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (isPrivate) {
          if (typeParameters) method2.typeParameters = typeParameters;
          if (method2.accessibility) {
            this.raise(
              method2.start,
              TypeScriptError.PrivateMethodsHasAccessibility({
                modifier: method2.accessibility
              })
            );
          }
        } else {
          if (typeParameters && isConstructor) {
            this.raise(typeParameters.start, TypeScriptError.ConstructorHasTypeParameters);
          }
        }
        const { declare = false, kind } = method2;
        if (declare && (kind === "get" || kind === "set")) {
          this.raise(method2.start, TypeScriptError.DeclareAccessor({ kind }));
        }
        if (typeParameters) method2.typeParameters = typeParameters;
        const key2 = method2.key;
        if (method2.kind === "constructor") {
          if (isGenerator) this.raise(key2.start, "Constructor can't be a generator");
          if (isAsync) this.raise(key2.start, "Constructor can't be an async method");
        } else if (method2.static && checkKeyName2(method2, "prototype")) {
          this.raise(key2.start, "Classes may not have a static property named prototype");
        }
        const value = method2.value = this.parseMethod(
          isGenerator,
          isAsync,
          allowsDirectSuper,
          true,
          method2
        );
        if (method2.kind === "get" && value["params"].length !== 0)
          this.raiseRecoverable(value.start, "getter should have no params");
        if (method2.kind === "set" && value["params"].length !== 1)
          this.raiseRecoverable(value.start, "setter should have exactly one param");
        if (method2.kind === "set" && value["params"][0].type === "RestElement")
          this.raiseRecoverable(value["params"][0].start, "Setter cannot use rest params");
        return this.finishNode(method2, "MethodDefinition");
      }
      isClassMethod() {
        return this.match(tt.relational);
      }
      parseClassElement(constructorAllowsSuper) {
        if (this.eat(tt.semi)) return null;
        let node = this.startNode();
        let keyName = "";
        let isGenerator = false;
        let isAsync = false;
        let kind = "method";
        let isStatic = false;
        const modifiers = [
          "declare",
          "private",
          "public",
          "protected",
          "accessor",
          "override",
          "abstract",
          "readonly",
          "static"
        ];
        const modifierMap = this.tsParseModifiers({
          modified: node,
          allowedModifiers: modifiers,
          disallowedModifiers: ["in", "out"],
          stopOnStartOfClassStaticBlock: true,
          errorTemplate: TypeScriptError.InvalidModifierOnTypeParameterPositions
        });
        isStatic = Boolean(modifierMap.static);
        const callParseClassMemberWithIsStatic = () => {
          if (this.tsIsStartOfStaticBlocks()) {
            this.next();
            this.next();
            if (this.tsHasSomeModifiers(node, modifiers)) {
              this.raise(this.start, TypeScriptError.StaticBlockCannotHaveModifier);
            }
            if (this.ecmaVersion >= 13) {
              super.parseClassStaticBlock(node);
              return node;
            }
          } else {
            const idx = this.tsTryParseIndexSignature(node);
            if (idx) {
              if (node.abstract) {
                this.raise(node.start, TypeScriptError.IndexSignatureHasAbstract);
              }
              if (node.accessibility) {
                this.raise(
                  node.start,
                  TypeScriptError.IndexSignatureHasAccessibility({
                    modifier: node.accessibility
                  })
                );
              }
              if (node.declare) {
                this.raise(node.start, TypeScriptError.IndexSignatureHasDeclare);
              }
              if (node.override) {
                this.raise(node.start, TypeScriptError.IndexSignatureHasOverride);
              }
              return idx;
            }
            if (!this.inAbstractClass && node.abstract) {
              this.raise(node.start, TypeScriptError.NonAbstractClassHasAbstractMethod);
            }
            if (node.override) {
              if (!constructorAllowsSuper) {
                this.raise(node.start, TypeScriptError.OverrideNotInSubClass);
              }
            }
            node.static = isStatic;
            if (isStatic) {
              if (!(this.isClassElementNameStart() || this.type === tt.star)) {
                keyName = "static";
              }
            }
            if (!keyName && this.ecmaVersion >= 8 && this.eatContextual("async")) {
              if ((this.isClassElementNameStart() || this.type === tt.star) && !this.canInsertSemicolon()) {
                isAsync = true;
              } else {
                keyName = "async";
              }
            }
            if (!keyName && (this.ecmaVersion >= 9 || !isAsync) && this.eat(tt.star)) {
              isGenerator = true;
            }
            if (!keyName && !isAsync && !isGenerator) {
              const lastValue = this.value;
              if (this.eatContextual("get") || this.eatContextual("set")) {
                if (this.isClassElementNameStart()) {
                  kind = lastValue;
                } else {
                  keyName = lastValue;
                }
              }
            }
            if (keyName) {
              node.computed = false;
              node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
              node.key.name = keyName;
              this.finishNode(node.key, "Identifier");
            } else {
              this.parseClassElementName(node);
            }
            this.parsePostMemberNameModifiers(node);
            if (this.isClassMethod() || this.ecmaVersion < 13 || this.type === tt.parenL || kind !== "method" || isGenerator || isAsync) {
              const isConstructor = !node.static && checkKeyName2(node, "constructor");
              const allowsDirectSuper = isConstructor && constructorAllowsSuper;
              if (isConstructor && kind !== "method")
                this.raise(node.key.start, "Constructor can't have get/set modifier");
              node.kind = isConstructor ? "constructor" : kind;
              this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
            } else {
              this.parseClassField(node);
            }
            return node;
          }
        };
        if (node.declare) {
          this.tsInAmbientContext(callParseClassMemberWithIsStatic);
        } else {
          callParseClassMemberWithIsStatic();
        }
        return node;
      }
      isClassElementNameStart() {
        if (this.tsIsIdentifier()) {
          return true;
        }
        return super.isClassElementNameStart();
      }
      parseClassSuper(node) {
        super.parseClassSuper(node);
        if (node.superClass && (this.tsMatchLeftRelational() || this.match(tt.bitShift))) {
          node.superTypeParameters = this.tsParseTypeArgumentsInExpression();
        }
        if (this.eatContextual("implements")) {
          node.implements = this.tsParseHeritageClause("implements");
        }
      }
      parseFunctionParams(node) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (typeParameters) node.typeParameters = typeParameters;
        super.parseFunctionParams(node);
      }
      // `let x: number;`
      parseVarId(decl, kind) {
        super.parseVarId(decl, kind);
        if (decl.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.value === "!" && this.eat(tt.prefix)) {
          decl.definite = true;
        }
        const type2 = this.tsTryParseTypeAnnotation();
        if (type2) {
          decl.id.typeAnnotation = type2;
          this.resetEndLocation(decl.id);
        }
      }
      // parse the return type of an async arrow function - let foo = (async (): number => {});
      parseArrowExpression(node, params, isAsync, forInit) {
        if (this.match(tt.colon)) {
          node.returnType = this.tsParseTypeAnnotation();
        }
        let oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.enterScope(functionFlags2(isAsync, false) | acornScope.SCOPE_ARROW);
        this.initFunction(node);
        const oldMaybeInArrowParameters = this.maybeInArrowParameters;
        if (this.ecmaVersion >= 8) node.async = !!isAsync;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.maybeInArrowParameters = true;
        node.params = this.toAssignableList(params, true);
        this.maybeInArrowParameters = false;
        this.parseFunctionBody(node, true, false, forInit);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        this.maybeInArrowParameters = oldMaybeInArrowParameters;
        return this.finishNode(node, "ArrowFunctionExpression");
      }
      parseMaybeAssignOrigin(forInit, refDestructuringErrors, afterLeftParse) {
        if (this.isContextual("yield")) {
          if (this.inGenerator) return this.parseYield(forInit);
          else this.exprAllowed = false;
        }
        let ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
        if (refDestructuringErrors) {
          oldParenAssign = refDestructuringErrors.parenthesizedAssign;
          oldTrailingComma = refDestructuringErrors.trailingComma;
          oldDoubleProto = refDestructuringErrors.doubleProto;
          refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
        } else {
          refDestructuringErrors = new DestructuringErrors3();
          ownDestructuringErrors = true;
        }
        let startPos = this.start, startLoc = this.startLoc;
        if (this.type === tt.parenL || tokenIsIdentifier(this.type)) {
          this.potentialArrowAt = this.start;
          this.potentialArrowInForAwait = forInit === "await";
        }
        let left = this.parseMaybeConditional(forInit, refDestructuringErrors);
        if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);
        if (this.type.isAssign) {
          let node = this.startNodeAt(startPos, startLoc);
          node.operator = this.value;
          if (this.type === tt.eq) left = this.toAssignable(left, true, refDestructuringErrors);
          if (!ownDestructuringErrors) {
            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
          }
          if (refDestructuringErrors.shorthandAssign >= left.start)
            refDestructuringErrors.shorthandAssign = -1;
          if (!this.maybeInArrowParameters) {
            if (this.type === tt.eq) this.checkLValPattern(left);
            else this.checkLValSimple(left);
          }
          node.left = left;
          this.next();
          node.right = this.parseMaybeAssign(forInit);
          if (oldDoubleProto > -1) refDestructuringErrors.doubleProto = oldDoubleProto;
          return this.finishNode(node, "AssignmentExpression");
        } else {
          if (ownDestructuringErrors) this.checkExpressionErrors(refDestructuringErrors, true);
        }
        if (oldParenAssign > -1) refDestructuringErrors.parenthesizedAssign = oldParenAssign;
        if (oldTrailingComma > -1) refDestructuringErrors.trailingComma = oldTrailingComma;
        return left;
      }
      parseMaybeAssign(forInit, refExpressionErrors, afterLeftParse) {
        let state;
        let jsx;
        let typeCast;
        if (options2?.jsx && (this.matchJsx("jsxTagStart") || this.tsMatchLeftRelational())) {
          state = this.cloneCurLookaheadState();
          jsx = this.tryParse(
            () => this.parseMaybeAssignOrigin(forInit, refExpressionErrors, afterLeftParse),
            state
          );
          if (!jsx.error) return jsx.node;
          const context2 = this.context;
          const currentContext = context2[context2.length - 1];
          const lastCurrentContext = context2[context2.length - 2];
          if (currentContext === acornTypeScript.tokContexts.tc_oTag && lastCurrentContext === acornTypeScript.tokContexts.tc_expr) {
            context2.pop();
            context2.pop();
          } else if (currentContext === acornTypeScript.tokContexts.tc_oTag || currentContext === acornTypeScript.tokContexts.tc_expr) {
            context2.pop();
          }
        }
        if (!jsx?.error && !this.tsMatchLeftRelational()) {
          return this.parseMaybeAssignOrigin(forInit, refExpressionErrors, afterLeftParse);
        }
        if (!state || this.compareLookaheadState(state, this.getCurLookaheadState())) {
          state = this.cloneCurLookaheadState();
        }
        let typeParameters;
        const arrow2 = this.tryParse((abort) => {
          typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
          const expr = this.parseMaybeAssignOrigin(forInit, refExpressionErrors, afterLeftParse);
          if (expr.type !== "ArrowFunctionExpression" || expr.extra?.parenthesized) {
            abort();
          }
          if (typeParameters?.params.length !== 0) {
            this.resetStartLocationFromNode(expr, typeParameters);
          }
          expr.typeParameters = typeParameters;
          return expr;
        }, state);
        if (!arrow2.error && !arrow2.aborted) {
          if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
          return arrow2.node;
        }
        if (!jsx) {
          assert(true);
          typeCast = this.tryParse(
            () => this.parseMaybeAssignOrigin(forInit, refExpressionErrors, afterLeftParse),
            state
          );
          if (!typeCast.error) return typeCast.node;
        }
        if (jsx?.node) {
          this.setLookaheadState(jsx.failState);
          return jsx.node;
        }
        if (arrow2.node) {
          this.setLookaheadState(arrow2.failState);
          if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
          return arrow2.node;
        }
        if (typeCast?.node) {
          this.setLookaheadState(typeCast.failState);
          return typeCast.node;
        }
        if (jsx?.thrown) throw jsx.error;
        if (arrow2.thrown) throw arrow2.error;
        if (typeCast?.thrown) throw typeCast.error;
        throw jsx?.error || arrow2.error || typeCast?.error;
      }
      parseAssignableListItem(allowModifiers) {
        const decorators = [];
        while (this.match(tokTypes2.at)) {
          decorators.push(this.parseDecorator());
        }
        const startPos = this.start;
        const startLoc = this.startLoc;
        let accessibility;
        let readonly = false;
        let override = false;
        if (allowModifiers !== void 0) {
          const modified = {};
          this.tsParseModifiers({
            modified,
            allowedModifiers: ["public", "private", "protected", "override", "readonly"]
          });
          accessibility = modified.accessibility;
          override = modified.override;
          readonly = modified.readonly;
          if (allowModifiers === false && (accessibility || readonly || override)) {
            this.raise(startLoc.column, TypeScriptError.UnexpectedParameterModifier);
          }
        }
        const left = this.parseMaybeDefault(startPos, startLoc);
        this.parseBindingListItem(left);
        const elt = this.parseMaybeDefault(left["start"], left["loc"], left);
        if (decorators.length) {
          elt.decorators = decorators;
        }
        if (accessibility || readonly || override) {
          const pp2 = this.startNodeAt(startPos, startLoc);
          if (accessibility) pp2.accessibility = accessibility;
          if (readonly) pp2.readonly = readonly;
          if (override) pp2.override = override;
          if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
            this.raise(pp2.start, TypeScriptError.UnsupportedParameterPropertyKind);
          }
          pp2.parameter = elt;
          return this.finishNode(pp2, "TSParameterProperty");
        }
        return elt;
      }
      // AssignmentPattern
      checkLValInnerPattern(expr, bindingType = acornScope.BIND_NONE, checkClashes) {
        switch (expr.type) {
          case "TSParameterProperty":
            this.checkLValInnerPattern(expr.parameter, bindingType, checkClashes);
            break;
          default: {
            super.checkLValInnerPattern(expr, bindingType, checkClashes);
            break;
          }
        }
      }
      // Allow type annotations inside of a parameter list.
      parseBindingListItem(param) {
        if (this.eat(tt.question)) {
          if (param.type !== "Identifier" && !this.isAmbientContext && !this.inType) {
            this.raise(param.start, TypeScriptError.PatternIsOptional);
          }
          param.optional = true;
        }
        const type2 = this.tsTryParseTypeAnnotation();
        if (type2) param.typeAnnotation = type2;
        this.resetEndLocation(param);
        return param;
      }
      isAssignable(node, isBinding) {
        switch (node.type) {
          case "TSTypeCastExpression":
            return this.isAssignable(node.expression, isBinding);
          case "TSParameterProperty":
            return true;
          case "Identifier":
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
            return true;
          case "ObjectExpression": {
            const last = node.properties.length - 1;
            return node.properties.every((prop3, i) => {
              return prop3.type !== "ObjectMethod" && (i === last || prop3.type !== "SpreadElement") && this.isAssignable(prop3);
            });
          }
          case "Property":
          case "ObjectProperty":
            return this.isAssignable(node.value);
          case "SpreadElement":
            return this.isAssignable(node.argument);
          case "ArrayExpression":
            return node.elements.every(
              (element3) => element3 === null || this.isAssignable(element3)
            );
          case "AssignmentExpression":
            return node.operator === "=";
          case "ParenthesizedExpression":
            return this.isAssignable(node.expression);
          case "MemberExpression":
          case "OptionalMemberExpression":
            return !isBinding;
          default:
            return false;
        }
      }
      toAssignable(node, isBinding = false, refDestructuringErrors = new DestructuringErrors3()) {
        switch (node.type) {
          case "ParenthesizedExpression":
            return this.toAssignableParenthesizedExpression(
              node,
              isBinding,
              refDestructuringErrors
            );
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
            if (isBinding) {
            } else {
              this.raise(node.start, TypeScriptError.UnexpectedTypeCastInParameter);
            }
            return this.toAssignable(node.expression, isBinding, refDestructuringErrors);
          case "MemberExpression":
            break;
          case "AssignmentExpression":
            if (!isBinding && node.left.type === "TSTypeCastExpression") {
              node.left = this.typeCastToParameter(node.left);
            }
            return super.toAssignable(node, isBinding, refDestructuringErrors);
          case "TSTypeCastExpression": {
            return this.typeCastToParameter(node);
          }
          default:
            return super.toAssignable(node, isBinding, refDestructuringErrors);
        }
        return node;
      }
      toAssignableParenthesizedExpression(node, isBinding, refDestructuringErrors) {
        switch (node.expression.type) {
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
          case "ParenthesizedExpression":
            return this.toAssignable(node.expression, isBinding, refDestructuringErrors);
          default:
            return super.toAssignable(node, isBinding, refDestructuringErrors);
        }
      }
      parseBindingAtom() {
        switch (this.type) {
          case tt._this:
            return this.parseIdent(
              /* liberal */
              true
            );
          default:
            return super.parseBindingAtom();
        }
      }
      shouldParseArrow(exprList) {
        let shouldParseArrowRes;
        if (this.match(tt.colon)) {
          shouldParseArrowRes = exprList.every((expr) => this.isAssignable(expr, true));
        } else {
          shouldParseArrowRes = !this.canInsertSemicolon();
        }
        if (shouldParseArrowRes) {
          if (this.match(tt.colon)) {
            const result = this.tryParse((abort) => {
              const returnType = this.tsParseTypeOrTypePredicateAnnotation(tt.colon);
              if (this.canInsertSemicolon() || !this.match(tt.arrow)) abort();
              return returnType;
            });
            if (result.aborted) {
              this.shouldParseArrowReturnType = void 0;
              return false;
            }
            if (!result.thrown) {
              if (result.error) this.setLookaheadState(result.failState);
              this.shouldParseArrowReturnType = result.node;
            }
          }
          if (!this.match(tt.arrow)) {
            this.shouldParseArrowReturnType = void 0;
            return false;
          }
          return true;
        }
        this.shouldParseArrowReturnType = void 0;
        return shouldParseArrowRes;
      }
      parseParenArrowList(startPos, startLoc, exprList, forInit) {
        const node = this.startNodeAt(startPos, startLoc);
        node.returnType = this.shouldParseArrowReturnType;
        this.shouldParseArrowReturnType = void 0;
        return this.parseArrowExpression(node, exprList, false, forInit);
      }
      parseParenAndDistinguishExpression(canBeArrow, forInit) {
        let startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.ecmaVersion >= 8;
        if (this.ecmaVersion >= 6) {
          const oldMaybeInArrowParameters = this.maybeInArrowParameters;
          this.maybeInArrowParameters = true;
          this.next();
          let innerStartPos = this.start, innerStartLoc = this.startLoc;
          let exprList = [], first2 = true, lastIsComma = false;
          let refDestructuringErrors = new DestructuringErrors3(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
          this.yieldPos = 0;
          this.awaitPos = 0;
          while (this.type !== tt.parenR) {
            first2 ? first2 = false : this.expect(tt.comma);
            if (allowTrailingComma && this.afterTrailingComma(tt.parenR, true)) {
              lastIsComma = true;
              break;
            } else if (this.type === tt.ellipsis) {
              spreadStart = this.start;
              exprList.push(this.parseParenItem(this.parseRestBinding()));
              if (this.type === tt.comma) {
                this.raise(this.start, "Comma is not permitted after the rest element");
              }
              break;
            } else {
              exprList.push(
                this.parseMaybeAssign(forInit, refDestructuringErrors, this.parseParenItem)
              );
            }
          }
          let innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
          this.expect(tt.parenR);
          this.maybeInArrowParameters = oldMaybeInArrowParameters;
          if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(tt.arrow)) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
          }
          if (!exprList.length || lastIsComma) this.unexpected(this.lastTokStart);
          if (spreadStart) this.unexpected(spreadStart);
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          if (exprList.length > 1) {
            val = this.startNodeAt(innerStartPos, innerStartLoc);
            val.expressions = exprList;
            this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
          } else {
            val = exprList[0];
          }
        } else {
          val = this.parseParenExpression();
        }
        if (this.options.preserveParens) {
          let par2 = this.startNodeAt(startPos, startLoc);
          par2.expression = val;
          return this.finishNode(par2, "ParenthesizedExpression");
        } else {
          return val;
        }
      }
      parseTaggedTemplateExpression(base, startPos, startLoc, optionalChainMember) {
        const node = this.startNodeAt(startPos, startLoc);
        node.tag = base;
        node.quasi = this.parseTemplate({ isTagged: true });
        if (optionalChainMember) {
          this.raise(
            startPos,
            "Tagged Template Literals are not allowed in optionalChain."
          );
        }
        return this.finishNode(node, "TaggedTemplateExpression");
      }
      shouldParseAsyncArrow() {
        if (this.match(tt.colon)) {
          const result = this.tryParse((abort) => {
            const returnType = this.tsParseTypeOrTypePredicateAnnotation(tt.colon);
            if (this.canInsertSemicolon() || !this.match(tt.arrow)) abort();
            return returnType;
          });
          if (result.aborted) {
            this.shouldParseAsyncArrowReturnType = void 0;
            return false;
          }
          if (!result.thrown) {
            if (result.error) this.setLookaheadState(result.failState);
            this.shouldParseAsyncArrowReturnType = result.node;
            return !this.canInsertSemicolon() && this.eat(tt.arrow);
          }
        } else {
          return !this.canInsertSemicolon() && this.eat(tt.arrow);
        }
      }
      parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit) {
        const arrN = this.startNodeAt(startPos, startLoc);
        arrN.returnType = this.shouldParseAsyncArrowReturnType;
        this.shouldParseAsyncArrowReturnType = void 0;
        return this.parseArrowExpression(arrN, exprList, true, forInit);
      }
      parseExprList(close2, allowTrailingComma, allowEmpty, refDestructuringErrors) {
        let elts = [], first2 = true;
        while (!this.eat(close2)) {
          if (!first2) {
            this.expect(tt.comma);
            if (allowTrailingComma && this.afterTrailingComma(close2)) break;
          } else first2 = false;
          let elt;
          if (allowEmpty && this.type === tt.comma) elt = null;
          else if (this.type === tt.ellipsis) {
            elt = this.parseSpread(refDestructuringErrors);
            if (this.maybeInArrowParameters && this.match(tt.colon)) {
              elt.typeAnnotation = this.tsParseTypeAnnotation();
            }
            if (refDestructuringErrors && this.type === tt.comma && refDestructuringErrors.trailingComma < 0)
              refDestructuringErrors.trailingComma = this.start;
          } else {
            elt = this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem);
          }
          elts.push(elt);
        }
        return elts;
      }
      parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
        let _optionalChained = optionalChained;
        if (!this.hasPrecedingLineBreak() && // NODE: replace bang
        this.value === "!" && this.match(tt.prefix)) {
          this.exprAllowed = false;
          this.next();
          const nonNullExpression = this.startNodeAt(startPos, startLoc);
          nonNullExpression.expression = base;
          base = this.finishNode(nonNullExpression, "TSNonNullExpression");
          return base;
        }
        let isOptionalCall = false;
        if (this.match(tt.questionDot) && this.lookaheadCharCode() === 60) {
          if (noCalls) {
            return base;
          }
          base.optional = true;
          _optionalChained = isOptionalCall = true;
          this.next();
        }
        if (this.tsMatchLeftRelational() || this.match(tt.bitShift)) {
          let missingParenErrorLoc;
          const result = this.tsTryParseAndCatch(() => {
            if (!noCalls && this.atPossibleAsyncArrow(base)) {
              const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(
                startPos,
                startLoc,
                forInit
              );
              if (asyncArrowFn) {
                base = asyncArrowFn;
                return base;
              }
            }
            const typeArguments = this.tsParseTypeArgumentsInExpression();
            if (!typeArguments) return base;
            if (isOptionalCall && !this.match(tt.parenL)) {
              missingParenErrorLoc = this.curPosition();
              return base;
            }
            if (tokenIsTemplate(this.type) || this.type === tt.backQuote) {
              const result2 = this.parseTaggedTemplateExpression(
                base,
                startPos,
                startLoc,
                _optionalChained
              );
              result2.typeArguments = typeArguments;
              return result2;
            }
            if (!noCalls && this.eat(tt.parenL)) {
              let refDestructuringErrors = new DestructuringErrors3();
              const node2 = this.startNodeAt(startPos, startLoc);
              node2.callee = base;
              node2.arguments = this.parseExprList(
                tt.parenR,
                this.ecmaVersion >= 8,
                false,
                refDestructuringErrors
              );
              this.tsCheckForInvalidTypeCasts(node2.arguments);
              node2.typeArguments = typeArguments;
              if (_optionalChained) {
                node2.optional = isOptionalCall;
              }
              this.checkExpressionErrors(refDestructuringErrors, true);
              base = this.finishNode(node2, "CallExpression");
              return base;
            }
            const tokenType = this.type;
            if (
              // a<b>>c is not (a<b>)>c, but a<(b>>c)
              this.tsMatchRightRelational() || // a<b>>>c is not (a<b>)>>c, but a<(b>>>c)
              tokenType === tt.bitShift || // a<b>c is (a<b)>c
              tokenType !== tt.parenL && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak()
            ) {
              return;
            }
            const node = this.startNodeAt(startPos, startLoc);
            node.expression = base;
            node.typeArguments = typeArguments;
            return this.finishNode(node, "TSInstantiationExpression");
          });
          if (missingParenErrorLoc) {
            this.unexpected(missingParenErrorLoc);
          }
          if (result) {
            if (result.type === "TSInstantiationExpression" && (this.match(tt.dot) || this.match(tt.questionDot) && this.lookaheadCharCode() !== 40)) {
              this.raise(
                this.start,
                TypeScriptError.InvalidPropertyAccessAfterInstantiationExpression
              );
            }
            base = result;
            return base;
          }
        }
        let optionalSupported = this.ecmaVersion >= 11;
        let optional = optionalSupported && this.eat(tt.questionDot);
        if (noCalls && optional)
          this.raise(
            this.lastTokStart,
            "Optional chaining cannot appear in the callee of new expressions"
          );
        let computed = this.eat(tt.bracketL);
        if (computed || optional && this.type !== tt.parenL && this.type !== tt.backQuote || this.eat(tt.dot)) {
          let node = this.startNodeAt(startPos, startLoc);
          node.object = base;
          if (computed) {
            node.property = this.parseExpression();
            this.expect(tt.bracketR);
          } else if (this.type === tt.privateId && base.type !== "Super") {
            node.property = this.parsePrivateIdent();
          } else {
            node.property = this.parseIdent(this.options.allowReserved !== "never");
          }
          node.computed = !!computed;
          if (optionalSupported) {
            node.optional = optional;
          }
          base = this.finishNode(node, "MemberExpression");
        } else if (!noCalls && this.eat(tt.parenL)) {
          const oldMaybeInArrowParameters = this.maybeInArrowParameters;
          this.maybeInArrowParameters = true;
          let refDestructuringErrors = new DestructuringErrors3(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
          this.yieldPos = 0;
          this.awaitPos = 0;
          this.awaitIdentPos = 0;
          let exprList = this.parseExprList(
            tt.parenR,
            this.ecmaVersion >= 8,
            false,
            refDestructuringErrors
          );
          if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            if (this.awaitIdentPos > 0)
              this.raise(
                this.awaitIdentPos,
                "Cannot use 'await' as identifier inside an async function"
              );
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            this.awaitIdentPos = oldAwaitIdentPos;
            base = this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
          } else {
            this.checkExpressionErrors(refDestructuringErrors, true);
            this.yieldPos = oldYieldPos || this.yieldPos;
            this.awaitPos = oldAwaitPos || this.awaitPos;
            this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
            let node = this.startNodeAt(startPos, startLoc);
            node.callee = base;
            node.arguments = exprList;
            if (optionalSupported) {
              node.optional = optional;
            }
            base = this.finishNode(node, "CallExpression");
          }
          this.maybeInArrowParameters = oldMaybeInArrowParameters;
        } else if (this.type === tt.backQuote) {
          if (optional || _optionalChained) {
            this.raise(
              this.start,
              "Optional chaining cannot appear in the tag of tagged template expressions"
            );
          }
          let node = this.startNodeAt(startPos, startLoc);
          node.tag = base;
          node.quasi = this.parseTemplate({ isTagged: true });
          base = this.finishNode(node, "TaggedTemplateExpression");
        }
        return base;
      }
      parseGetterSetter(prop3) {
        prop3.kind = prop3.key.name;
        this.parsePropertyName(prop3);
        prop3.value = this.parseMethod(false);
        let paramCount = prop3.kind === "get" ? 0 : 1;
        const firstParam = prop3.value.params[0];
        const hasContextParam = firstParam && this.isThisParam(firstParam);
        paramCount = hasContextParam ? paramCount + 1 : paramCount;
        if (prop3.value.params.length !== paramCount) {
          let start2 = prop3.value.start;
          if (prop3.kind === "get") this.raiseRecoverable(start2, "getter should have no params");
          else this.raiseRecoverable(start2, "setter should have exactly one param");
        } else {
          if (prop3.kind === "set" && prop3.value.params[0].type === "RestElement")
            this.raiseRecoverable(prop3.value.params[0].start, "Setter cannot use rest params");
        }
      }
      parseProperty(isPattern, refDestructuringErrors) {
        if (!isPattern) {
          let decorators = [];
          if (this.match(tokTypes2.at)) {
            while (this.match(tokTypes2.at)) {
              decorators.push(this.parseDecorator());
            }
          }
          const property = super.parseProperty(isPattern, refDestructuringErrors);
          if (property.type === "SpreadElement") {
            if (decorators.length)
              this.raise(property.start, DecoratorsError.SpreadElementDecorator);
          }
          if (decorators.length) {
            property.decorators = decorators;
            decorators = [];
          }
          return property;
        }
        return super.parseProperty(isPattern, refDestructuringErrors);
      }
      parseCatchClauseParam() {
        const param = this.parseBindingAtom();
        let simple = param.type === "Identifier";
        this.enterScope(simple ? acornScope.SCOPE_SIMPLE_CATCH : 0);
        this.checkLValPattern(
          param,
          simple ? acornScope.BIND_SIMPLE_CATCH : acornScope.BIND_LEXICAL
        );
        const type2 = this.tsTryParseTypeAnnotation();
        if (type2) {
          param.typeAnnotation = type2;
          this.resetEndLocation(param);
        }
        this.expect(tt.parenR);
        return param;
      }
      parseClass(node, isStatement) {
        const oldInAbstractClass = this.inAbstractClass;
        this.inAbstractClass = !!node.abstract;
        try {
          this.next();
          this.takeDecorators(node);
          const oldStrict = this.strict;
          this.strict = true;
          this.parseClassId(node, isStatement);
          this.parseClassSuper(node);
          const privateNameMap = this.enterClassBody();
          const classBody = this.startNode();
          let hadConstructor = false;
          classBody.body = [];
          let decorators = [];
          this.expect(tt.braceL);
          while (this.type !== tt.braceR) {
            if (this.match(tokTypes2.at)) {
              decorators.push(this.parseDecorator());
              continue;
            }
            const element3 = this.parseClassElement(node.superClass !== null);
            if (decorators.length) {
              element3.decorators = decorators;
              this.resetStartLocationFromNode(element3, decorators[0]);
              decorators = [];
            }
            if (element3) {
              classBody.body.push(element3);
              if (element3.type === "MethodDefinition" && element3.kind === "constructor" && element3.value.type === "FunctionExpression") {
                if (hadConstructor) {
                  this.raiseRecoverable(element3.start, "Duplicate constructor in the same class");
                }
                hadConstructor = true;
                if (element3.decorators && element3.decorators.length > 0) {
                  this.raise(element3.start, DecoratorsError.DecoratorConstructor);
                }
              } else if (element3.key && element3.key.type === "PrivateIdentifier" && isPrivateNameConflicted2(privateNameMap, element3)) {
                this.raiseRecoverable(
                  element3.key.start,
                  `Identifier '#${element3.key.name}' has already been declared`
                );
              }
            }
          }
          this.strict = oldStrict;
          this.next();
          if (decorators.length) {
            this.raise(this.start, DecoratorsError.TrailingDecorator);
          }
          node.body = this.finishNode(classBody, "ClassBody");
          this.exitClassBody();
          return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
        } finally {
          this.inAbstractClass = oldInAbstractClass;
        }
      }
      parseClassFunctionParams() {
        const typeParameters = this.tsTryParseTypeParameters();
        let params = this.parseBindingList(tt.parenR, false, this.ecmaVersion >= 8, true);
        if (typeParameters) params.typeParameters = typeParameters;
        return params;
      }
      parseMethod(isGenerator, isAsync, allowDirectSuper, inClassScope, method2) {
        let node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.initFunction(node);
        if (this.ecmaVersion >= 6) node.generator = isGenerator;
        if (this.ecmaVersion >= 8) node.async = !!isAsync;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(
          functionFlags2(isAsync, node.generator) | acornScope.SCOPE_SUPER | (allowDirectSuper ? acornScope.SCOPE_DIRECT_SUPER : 0)
        );
        this.expect(tt.parenL);
        node.params = this.parseClassFunctionParams();
        this.checkYieldAwaitInDefaultParams();
        this.parseFunctionBody(node, false, true, false, {
          isClassMethod: inClassScope
        });
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        if (method2 && method2.abstract) {
          const hasBody = !!node.body;
          if (hasBody) {
            const { key: key2 } = method2;
            this.raise(
              method2.start,
              TypeScriptError.AbstractMethodHasImplementation({
                methodName: key2.type === "Identifier" && !method2.computed ? key2.name : `[${this.input.slice(key2.start, key2.end)}]`
              })
            );
          }
        }
        return this.finishNode(node, "FunctionExpression");
      }
      static parse(input, options22) {
        if (options22.locations === false) {
          throw new Error(`You have to enable options.locations while using acorn-typescript`);
        } else {
          options22.locations = true;
        }
        const parser2 = new this(options22, input);
        if (dts) {
          parser2.isAmbientContext = true;
        }
        return parser2.parse();
      }
      static parseExpressionAt(input, pos, options22) {
        if (options22.locations === false) {
          throw new Error(`You have to enable options.locations while using acorn-typescript`);
        } else {
          options22.locations = true;
        }
        const parser2 = new this(options22, input, pos);
        if (dts) {
          parser2.isAmbientContext = true;
        }
        parser2.nextToken();
        return parser2.parseExpression();
      }
      parseImportSpecifier() {
        const isMaybeTypeOnly = this.ts_isContextual(tokTypes2.type);
        if (isMaybeTypeOnly) {
          let node = this.startNode();
          node.imported = this.parseModuleExportName();
          this.parseTypeOnlyImportExportSpecifier(
            node,
            /* isImport */
            true,
            this.importOrExportOuterKind === "type"
          );
          return this.finishNode(node, "ImportSpecifier");
        } else {
          const node = super.parseImportSpecifier();
          node.importKind = "value";
          return node;
        }
      }
      parseExportSpecifier(exports) {
        const isMaybeTypeOnly = this.ts_isContextual(tokTypes2.type);
        const isString = this.match(tt.string);
        if (!isString && isMaybeTypeOnly) {
          let node = this.startNode();
          node.local = this.parseModuleExportName();
          this.parseTypeOnlyImportExportSpecifier(
            node,
            /* isImport */
            false,
            this.importOrExportOuterKind === "type"
          );
          this.finishNode(node, "ExportSpecifier");
          this.checkExport(exports, node.exported, node.exported.start);
          return node;
        } else {
          const node = super.parseExportSpecifier(exports);
          node.exportKind = "value";
          return node;
        }
      }
      parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {
        const leftOfAsKey = isImport ? "imported" : "local";
        const rightOfAsKey = isImport ? "local" : "exported";
        let leftOfAs = node[leftOfAsKey];
        let rightOfAs;
        let hasTypeSpecifier = false;
        let canParseAsKeyword = true;
        const loc = leftOfAs.start;
        if (this.isContextual("as")) {
          const firstAs = this.parseIdent();
          if (this.isContextual("as")) {
            const secondAs = this.parseIdent();
            if (tokenIsKeywordOrIdentifier(this.type)) {
              hasTypeSpecifier = true;
              leftOfAs = firstAs;
              rightOfAs = isImport ? this.parseIdent() : this.parseModuleExportName();
              canParseAsKeyword = false;
            } else {
              rightOfAs = secondAs;
              canParseAsKeyword = false;
            }
          } else if (tokenIsKeywordOrIdentifier(this.type)) {
            canParseAsKeyword = false;
            rightOfAs = isImport ? this.parseIdent() : this.parseModuleExportName();
          } else {
            hasTypeSpecifier = true;
            leftOfAs = firstAs;
          }
        } else if (tokenIsKeywordOrIdentifier(this.type)) {
          hasTypeSpecifier = true;
          if (isImport) {
            leftOfAs = super.parseIdent(true);
            if (!this.isContextual("as")) {
              this.checkUnreserved(leftOfAs);
            }
          } else {
            leftOfAs = this.parseModuleExportName();
          }
        }
        if (hasTypeSpecifier && isInTypeOnlyImportExport) {
          this.raise(
            loc,
            isImport ? TypeScriptError.TypeModifierIsUsedInTypeImports : TypeScriptError.TypeModifierIsUsedInTypeExports
          );
        }
        node[leftOfAsKey] = leftOfAs;
        node[rightOfAsKey] = rightOfAs;
        const kindKey = isImport ? "importKind" : "exportKind";
        node[kindKey] = hasTypeSpecifier ? "type" : "value";
        if (canParseAsKeyword && this.eatContextual("as")) {
          node[rightOfAsKey] = isImport ? this.parseIdent() : this.parseModuleExportName();
        }
        if (!node[rightOfAsKey]) {
          node[rightOfAsKey] = this.copyNode(node[leftOfAsKey]);
        }
        if (isImport) {
          this.checkLValSimple(node[rightOfAsKey], acornScope.BIND_LEXICAL);
        }
      }
      raiseCommonCheck(pos, message2, recoverable) {
        switch (message2) {
          case "Comma is not permitted after the rest element": {
            if (this.isAmbientContext && this.match(tt.comma) && this.lookaheadCharCode() === 41) {
              this.next();
              return;
            } else {
              return super.raise(pos, message2);
            }
          }
        }
        return recoverable ? super.raiseRecoverable(pos, message2) : super.raise(pos, message2);
      }
      raiseRecoverable(pos, message2) {
        return this.raiseCommonCheck(pos, message2, true);
      }
      raise(pos, message2) {
        return this.raiseCommonCheck(pos, message2, true);
      }
      updateContext(prevType) {
        const { type: type2 } = this;
        if (type2 == tt.braceL) {
          var curContext = this.curContext();
          if (curContext == tsTokContexts.tc_oTag) this.context.push(tokContexts.b_expr);
          else if (curContext == tsTokContexts.tc_expr) this.context.push(tokContexts.b_tmpl);
          else super.updateContext(prevType);
          this.exprAllowed = true;
        } else if (type2 === tt.slash && prevType === tokTypes2.jsxTagStart) {
          this.context.length -= 2;
          this.context.push(tsTokContexts.tc_cTag);
          this.exprAllowed = false;
        } else {
          return super.updateContext(prevType);
        }
      }
      // Parses JSX opening tag starting after '<'.
      jsx_parseOpeningElementAt(startPos, startLoc) {
        let node = this.startNodeAt(startPos, startLoc);
        let nodeName = this.jsx_parseElementName();
        if (nodeName) node.name = nodeName;
        if (this.match(tt.relational) || this.match(tt.bitShift)) {
          const typeArguments = this.tsTryParseAndCatch(
            () => this.tsParseTypeArgumentsInExpression()
          );
          if (typeArguments) node.typeArguments = typeArguments;
        }
        node.attributes = [];
        while (this.type !== tt.slash && this.type !== tokTypes2.jsxTagEnd)
          node.attributes.push(this.jsx_parseAttribute());
        node.selfClosing = this.eat(tt.slash);
        this.expect(tokTypes2.jsxTagEnd);
        return this.finishNode(node, nodeName ? "JSXOpeningElement" : "JSXOpeningFragment");
      }
      enterScope(flags) {
        if (flags === TS_SCOPE_TS_MODULE) {
          this.importsStack.push([]);
        }
        super.enterScope(flags);
        const scope = super.currentScope();
        scope.types = [];
        scope.enums = [];
        scope.constEnums = [];
        scope.classes = [];
        scope.exportOnlyBindings = [];
      }
      exitScope() {
        const scope = super.currentScope();
        if (scope.flags === TS_SCOPE_TS_MODULE) {
          this.importsStack.pop();
        }
        super.exitScope();
      }
      hasImport(name2, allowShadow) {
        const len = this.importsStack.length;
        if (this.importsStack[len - 1].indexOf(name2) > -1) {
          return true;
        }
        if (!allowShadow && len > 1) {
          for (let i = 0; i < len - 1; i++) {
            if (this.importsStack[i].indexOf(name2) > -1) return true;
          }
        }
        return false;
      }
      maybeExportDefined(scope, name2) {
        if (this.inModule && scope.flags & acornScope.SCOPE_TOP) {
          this.undefinedExports.delete(name2);
        }
      }
      declareName(name2, bindingType, pos) {
        if (bindingType & acornScope.BIND_FLAGS_TS_IMPORT) {
          if (this.hasImport(name2, true)) {
            this.raise(pos, `Identifier '${name2}' has already been declared.`);
          }
          this.importsStack[this.importsStack.length - 1].push(name2);
          return;
        }
        const scope = this.currentScope();
        if (bindingType & acornScope.BIND_FLAGS_TS_EXPORT_ONLY) {
          this.maybeExportDefined(scope, name2);
          scope.exportOnlyBindings.push(name2);
          return;
        }
        if (bindingType === acornScope.BIND_TS_TYPE || bindingType === acornScope.BIND_TS_INTERFACE) {
          if (bindingType === acornScope.BIND_TS_TYPE && scope.types.includes(name2)) {
            this.raise(pos, `type '${name2}' has already been declared.`);
          }
          scope.types.push(name2);
        } else {
          super.declareName(name2, bindingType, pos);
        }
        if (bindingType & acornScope.BIND_FLAGS_TS_ENUM) scope.enums.push(name2);
        if (bindingType & acornScope.BIND_FLAGS_TS_CONST_ENUM) scope.constEnums.push(name2);
        if (bindingType & acornScope.BIND_FLAGS_CLASS) scope.classes.push(name2);
      }
      checkLocalExport(id2) {
        const { name: name2 } = id2;
        if (this.hasImport(name2)) return;
        const len = this.scopeStack.length;
        for (let i = len - 1; i >= 0; i--) {
          const scope = this.scopeStack[i];
          if (scope.types.indexOf(name2) > -1 || scope.exportOnlyBindings.indexOf(name2) > -1) return;
        }
        super.checkLocalExport(id2);
      }
    }
    return TypeScriptParser;
  };
}

// node_modules/.deno/svelte@5.43.8/node_modules/svelte/src/compiler/phases/1-parse/acorn.js
var ParserWithTS = Parser.extend(tsPlugin());
function parse4(source2, comments, typescript, is_script) {
  const parser2 = typescript ? ParserWithTS : Parser;
  const { onComment, add_comments } = get_comment_handlers(
    source2,
    /** @type {CommentWithLocation[]} */
    comments
  );
  const parse_statement = parser2.prototype.parseStatement;
  if (is_script) {
    parser2.prototype.parseStatement = function(...args) {
      const v = parse_statement.call(this, ...args);
      this.undefinedExports = {};
      return v;
    };
  }
  let ast2;
  try {
    ast2 = parser2.parse(source2, {
      onComment,
      sourceType: "module",
      ecmaVersion: 16,
      locations: true
    });
  } finally {
    if (is_script) {
      parser2.prototype.parseStatement = parse_statement;
    }
  }
  add_comments(ast2);
  return (
    /** @type {Program} */
    ast2
  );
}
function parse_expression_at(source2, comments, typescript, index2) {
  const parser2 = typescript ? ParserWithTS : Parser;
  const { onComment, add_comments } = get_comment_handlers(
    source2,
    /** @type {CommentWithLocation[]} */
    comments,
    index2
  );
  const ast2 = parser2.parseExpressionAt(source2, index2, {
    onComment,
    sourceType: "module",
    ecmaVersion: 16,
    locations: true
  });
  add_comments(ast2);
  return ast2;
}
function get_comment_handlers(source2, comments, index2 = 0) {
  return {
    /**
     * @param {boolean} block
     * @param {string} value
     * @param {number} start
     * @param {number} end
     * @param {import('acorn').Position} [start_loc]
     * @param {import('acorn').Position} [end_loc]
     */
    onComment: (block3, value, start2, end2, start_loc, end_loc) => {
      if (block3 && /\n/.test(value)) {
        let a = start2;
        while (a > 0 && source2[a - 1] !== "\n") a -= 1;
        let b = a;
        while (/[ \t]/.test(source2[b])) b += 1;
        const indentation = source2.slice(a, b);
        value = value.replace(new RegExp(`^${indentation}`, "gm"), "");
      }
      comments.push({
        type: block3 ? "Block" : "Line",
        value,
        start: start2,
        end: end2,
        loc: {
          start: (
            /** @type {import('acorn').Position} */
            start_loc
          ),
          end: (
            /** @type {import('acorn').Position} */
            end_loc
          )
        }
      });
    },
    /** @param {acorn.Node & { leadingComments?: CommentWithLocation[]; trailingComments?: CommentWithLocation[]; }} ast */
    add_comments(ast2) {
      if (comments.length === 0) return;
      comments = comments.filter((comment2) => comment2.start >= index2).map(({ type: type2, value, start: start2, end: end2 }) => ({ type: type2, value, start: start2, end: end2 }));
      walk(ast2, null, {
        _(node, { next: next2, path: path2 }) {
          let comment2;
          while (comments[0] && comments[0].start < node.start) {
            comment2 = /** @type {CommentWithLocation} */
            comments.shift();
            (node.leadingComments ||= []).push(comment2);
          }
          next2();
          if (comments[0]) {
            const parent = (
              /** @type {any} */
              path2.at(-1)
            );
            if (parent === void 0 || node.end !== parent.end) {
              const slice2 = source2.slice(node.end, comments[0].start);
              const is_last_in_body = (parent?.type === "BlockStatement" || parent?.type === "Program") && parent.body.indexOf(node) === parent.body.length - 1 || parent?.type === "ArrayExpression" && parent.elements.indexOf(node) === parent.elements.length - 1 || parent?.type === "ObjectExpression" && parent.properties.indexOf(node) === parent.properties.length - 1;
              if (is_last_in_body) {
                let end2 = node.end;
                while (comments.length) {
                  const comment3 = comments[0];
                  if (parent && comment3.start >= parent.end) break;
                  (node.trailingComments ||= []).push(comment3);
                  comments.shift();
                  end2 = comment3.end;
                }
              } else if (node.end <= comments[0].start && /^[,) \t]*$/.test(slice2)) {
                node.trailingComments = [
                  /** @type {CommentWithLocation} */
                  comments.shift()
                ];
              }
            }
          }
        }
      });
      if (comments.length > 0 && (comments[0].start >= ast2.end || ast2.type === "Program")) {
        (ast2.trailingComments ||= []).push(...comments.splice(0));
      }
    }
  };
}

// node_modules/.deno/svelte@5.43.8/node_modules/svelte/src/compiler/errors.js
var InternalCompileError = class extends Error {
  message = "";
  // ensure this property is enumerable
  #diagnostic;
  /**
   * @param {string} code
   * @param {string} message
   * @param {[number, number] | undefined} position
   */
  constructor(code2, message2, position2) {
    super(message2);
    this.stack = "";
    this.#diagnostic = new CompileDiagnostic(code2, message2, position2);
    Object.assign(this, this.#diagnostic);
    this.name = "CompileError";
  }
  toString() {
    return this.#diagnostic.toString();
  }
  toJSON() {
    return this.#diagnostic.toJSON();
  }
};
function e(node, code2, message2) {
  const start2 = typeof node === "number" ? node : node?.start;
  const end2 = typeof node === "number" ? node : node?.end;
  throw new InternalCompileError(code2, message2, start2 !== void 0 ? [start2, end2 ?? start2] : void 0);
}
function options_invalid_value(node, details) {
  e(node, "options_invalid_value", `Invalid compiler option: ${details}
https://svelte.dev/e/options_invalid_value`);
}
function options_removed(node, details) {
  e(node, "options_removed", `Invalid compiler option: ${details}
https://svelte.dev/e/options_removed`);
}
function options_unrecognised(node, keypath) {
  e(node, "options_unrecognised", `Unrecognised compiler option ${keypath}
https://svelte.dev/e/options_unrecognised`);
}
function css_empty_declaration(node) {
  e(node, "css_empty_declaration", `Declaration cannot be empty
https://svelte.dev/e/css_empty_declaration`);
}
function css_expected_identifier(node) {
  e(node, "css_expected_identifier", `Expected a valid CSS identifier
https://svelte.dev/e/css_expected_identifier`);
}
function css_selector_invalid(node) {
  e(node, "css_selector_invalid", `Invalid selector
https://svelte.dev/e/css_selector_invalid`);
}
function attribute_duplicate(node) {
  e(node, "attribute_duplicate", `Attributes need to be unique
https://svelte.dev/e/attribute_duplicate`);
}
function attribute_empty_shorthand(node) {
  e(node, "attribute_empty_shorthand", `Attribute shorthand cannot be empty
https://svelte.dev/e/attribute_empty_shorthand`);
}
function block_duplicate_clause(node, name2) {
  e(node, "block_duplicate_clause", `${name2} cannot appear more than once within a block
https://svelte.dev/e/block_duplicate_clause`);
}
function block_invalid_continuation_placement(node) {
  e(node, "block_invalid_continuation_placement", `{:...} block is invalid at this position (did you forget to close the preceding element or block?)
https://svelte.dev/e/block_invalid_continuation_placement`);
}
function block_invalid_elseif(node) {
  e(node, "block_invalid_elseif", `'elseif' should be 'else if'
https://svelte.dev/e/block_invalid_elseif`);
}
function block_invalid_placement(node, name2, location) {
  e(node, "block_invalid_placement", `{#${name2} ...} block cannot be ${location}
https://svelte.dev/e/block_invalid_placement`);
}
function block_unclosed(node) {
  e(node, "block_unclosed", `Block was left open
https://svelte.dev/e/block_unclosed`);
}
function block_unexpected_close(node) {
  e(node, "block_unexpected_close", `Unexpected block closing tag
https://svelte.dev/e/block_unexpected_close`);
}
function const_tag_invalid_expression(node) {
  e(node, "const_tag_invalid_expression", `{@const ...} must consist of a single variable declaration
https://svelte.dev/e/const_tag_invalid_expression`);
}
function debug_tag_invalid_arguments(node) {
  e(node, "debug_tag_invalid_arguments", `{@debug ...} arguments must be identifiers, not arbitrary expressions
https://svelte.dev/e/debug_tag_invalid_arguments`);
}
function directive_invalid_value(node) {
  e(node, "directive_invalid_value", `Directive value must be a JavaScript expression enclosed in curly braces
https://svelte.dev/e/directive_invalid_value`);
}
function directive_missing_name(node, type2) {
  e(node, "directive_missing_name", `\`${type2}\` name cannot be empty
https://svelte.dev/e/directive_missing_name`);
}
function element_invalid_closing_tag(node, name2) {
  e(node, "element_invalid_closing_tag", `\`</${name2}>\` attempted to close an element that was not open
https://svelte.dev/e/element_invalid_closing_tag`);
}
function element_invalid_closing_tag_autoclosed(node, name2, reason) {
  e(node, "element_invalid_closing_tag_autoclosed", `\`</${name2}>\` attempted to close element that was already automatically closed by \`<${reason}>\` (cannot nest \`<${reason}>\` inside \`<${name2}>\`)
https://svelte.dev/e/element_invalid_closing_tag_autoclosed`);
}
function element_unclosed(node, name2) {
  e(node, "element_unclosed", `\`<${name2}>\` was left open
https://svelte.dev/e/element_unclosed`);
}
function expected_attribute_value(node) {
  e(node, "expected_attribute_value", `Expected attribute value
https://svelte.dev/e/expected_attribute_value`);
}
function expected_block_type(node) {
  e(node, "expected_block_type", `Expected 'if', 'each', 'await', 'key' or 'snippet'
https://svelte.dev/e/expected_block_type`);
}
function expected_identifier(node) {
  e(node, "expected_identifier", `Expected an identifier
https://svelte.dev/e/expected_identifier`);
}
function expected_pattern(node) {
  e(node, "expected_pattern", `Expected identifier or destructure pattern
https://svelte.dev/e/expected_pattern`);
}
function expected_token(node, token) {
  e(node, "expected_token", `Expected token ${token}
https://svelte.dev/e/expected_token`);
}
function expected_whitespace(node) {
  e(node, "expected_whitespace", `Expected whitespace
https://svelte.dev/e/expected_whitespace`);
}
function js_parse_error(node, message2) {
  e(node, "js_parse_error", `${message2}
https://svelte.dev/e/js_parse_error`);
}
function render_tag_invalid_expression(node) {
  e(node, "render_tag_invalid_expression", `\`{@render ...}\` tags can only contain call expressions
https://svelte.dev/e/render_tag_invalid_expression`);
}
function script_duplicate(node) {
  e(node, "script_duplicate", `A component can have a single top-level \`<script>\` element and/or a single top-level \`<script module>\` element
https://svelte.dev/e/script_duplicate`);
}
function script_invalid_attribute_value(node, name2) {
  e(node, "script_invalid_attribute_value", `If the \`${name2}\` attribute is supplied, it must be a boolean attribute
https://svelte.dev/e/script_invalid_attribute_value`);
}
function script_invalid_context(node) {
  e(node, "script_invalid_context", `If the context attribute is supplied, its value must be "module"
https://svelte.dev/e/script_invalid_context`);
}
function script_reserved_attribute(node, name2) {
  e(node, "script_reserved_attribute", `The \`${name2}\` attribute is reserved and cannot be used
https://svelte.dev/e/script_reserved_attribute`);
}
function style_duplicate(node) {
  e(node, "style_duplicate", `A component can have a single top-level \`<style>\` element
https://svelte.dev/e/style_duplicate`);
}
function svelte_component_invalid_this(node) {
  e(node, "svelte_component_invalid_this", `Invalid component definition  must be an \`{expression}\`
https://svelte.dev/e/svelte_component_invalid_this`);
}
function svelte_component_missing_this(node) {
  e(node, "svelte_component_missing_this", `\`<svelte:component>\` must have a 'this' attribute
https://svelte.dev/e/svelte_component_missing_this`);
}
function svelte_element_missing_this(node) {
  e(node, "svelte_element_missing_this", `\`<svelte:element>\` must have a 'this' attribute with a value
https://svelte.dev/e/svelte_element_missing_this`);
}
function svelte_meta_duplicate(node, name2) {
  e(node, "svelte_meta_duplicate", `A component can only have one \`<${name2}>\` element
https://svelte.dev/e/svelte_meta_duplicate`);
}
function svelte_meta_invalid_content(node, name2) {
  e(node, "svelte_meta_invalid_content", `<${name2}> cannot have children
https://svelte.dev/e/svelte_meta_invalid_content`);
}
function svelte_meta_invalid_placement(node, name2) {
  e(node, "svelte_meta_invalid_placement", `\`<${name2}>\` tags cannot be inside elements or blocks
https://svelte.dev/e/svelte_meta_invalid_placement`);
}
function svelte_meta_invalid_tag(node, list4) {
  e(node, "svelte_meta_invalid_tag", `Valid \`<svelte:...>\` tag names are ${list4}
https://svelte.dev/e/svelte_meta_invalid_tag`);
}
function svelte_options_deprecated_tag(node) {
  e(node, "svelte_options_deprecated_tag", `"tag" option is deprecated  use "customElement" instead
https://svelte.dev/e/svelte_options_deprecated_tag`);
}
function svelte_options_invalid_attribute(node) {
  e(node, "svelte_options_invalid_attribute", `\`<svelte:options>\` can only receive static attributes
https://svelte.dev/e/svelte_options_invalid_attribute`);
}
function svelte_options_invalid_attribute_value(node, list4) {
  e(node, "svelte_options_invalid_attribute_value", `Value must be ${list4}, if specified
https://svelte.dev/e/svelte_options_invalid_attribute_value`);
}
function svelte_options_invalid_customelement(node) {
  e(node, "svelte_options_invalid_customelement", `"customElement" must be a string literal defining a valid custom element name or an object of the form { tag?: string; shadow?: "open" | "none"; props?: { [key: string]: { attribute?: string; reflect?: boolean; type: .. } } }
https://svelte.dev/e/svelte_options_invalid_customelement`);
}
function svelte_options_invalid_customelement_props(node) {
  e(node, "svelte_options_invalid_customelement_props", `"props" must be a statically analyzable object literal of the form "{ [key: string]: { attribute?: string; reflect?: boolean; type?: "String" | "Boolean" | "Number" | "Array" | "Object" }"
https://svelte.dev/e/svelte_options_invalid_customelement_props`);
}
function svelte_options_invalid_customelement_shadow(node) {
  e(node, "svelte_options_invalid_customelement_shadow", `"shadow" must be either "open" or "none"
https://svelte.dev/e/svelte_options_invalid_customelement_shadow`);
}
function svelte_options_invalid_tagname(node) {
  e(node, "svelte_options_invalid_tagname", `Tag name must be lowercase and hyphenated
https://svelte.dev/e/svelte_options_invalid_tagname`);
}
function svelte_options_reserved_tagname(node) {
  e(node, "svelte_options_reserved_tagname", `Tag name is reserved
https://svelte.dev/e/svelte_options_reserved_tagname`);
}
function svelte_options_unknown_attribute(node, name2) {
  e(node, "svelte_options_unknown_attribute", `\`<svelte:options>\` unknown attribute '${name2}'
https://svelte.dev/e/svelte_options_unknown_attribute`);
}
function tag_invalid_name(node) {
  e(node, "tag_invalid_name", `Expected a valid element or component name. Components must have a valid variable name or dot notation expression
https://svelte.dev/e/tag_invalid_name`);
}
function tag_invalid_placement(node, name2, location) {
  e(node, "tag_invalid_placement", `{@${name2} ...} tag cannot be ${location}
https://svelte.dev/e/tag_invalid_placement`);
}
function unexpected_eof(node) {
  e(node, "unexpected_eof", `Unexpected end of input
https://svelte.dev/e/unexpected_eof`);
}
function unexpected_reserved_word(node, word2) {
  e(node, "unexpected_reserved_word", `'${word2}' is a reserved word in JavaScript and cannot be used here
https://svelte.dev/e/unexpected_reserved_word`);
}
function unterminated_string_constant(node) {
  e(node, "unterminated_string_constant", `Unterminated string constant
https://svelte.dev/e/unterminated_string_constant`);
}
function void_element_invalid_content(node) {
  e(node, "void_element_invalid_content", `Void elements cannot have children or closing tags
https://svelte.dev/e/void_element_invalid_content`);
}

// node_modules/.deno/svelte@5.43.8/node_modules/svelte/src/compiler/phases/1-parse/utils/bracket.js
function infinity_if_negative(num2) {
  if (num2 < 0) {
    return Infinity;
  }
  return num2;
}
function find_string_end(string2, search_start_index, string_start_char) {
  let string_to_search;
  if (string_start_char === "`") {
    string_to_search = string2;
  } else {
    string_to_search = string2.slice(
      0,
      infinity_if_negative(string2.indexOf("\n", search_start_index))
    );
  }
  return find_unescaped_char(string_to_search, search_start_index, string_start_char);
}
function find_regex_end(string2, search_start_index) {
  return find_unescaped_char(string2, search_start_index, "/");
}
function find_unescaped_char(string2, search_start_index, char) {
  let i = search_start_index;
  while (true) {
    const found_index = string2.indexOf(char, i);
    if (found_index === -1) {
      return Infinity;
    }
    if (count_leading_backslashes(string2, found_index - 1) % 2 === 0) {
      return found_index;
    }
    i = found_index + 1;
  }
}
function count_leading_backslashes(string2, search_start_index) {
  let i = search_start_index;
  let count = 0;
  while (string2[i] === "\\") {
    count++;
    i--;
  }
  return count;
}
function find_matching_bracket(template2, index2, open2) {
  const close2 = default_brackets[open2];
  let brackets = 1;
  let i = index2;
  while (brackets > 0 && i < template2.length) {
    const char = template2[i];
    switch (char) {
      case "'":
      case '"':
      case "`":
        i = find_string_end(template2, i + 1, char) + 1;
        continue;
      case "/": {
        const next_char = template2[i + 1];
        if (!next_char) continue;
        if (next_char === "/") {
          i = infinity_if_negative(template2.indexOf("\n", i + 1)) + "\n".length;
          continue;
        }
        if (next_char === "*") {
          i = infinity_if_negative(template2.indexOf("*/", i + 1)) + "*/".length;
          continue;
        }
        i = find_regex_end(template2, i + 1) + "/".length;
        continue;
      }
      default: {
        const char2 = template2[i];
        if (char2 === open2) {
          brackets++;
        } else if (char2 === close2) {
          brackets--;
        }
        if (brackets === 0) {
          return i;
        }
        i++;
      }
    }
  }
  return void 0;
}
var default_brackets = {
  "{": "}",
  "(": ")",
  "[": "]"
};
function match_bracket(parser2, start2, brackets = default_brackets) {
  const close2 = Object.values(brackets);
  const bracket_stack = [];
  let i = start2;
  while (i < parser2.template.length) {
    let char = parser2.template[i++];
    if (char === "'" || char === '"' || char === "`") {
      i = match_quote(parser2, i, char);
      continue;
    }
    if (char in brackets) {
      bracket_stack.push(char);
    } else if (close2.includes(char)) {
      const popped = (
        /** @type {string} */
        bracket_stack.pop()
      );
      const expected = (
        /** @type {string} */
        brackets[popped]
      );
      if (char !== expected) {
        expected_token(i - 1, expected);
      }
      if (bracket_stack.length === 0) {
        return i;
      }
    }
  }
  unexpected_eof(parser2.template.length);
}
function match_quote(parser2, start2, quote) {
  let is_escaped = false;
  let i = start2;
  while (i < parser2.template.length) {
    const char = parser2.template[i++];
    if (is_escaped) {
      is_escaped = false;
      continue;
    }
    if (char === quote) {
      return i;
    }
    if (char === "\\") {
      is_escaped = true;
    }
    if (quote === "`" && char === "$" && parser2.template[i] === "{") {
      i = match_bracket(parser2, i);
    }
  }
  unterminated_string_constant(start2);
}

// node_modules/.deno/svelte@5.43.8/node_modules/svelte/src/compiler/phases/1-parse/read/expression.js
function get_loose_identifier(parser2, opening_token) {
  const end2 = find_matching_bracket(parser2.template, parser2.index, opening_token ?? "{");
  if (end2) {
    const start2 = parser2.index;
    parser2.index = end2;
    return {
      type: "Identifier",
      start: start2,
      end: end2,
      name: ""
    };
  }
}
function read_expression(parser2, opening_token, disallow_loose) {
  try {
    let comment_index = parser2.root.comments.length;
    const node = parse_expression_at(
      parser2.template,
      parser2.root.comments,
      parser2.ts,
      parser2.index
    );
    let num_parens = 0;
    let i = parser2.root.comments.length;
    while (i-- > comment_index) {
      const comment2 = parser2.root.comments[i];
      if (comment2.end < node.start) {
        parser2.index = comment2.end;
        break;
      }
    }
    for (let i2 = parser2.index; i2 < /** @type {number} */
    node.start; i2 += 1) {
      if (parser2.template[i2] === "(") num_parens += 1;
    }
    let index2 = (
      /** @type {number} */
      node.end
    );
    const last_comment = parser2.root.comments.at(-1);
    if (last_comment && last_comment.end > index2) index2 = last_comment.end;
    while (num_parens > 0) {
      const char = parser2.template[index2];
      if (char === ")") {
        num_parens -= 1;
      } else if (!regex_whitespace.test(char)) {
        expected_token(index2, ")");
      }
      index2 += 1;
    }
    parser2.index = index2;
    return (
      /** @type {Expression} */
      node
    );
  } catch (err) {
    if (parser2.loose && !disallow_loose) {
      const expression = get_loose_identifier(parser2, opening_token);
      if (expression) {
        return expression;
      }
    }
    parser2.acorn_error(err);
  }
}

// node_modules/.deno/svelte@5.43.8/node_modules/svelte/src/compiler/utils/builders.js
function array(elements = []) {
  return { type: "ArrayExpression", elements };
}
function unary(operator, argument) {
  return { type: "UnaryExpression", argument, operator, prefix: true };
}
var void0 = unary("void", literal2(0));
function literal2(value) {
  return { type: "Literal", value };
}
var true_instance = literal2(true);
var false_instance = literal2(false);
var null_instance = literal2(null);

// node_modules/.deno/svelte@5.43.8/node_modules/svelte/src/compiler/utils/ast.js
function is_text_attribute(attribute2) {
  return Array.isArray(attribute2.value) && attribute2.value.length === 1 && attribute2.value[0].type === "Text";
}
function is_expression_attribute(attribute2) {
  return attribute2.value !== true && !Array.isArray(attribute2.value) || Array.isArray(attribute2.value) && attribute2.value.length === 1 && attribute2.value[0].type === "ExpressionTag";
}
function get_attribute_expression(attribute2) {
  return Array.isArray(attribute2.value) ? (
    /** @type {AST.ExpressionTag} */
    attribute2.value[0].expression
  ) : attribute2.value.expression;
}

// node_modules/.deno/svelte@5.43.8/node_modules/svelte/src/compiler/phases/1-parse/read/script.js
var regex_closing_script_tag = /<\/script\s*>/;
var regex_starts_with_closing_script_tag = /^<\/script\s*>/;
var RESERVED_ATTRIBUTES = ["server", "client", "worker", "test", "default"];
var ALLOWED_ATTRIBUTES = ["context", "generics", "lang", "module"];
function read_script(parser2, start2, attributes) {
  const script_start = parser2.index;
  const data3 = parser2.read_until(regex_closing_script_tag);
  if (parser2.index >= parser2.template.length) {
    element_unclosed(parser2.template.length, "script");
  }
  const source2 = parser2.template.slice(0, script_start).replace(regex_not_newline_characters, " ") + data3;
  parser2.read(regex_starts_with_closing_script_tag);
  let ast2;
  try {
    ast2 = parse4(source2, parser2.root.comments, parser2.ts, true);
  } catch (err) {
    parser2.acorn_error(err);
  }
  ast2.start = script_start;
  let context2 = "default";
  for (
    const attribute2 of
    /** @type {AST.Attribute[]} */
    attributes
  ) {
    if (RESERVED_ATTRIBUTES.includes(attribute2.name)) {
      script_reserved_attribute(attribute2, attribute2.name);
    }
    if (!ALLOWED_ATTRIBUTES.includes(attribute2.name)) {
      script_unknown_attribute(attribute2);
    }
    if (attribute2.name === "module") {
      if (attribute2.value !== true) {
        script_invalid_attribute_value(attribute2, attribute2.name);
      }
      context2 = "module";
    }
    if (attribute2.name === "context") {
      if (attribute2.value === true || !is_text_attribute(attribute2)) {
        script_invalid_context(attribute2);
      }
      const value = attribute2.value[0].data;
      if (value !== "module") {
        script_invalid_context(attribute2);
      }
      context2 = "module";
    }
  }
  return {
    type: "Script",
    start: start2,
    end: parser2.index,
    context: context2,
    content: ast2,
    // @ts-ignore
    attributes
  };
}

// node_modules/.deno/svelte@5.43.8/node_modules/svelte/src/compiler/phases/1-parse/read/style.js
var REGEX_MATCHER = /^[~^$*|]?=/;
var REGEX_CLOSING_BRACKET = /[\s\]]/;
var REGEX_ATTRIBUTE_FLAGS = /^[a-zA-Z]+/;
var REGEX_COMBINATOR = /^(\+|~|>|\|\|)/;
var REGEX_PERCENTAGE = /^\d+(\.\d+)?%/;
var REGEX_NTH_OF = /^(even|odd|\+?(\d+|\d*n(\s*[+-]\s*\d+)?)|-\d*n(\s*\+\s*\d+))((?=\s*[,)])|\s+of\s+)/;
var REGEX_WHITESPACE_OR_COLON = /[\s:]/;
var REGEX_LEADING_HYPHEN_OR_DIGIT = /-?\d/;
var REGEX_VALID_IDENTIFIER_CHAR = /[a-zA-Z0-9_-]/;
var REGEX_UNICODE_SEQUENCE = /^\\[0-9a-fA-F]{1,6}(\r\n|\s)?/;
var REGEX_COMMENT_CLOSE = /\*\//;
var REGEX_HTML_COMMENT_CLOSE = /-->/;
function read_style(parser2, start2, attributes) {
  const content_start = parser2.index;
  const children = read_body(parser2, "</style");
  const content_end = parser2.index;
  parser2.read(/^<\/style\s*>/);
  return {
    type: "StyleSheet",
    start: start2,
    end: parser2.index,
    attributes,
    children,
    content: {
      start: content_start,
      end: content_end,
      styles: parser2.template.slice(content_start, content_end),
      comment: null
    }
  };
}
function read_body(parser2, close2) {
  const children = [];
  while (parser2.index < parser2.template.length) {
    allow_comment_or_whitespace(parser2);
    if (parser2.match(close2)) {
      return children;
    }
    if (parser2.match("@")) {
      children.push(read_at_rule(parser2));
    } else {
      children.push(read_rule(parser2));
    }
  }
  expected_token(parser2.template.length, close2);
}
function read_at_rule(parser2) {
  const start2 = parser2.index;
  parser2.eat("@", true);
  const name2 = read_identifier(parser2);
  const prelude = read_value(parser2);
  let block3 = null;
  if (parser2.match("{")) {
    block3 = read_block(parser2);
  } else {
    parser2.eat(";", true);
  }
  return {
    type: "Atrule",
    start: start2,
    end: parser2.index,
    name: name2,
    prelude,
    block: block3
  };
}
function read_rule(parser2) {
  const start2 = parser2.index;
  return {
    type: "Rule",
    prelude: read_selector_list(parser2),
    block: read_block(parser2),
    start: start2,
    end: parser2.index,
    metadata: {
      parent_rule: null,
      has_local_selectors: false,
      has_global_selectors: false,
      is_global_block: false
    }
  };
}
function read_selector_list(parser2, inside_pseudo_class = false) {
  const children = [];
  allow_comment_or_whitespace(parser2);
  const start2 = parser2.index;
  while (parser2.index < parser2.template.length) {
    children.push(read_selector(parser2, inside_pseudo_class));
    const end2 = parser2.index;
    allow_comment_or_whitespace(parser2);
    if (inside_pseudo_class ? parser2.match(")") : parser2.match("{")) {
      return {
        type: "SelectorList",
        start: start2,
        end: end2,
        children
      };
    } else {
      parser2.eat(",", true);
      allow_comment_or_whitespace(parser2);
    }
  }
  unexpected_eof(parser2.template.length);
}
function read_selector(parser2, inside_pseudo_class = false) {
  const list_start = parser2.index;
  const children = [];
  function create_selector(combinator, start2) {
    return {
      type: "RelativeSelector",
      combinator,
      selectors: [],
      start: start2,
      end: -1,
      metadata: {
        is_global: false,
        is_global_like: false,
        scoped: false
      }
    };
  }
  let relative_selector = create_selector(null, parser2.index);
  while (parser2.index < parser2.template.length) {
    let start2 = parser2.index;
    if (parser2.eat("&")) {
      relative_selector.selectors.push({
        type: "NestingSelector",
        name: "&",
        start: start2,
        end: parser2.index
      });
    } else if (parser2.eat("*")) {
      let name2 = "*";
      if (parser2.eat("|")) {
        name2 = read_identifier(parser2);
      }
      relative_selector.selectors.push({
        type: "TypeSelector",
        name: name2,
        start: start2,
        end: parser2.index
      });
    } else if (parser2.eat("#")) {
      relative_selector.selectors.push({
        type: "IdSelector",
        name: read_identifier(parser2),
        start: start2,
        end: parser2.index
      });
    } else if (parser2.eat(".")) {
      relative_selector.selectors.push({
        type: "ClassSelector",
        name: read_identifier(parser2),
        start: start2,
        end: parser2.index
      });
    } else if (parser2.eat("::")) {
      relative_selector.selectors.push({
        type: "PseudoElementSelector",
        name: read_identifier(parser2),
        start: start2,
        end: parser2.index
      });
      if (parser2.eat("(")) {
        read_selector_list(parser2, true);
        parser2.eat(")", true);
      }
    } else if (parser2.eat(":")) {
      const name2 = read_identifier(parser2);
      let args = null;
      if (parser2.eat("(")) {
        args = read_selector_list(parser2, true);
        parser2.eat(")", true);
      }
      relative_selector.selectors.push({
        type: "PseudoClassSelector",
        name: name2,
        args,
        start: start2,
        end: parser2.index
      });
    } else if (parser2.eat("[")) {
      parser2.allow_whitespace();
      const name2 = read_identifier(parser2);
      parser2.allow_whitespace();
      let value = null;
      const matcher = parser2.read(REGEX_MATCHER);
      if (matcher) {
        parser2.allow_whitespace();
        value = read_attribute_value(parser2);
      }
      parser2.allow_whitespace();
      const flags = parser2.read(REGEX_ATTRIBUTE_FLAGS);
      parser2.allow_whitespace();
      parser2.eat("]", true);
      relative_selector.selectors.push({
        type: "AttributeSelector",
        start: start2,
        end: parser2.index,
        name: name2,
        matcher,
        value,
        flags
      });
    } else if (inside_pseudo_class && parser2.match_regex(REGEX_NTH_OF)) {
      relative_selector.selectors.push({
        type: "Nth",
        value: (
          /**@type {string} */
          parser2.read(REGEX_NTH_OF)
        ),
        start: start2,
        end: parser2.index
      });
    } else if (parser2.match_regex(REGEX_PERCENTAGE)) {
      relative_selector.selectors.push({
        type: "Percentage",
        value: (
          /** @type {string} */
          parser2.read(REGEX_PERCENTAGE)
        ),
        start: start2,
        end: parser2.index
      });
    } else if (!parser2.match_regex(REGEX_COMBINATOR)) {
      let name2 = read_identifier(parser2);
      if (parser2.eat("|")) {
        name2 = read_identifier(parser2);
      }
      relative_selector.selectors.push({
        type: "TypeSelector",
        name: name2,
        start: start2,
        end: parser2.index
      });
    }
    const index2 = parser2.index;
    allow_comment_or_whitespace(parser2);
    if (parser2.match(",") || (inside_pseudo_class ? parser2.match(")") : parser2.match("{"))) {
      parser2.index = index2;
      relative_selector.end = index2;
      children.push(relative_selector);
      return {
        type: "ComplexSelector",
        start: list_start,
        end: index2,
        children,
        metadata: {
          rule: null,
          is_global: false,
          used: false
        }
      };
    }
    parser2.index = index2;
    const combinator = read_combinator(parser2);
    if (combinator) {
      if (relative_selector.selectors.length > 0) {
        relative_selector.end = index2;
        children.push(relative_selector);
      }
      relative_selector = create_selector(combinator, combinator.start);
      parser2.allow_whitespace();
      if (parser2.match(",") || (inside_pseudo_class ? parser2.match(")") : parser2.match("{"))) {
        css_selector_invalid(parser2.index);
      }
    }
  }
  unexpected_eof(parser2.template.length);
}
function read_combinator(parser2) {
  const start2 = parser2.index;
  parser2.allow_whitespace();
  const index2 = parser2.index;
  const name2 = parser2.read(REGEX_COMBINATOR);
  if (name2) {
    const end2 = parser2.index;
    parser2.allow_whitespace();
    return {
      type: "Combinator",
      name: name2,
      start: index2,
      end: end2
    };
  }
  if (parser2.index !== start2) {
    return {
      type: "Combinator",
      name: " ",
      start: start2,
      end: parser2.index
    };
  }
  return null;
}
function read_block(parser2) {
  const start2 = parser2.index;
  parser2.eat("{", true);
  const children = [];
  while (parser2.index < parser2.template.length) {
    allow_comment_or_whitespace(parser2);
    if (parser2.match("}")) {
      break;
    } else {
      children.push(read_block_item(parser2));
    }
  }
  parser2.eat("}", true);
  return {
    type: "Block",
    start: start2,
    end: parser2.index,
    children
  };
}
function read_block_item(parser2) {
  if (parser2.match("@")) {
    return read_at_rule(parser2);
  }
  const start2 = parser2.index;
  read_value(parser2);
  const char = parser2.template[parser2.index];
  parser2.index = start2;
  return char === "{" ? read_rule(parser2) : read_declaration(parser2);
}
function read_declaration(parser2) {
  const start2 = parser2.index;
  const property = parser2.read_until(REGEX_WHITESPACE_OR_COLON);
  parser2.allow_whitespace();
  parser2.eat(":");
  let index2 = parser2.index;
  parser2.allow_whitespace();
  const value = read_value(parser2);
  if (!value && !property.startsWith("--")) {
    css_empty_declaration({ start: start2, end: index2 });
  }
  const end2 = parser2.index;
  if (!parser2.match("}")) {
    parser2.eat(";", true);
  }
  return {
    type: "Declaration",
    start: start2,
    end: end2,
    property,
    value
  };
}
function read_value(parser2) {
  let value = "";
  let escaped = false;
  let in_url = false;
  let quote_mark = null;
  while (parser2.index < parser2.template.length) {
    const char = parser2.template[parser2.index];
    if (escaped) {
      value += "\\" + char;
      escaped = false;
    } else if (char === "\\") {
      escaped = true;
    } else if (char === quote_mark) {
      quote_mark = null;
    } else if (char === ")") {
      in_url = false;
    } else if (quote_mark === null && (char === '"' || char === "'")) {
      quote_mark = char;
    } else if (char === "(" && value.slice(-3) === "url") {
      in_url = true;
    } else if ((char === ";" || char === "{" || char === "}") && !in_url && !quote_mark) {
      return value.trim();
    }
    value += char;
    parser2.index++;
  }
  unexpected_eof(parser2.template.length);
}
function read_attribute_value(parser2) {
  let value = "";
  let escaped = false;
  const quote_mark = parser2.eat('"') ? '"' : parser2.eat("'") ? "'" : null;
  while (parser2.index < parser2.template.length) {
    const char = parser2.template[parser2.index];
    if (escaped) {
      value += "\\" + char;
      escaped = false;
    } else if (char === "\\") {
      escaped = true;
    } else if (quote_mark ? char === quote_mark : REGEX_CLOSING_BRACKET.test(char)) {
      if (quote_mark) {
        parser2.eat(quote_mark, true);
      }
      return value.trim();
    } else {
      value += char;
    }
    parser2.index++;
  }
  unexpected_eof(parser2.template.length);
}
function read_identifier(parser2) {
  const start2 = parser2.index;
  let identifier = "";
  if (parser2.match_regex(REGEX_LEADING_HYPHEN_OR_DIGIT)) {
    css_expected_identifier(start2);
  }
  while (parser2.index < parser2.template.length) {
    const char = parser2.template[parser2.index];
    if (char === "\\") {
      const sequence2 = parser2.match_regex(REGEX_UNICODE_SEQUENCE);
      if (sequence2) {
        identifier += String.fromCodePoint(parseInt(sequence2.slice(1), 16));
        parser2.index += sequence2.length;
      } else {
        identifier += "\\" + parser2.template[parser2.index + 1];
        parser2.index += 2;
      }
    } else if (
      /** @type {number} */
      char.codePointAt(0) >= 160 || REGEX_VALID_IDENTIFIER_CHAR.test(char)
    ) {
      identifier += char;
      parser2.index++;
    } else {
      break;
    }
  }
  if (identifier === "") {
    css_expected_identifier(start2);
  }
  return identifier;
}
function allow_comment_or_whitespace(parser2) {
  parser2.allow_whitespace();
  while (parser2.match("/*") || parser2.match("<!--")) {
    if (parser2.eat("/*")) {
      parser2.read_until(REGEX_COMMENT_CLOSE);
      parser2.eat("*/", true);
    }
    if (parser2.eat("<!--")) {
      parser2.read_until(REGEX_HTML_COMMENT_CLOSE);
      parser2.eat("-->", true);
    }
    parser2.allow_whitespace();
  }
}

// node_modules/.deno/svelte@5.43.8/node_modules/svelte/src/compiler/phases/1-parse/utils/entities.js
var entities_default = {
  "CounterClockwiseContourIntegral;": 8755,
  "ClockwiseContourIntegral;": 8754,
  "DoubleLongLeftRightArrow;": 10234,
  "NotNestedGreaterGreater;": 10914,
  "DiacriticalDoubleAcute;": 733,
  "NotSquareSupersetEqual;": 8931,
  "CloseCurlyDoubleQuote;": 8221,
  "DoubleContourIntegral;": 8751,
  "FilledVerySmallSquare;": 9642,
  "NegativeVeryThinSpace;": 8203,
  "NotPrecedesSlantEqual;": 8928,
  "NotRightTriangleEqual;": 8941,
  "NotSucceedsSlantEqual;": 8929,
  "CapitalDifferentialD;": 8517,
  "DoubleLeftRightArrow;": 8660,
  "DoubleLongRightArrow;": 10233,
  "EmptyVerySmallSquare;": 9643,
  "NestedGreaterGreater;": 8811,
  "NotDoubleVerticalBar;": 8742,
  "NotGreaterSlantEqual;": 10878,
  "NotLeftTriangleEqual;": 8940,
  "NotSquareSubsetEqual;": 8930,
  "OpenCurlyDoubleQuote;": 8220,
  "ReverseUpEquilibrium;": 10607,
  "DoubleLongLeftArrow;": 10232,
  "DownLeftRightVector;": 10576,
  "LeftArrowRightArrow;": 8646,
  "NegativeMediumSpace;": 8203,
  "NotGreaterFullEqual;": 8807,
  "NotRightTriangleBar;": 10704,
  "RightArrowLeftArrow;": 8644,
  "SquareSupersetEqual;": 8850,
  "leftrightsquigarrow;": 8621,
  "DownRightTeeVector;": 10591,
  "DownRightVectorBar;": 10583,
  "LongLeftRightArrow;": 10231,
  "Longleftrightarrow;": 10234,
  "NegativeThickSpace;": 8203,
  "NotLeftTriangleBar;": 10703,
  "PrecedesSlantEqual;": 8828,
  "ReverseEquilibrium;": 8651,
  "RightDoubleBracket;": 10215,
  "RightDownTeeVector;": 10589,
  "RightDownVectorBar;": 10581,
  "RightTriangleEqual;": 8885,
  "SquareIntersection;": 8851,
  "SucceedsSlantEqual;": 8829,
  "blacktriangleright;": 9656,
  "longleftrightarrow;": 10231,
  "DoubleUpDownArrow;": 8661,
  "DoubleVerticalBar;": 8741,
  "DownLeftTeeVector;": 10590,
  "DownLeftVectorBar;": 10582,
  "FilledSmallSquare;": 9724,
  "GreaterSlantEqual;": 10878,
  "LeftDoubleBracket;": 10214,
  "LeftDownTeeVector;": 10593,
  "LeftDownVectorBar;": 10585,
  "LeftTriangleEqual;": 8884,
  "NegativeThinSpace;": 8203,
  "NotGreaterGreater;": 8811,
  "NotLessSlantEqual;": 10877,
  "NotNestedLessLess;": 10913,
  "NotReverseElement;": 8716,
  "NotSquareSuperset;": 8848,
  "NotTildeFullEqual;": 8775,
  "RightAngleBracket;": 10217,
  "RightUpDownVector;": 10575,
  "SquareSubsetEqual;": 8849,
  "VerticalSeparator;": 10072,
  "blacktriangledown;": 9662,
  "blacktriangleleft;": 9666,
  "leftrightharpoons;": 8651,
  "rightleftharpoons;": 8652,
  "twoheadrightarrow;": 8608,
  "DiacriticalAcute;": 180,
  "DiacriticalGrave;": 96,
  "DiacriticalTilde;": 732,
  "DoubleRightArrow;": 8658,
  "DownArrowUpArrow;": 8693,
  "EmptySmallSquare;": 9723,
  "GreaterEqualLess;": 8923,
  "GreaterFullEqual;": 8807,
  "LeftAngleBracket;": 10216,
  "LeftUpDownVector;": 10577,
  "LessEqualGreater;": 8922,
  "NonBreakingSpace;": 160,
  "NotPrecedesEqual;": 10927,
  "NotRightTriangle;": 8939,
  "NotSucceedsEqual;": 10928,
  "NotSucceedsTilde;": 8831,
  "NotSupersetEqual;": 8841,
  "RightTriangleBar;": 10704,
  "RightUpTeeVector;": 10588,
  "RightUpVectorBar;": 10580,
  "UnderParenthesis;": 9181,
  "UpArrowDownArrow;": 8645,
  "circlearrowright;": 8635,
  "downharpoonright;": 8642,
  "ntrianglerighteq;": 8941,
  "rightharpoondown;": 8641,
  "rightrightarrows;": 8649,
  "twoheadleftarrow;": 8606,
  "vartriangleright;": 8883,
  "CloseCurlyQuote;": 8217,
  "ContourIntegral;": 8750,
  "DoubleDownArrow;": 8659,
  "DoubleLeftArrow;": 8656,
  "DownRightVector;": 8641,
  "LeftRightVector;": 10574,
  "LeftTriangleBar;": 10703,
  "LeftUpTeeVector;": 10592,
  "LeftUpVectorBar;": 10584,
  "LowerRightArrow;": 8600,
  "NotGreaterEqual;": 8817,
  "NotGreaterTilde;": 8821,
  "NotHumpDownHump;": 8782,
  "NotLeftTriangle;": 8938,
  "NotSquareSubset;": 8847,
  "OverParenthesis;": 9180,
  "RightDownVector;": 8642,
  "ShortRightArrow;": 8594,
  "UpperRightArrow;": 8599,
  "bigtriangledown;": 9661,
  "circlearrowleft;": 8634,
  "curvearrowright;": 8631,
  "downharpoonleft;": 8643,
  "leftharpoondown;": 8637,
  "leftrightarrows;": 8646,
  "nLeftrightarrow;": 8654,
  "nleftrightarrow;": 8622,
  "ntrianglelefteq;": 8940,
  "rightleftarrows;": 8644,
  "rightsquigarrow;": 8605,
  "rightthreetimes;": 8908,
  "straightepsilon;": 1013,
  "trianglerighteq;": 8885,
  "vartriangleleft;": 8882,
  "DiacriticalDot;": 729,
  "DoubleRightTee;": 8872,
  "DownLeftVector;": 8637,
  "GreaterGreater;": 10914,
  "HorizontalLine;": 9472,
  "InvisibleComma;": 8291,
  "InvisibleTimes;": 8290,
  "LeftDownVector;": 8643,
  "LeftRightArrow;": 8596,
  "Leftrightarrow;": 8660,
  "LessSlantEqual;": 10877,
  "LongRightArrow;": 10230,
  "Longrightarrow;": 10233,
  "LowerLeftArrow;": 8601,
  "NestedLessLess;": 8810,
  "NotGreaterLess;": 8825,
  "NotLessGreater;": 8824,
  "NotSubsetEqual;": 8840,
  "NotVerticalBar;": 8740,
  "OpenCurlyQuote;": 8216,
  "ReverseElement;": 8715,
  "RightTeeVector;": 10587,
  "RightVectorBar;": 10579,
  "ShortDownArrow;": 8595,
  "ShortLeftArrow;": 8592,
  "SquareSuperset;": 8848,
  "TildeFullEqual;": 8773,
  "UpperLeftArrow;": 8598,
  "ZeroWidthSpace;": 8203,
  "curvearrowleft;": 8630,
  "doublebarwedge;": 8966,
  "downdownarrows;": 8650,
  "hookrightarrow;": 8618,
  "leftleftarrows;": 8647,
  "leftrightarrow;": 8596,
  "leftthreetimes;": 8907,
  "longrightarrow;": 10230,
  "looparrowright;": 8620,
  "nshortparallel;": 8742,
  "ntriangleright;": 8939,
  "rightarrowtail;": 8611,
  "rightharpoonup;": 8640,
  "trianglelefteq;": 8884,
  "upharpoonright;": 8638,
  "ApplyFunction;": 8289,
  "DifferentialD;": 8518,
  "DoubleLeftTee;": 10980,
  "DoubleUpArrow;": 8657,
  "LeftTeeVector;": 10586,
  "LeftVectorBar;": 10578,
  "LessFullEqual;": 8806,
  "LongLeftArrow;": 10229,
  "Longleftarrow;": 10232,
  "NotEqualTilde;": 8770,
  "NotTildeEqual;": 8772,
  "NotTildeTilde;": 8777,
  "Poincareplane;": 8460,
  "PrecedesEqual;": 10927,
  "PrecedesTilde;": 8830,
  "RightArrowBar;": 8677,
  "RightTeeArrow;": 8614,
  "RightTriangle;": 8883,
  "RightUpVector;": 8638,
  "SucceedsEqual;": 10928,
  "SucceedsTilde;": 8831,
  "SupersetEqual;": 8839,
  "UpEquilibrium;": 10606,
  "VerticalTilde;": 8768,
  "VeryThinSpace;": 8202,
  "bigtriangleup;": 9651,
  "blacktriangle;": 9652,
  "divideontimes;": 8903,
  "fallingdotseq;": 8786,
  "hookleftarrow;": 8617,
  "leftarrowtail;": 8610,
  "leftharpoonup;": 8636,
  "longleftarrow;": 10229,
  "looparrowleft;": 8619,
  "measuredangle;": 8737,
  "ntriangleleft;": 8938,
  "shortparallel;": 8741,
  "smallsetminus;": 8726,
  "triangleright;": 9657,
  "upharpoonleft;": 8639,
  "varsubsetneqq;": 10955,
  "varsupsetneqq;": 10956,
  "DownArrowBar;": 10515,
  "DownTeeArrow;": 8615,
  "ExponentialE;": 8519,
  "GreaterEqual;": 8805,
  "GreaterTilde;": 8819,
  "HilbertSpace;": 8459,
  "HumpDownHump;": 8782,
  "Intersection;": 8898,
  "LeftArrowBar;": 8676,
  "LeftTeeArrow;": 8612,
  "LeftTriangle;": 8882,
  "LeftUpVector;": 8639,
  "NotCongruent;": 8802,
  "NotHumpEqual;": 8783,
  "NotLessEqual;": 8816,
  "NotLessTilde;": 8820,
  "Proportional;": 8733,
  "RightCeiling;": 8969,
  "RoundImplies;": 10608,
  "ShortUpArrow;": 8593,
  "SquareSubset;": 8847,
  "UnderBracket;": 9141,
  "VerticalLine;": 124,
  "blacklozenge;": 10731,
  "exponentiale;": 8519,
  "risingdotseq;": 8787,
  "triangledown;": 9663,
  "triangleleft;": 9667,
  "varsubsetneq;": 8842,
  "varsupsetneq;": 8843,
  "CircleMinus;": 8854,
  "CircleTimes;": 8855,
  "Equilibrium;": 8652,
  "GreaterLess;": 8823,
  "LeftCeiling;": 8968,
  "LessGreater;": 8822,
  "MediumSpace;": 8287,
  "NotLessLess;": 8810,
  "NotPrecedes;": 8832,
  "NotSucceeds;": 8833,
  "NotSuperset;": 8835,
  "OverBracket;": 9140,
  "RightVector;": 8640,
  "Rrightarrow;": 8667,
  "RuleDelayed;": 10740,
  "SmallCircle;": 8728,
  "SquareUnion;": 8852,
  "SubsetEqual;": 8838,
  "UpDownArrow;": 8597,
  "Updownarrow;": 8661,
  "VerticalBar;": 8739,
  "backepsilon;": 1014,
  "blacksquare;": 9642,
  "circledcirc;": 8858,
  "circleddash;": 8861,
  "curlyeqprec;": 8926,
  "curlyeqsucc;": 8927,
  "diamondsuit;": 9830,
  "eqslantless;": 10901,
  "expectation;": 8496,
  "nRightarrow;": 8655,
  "nrightarrow;": 8603,
  "preccurlyeq;": 8828,
  "precnapprox;": 10937,
  "quaternions;": 8461,
  "straightphi;": 981,
  "succcurlyeq;": 8829,
  "succnapprox;": 10938,
  "thickapprox;": 8776,
  "updownarrow;": 8597,
  "Bernoullis;": 8492,
  "CirclePlus;": 8853,
  "EqualTilde;": 8770,
  "Fouriertrf;": 8497,
  "ImaginaryI;": 8520,
  "Laplacetrf;": 8466,
  "LeftVector;": 8636,
  "Lleftarrow;": 8666,
  "NotElement;": 8713,
  "NotGreater;": 8815,
  "Proportion;": 8759,
  "RightArrow;": 8594,
  "RightFloor;": 8971,
  "Rightarrow;": 8658,
  "ThickSpace;": 8287,
  "TildeEqual;": 8771,
  "TildeTilde;": 8776,
  "UnderBrace;": 9183,
  "UpArrowBar;": 10514,
  "UpTeeArrow;": 8613,
  "circledast;": 8859,
  "complement;": 8705,
  "curlywedge;": 8911,
  "eqslantgtr;": 10902,
  "gtreqqless;": 10892,
  "lessapprox;": 10885,
  "lesseqqgtr;": 10891,
  "lmoustache;": 9136,
  "longmapsto;": 10236,
  "mapstodown;": 8615,
  "mapstoleft;": 8612,
  "nLeftarrow;": 8653,
  "nleftarrow;": 8602,
  "nsubseteqq;": 10949,
  "nsupseteqq;": 10950,
  "precapprox;": 10935,
  "rightarrow;": 8594,
  "rmoustache;": 9137,
  "sqsubseteq;": 8849,
  "sqsupseteq;": 8850,
  "subsetneqq;": 10955,
  "succapprox;": 10936,
  "supsetneqq;": 10956,
  "upuparrows;": 8648,
  "varepsilon;": 1013,
  "varnothing;": 8709,
  "Backslash;": 8726,
  "CenterDot;": 183,
  "CircleDot;": 8857,
  "Congruent;": 8801,
  "Coproduct;": 8720,
  "DoubleDot;": 168,
  "DownArrow;": 8595,
  "DownBreve;": 785,
  "Downarrow;": 8659,
  "HumpEqual;": 8783,
  "LeftArrow;": 8592,
  "LeftFloor;": 8970,
  "Leftarrow;": 8656,
  "LessTilde;": 8818,
  "Mellintrf;": 8499,
  "MinusPlus;": 8723,
  "NotCupCap;": 8813,
  "NotExists;": 8708,
  "NotSubset;": 8834,
  "OverBrace;": 9182,
  "PlusMinus;": 177,
  "Therefore;": 8756,
  "ThinSpace;": 8201,
  "TripleDot;": 8411,
  "UnionPlus;": 8846,
  "backprime;": 8245,
  "backsimeq;": 8909,
  "bigotimes;": 10754,
  "centerdot;": 183,
  "checkmark;": 10003,
  "complexes;": 8450,
  "dotsquare;": 8865,
  "downarrow;": 8595,
  "gtrapprox;": 10886,
  "gtreqless;": 8923,
  "gvertneqq;": 8809,
  "heartsuit;": 9829,
  "leftarrow;": 8592,
  "lesseqgtr;": 8922,
  "lvertneqq;": 8808,
  "ngeqslant;": 10878,
  "nleqslant;": 10877,
  "nparallel;": 8742,
  "nshortmid;": 8740,
  "nsubseteq;": 8840,
  "nsupseteq;": 8841,
  "pitchfork;": 8916,
  "rationals;": 8474,
  "spadesuit;": 9824,
  "subseteqq;": 10949,
  "subsetneq;": 8842,
  "supseteqq;": 10950,
  "supsetneq;": 8843,
  "therefore;": 8756,
  "triangleq;": 8796,
  "varpropto;": 8733,
  "DDotrahd;": 10513,
  "DotEqual;": 8784,
  "Integral;": 8747,
  "LessLess;": 10913,
  "NotEqual;": 8800,
  "NotTilde;": 8769,
  "PartialD;": 8706,
  "Precedes;": 8826,
  "RightTee;": 8866,
  "Succeeds;": 8827,
  "SuchThat;": 8715,
  "Superset;": 8835,
  "Uarrocir;": 10569,
  "UnderBar;": 95,
  "andslope;": 10840,
  "angmsdaa;": 10664,
  "angmsdab;": 10665,
  "angmsdac;": 10666,
  "angmsdad;": 10667,
  "angmsdae;": 10668,
  "angmsdaf;": 10669,
  "angmsdag;": 10670,
  "angmsdah;": 10671,
  "angrtvbd;": 10653,
  "approxeq;": 8778,
  "awconint;": 8755,
  "backcong;": 8780,
  "barwedge;": 8965,
  "bbrktbrk;": 9142,
  "bigoplus;": 10753,
  "bigsqcup;": 10758,
  "biguplus;": 10756,
  "bigwedge;": 8896,
  "boxminus;": 8863,
  "boxtimes;": 8864,
  "bsolhsub;": 10184,
  "capbrcup;": 10825,
  "circledR;": 174,
  "circledS;": 9416,
  "cirfnint;": 10768,
  "clubsuit;": 9827,
  "cupbrcap;": 10824,
  "curlyvee;": 8910,
  "cwconint;": 8754,
  "doteqdot;": 8785,
  "dotminus;": 8760,
  "drbkarow;": 10512,
  "dzigrarr;": 10239,
  "elinters;": 9191,
  "emptyset;": 8709,
  "eqvparsl;": 10725,
  "fpartint;": 10765,
  "geqslant;": 10878,
  "gesdotol;": 10884,
  "gnapprox;": 10890,
  "hksearow;": 10533,
  "hkswarow;": 10534,
  "imagline;": 8464,
  "imagpart;": 8465,
  "infintie;": 10717,
  "integers;": 8484,
  "intercal;": 8890,
  "intlarhk;": 10775,
  "laemptyv;": 10676,
  "ldrushar;": 10571,
  "leqslant;": 10877,
  "lesdotor;": 10883,
  "llcorner;": 8990,
  "lnapprox;": 10889,
  "lrcorner;": 8991,
  "lurdshar;": 10570,
  "mapstoup;": 8613,
  "multimap;": 8888,
  "naturals;": 8469,
  "ncongdot;": 10861,
  "notindot;": 8949,
  "otimesas;": 10806,
  "parallel;": 8741,
  "plusacir;": 10787,
  "pointint;": 10773,
  "precneqq;": 10933,
  "precnsim;": 8936,
  "profalar;": 9006,
  "profline;": 8978,
  "profsurf;": 8979,
  "raemptyv;": 10675,
  "realpart;": 8476,
  "rppolint;": 10770,
  "rtriltri;": 10702,
  "scpolint;": 10771,
  "setminus;": 8726,
  "shortmid;": 8739,
  "smeparsl;": 10724,
  "sqsubset;": 8847,
  "sqsupset;": 8848,
  "subseteq;": 8838,
  "succneqq;": 10934,
  "succnsim;": 8937,
  "supseteq;": 8839,
  "thetasym;": 977,
  "thicksim;": 8764,
  "timesbar;": 10801,
  "triangle;": 9653,
  "triminus;": 10810,
  "trpezium;": 9186,
  "ulcorner;": 8988,
  "urcorner;": 8989,
  "varkappa;": 1008,
  "varsigma;": 962,
  "vartheta;": 977,
  "Because;": 8757,
  "Cayleys;": 8493,
  "Cconint;": 8752,
  "Cedilla;": 184,
  "Diamond;": 8900,
  "DownTee;": 8868,
  "Element;": 8712,
  "Epsilon;": 917,
  "Implies;": 8658,
  "LeftTee;": 8867,
  "NewLine;": 10,
  "NoBreak;": 8288,
  "NotLess;": 8814,
  "Omicron;": 927,
  "OverBar;": 8254,
  "Product;": 8719,
  "UpArrow;": 8593,
  "Uparrow;": 8657,
  "Upsilon;": 933,
  "alefsym;": 8501,
  "angrtvb;": 8894,
  "angzarr;": 9084,
  "asympeq;": 8781,
  "backsim;": 8765,
  "because;": 8757,
  "bemptyv;": 10672,
  "between;": 8812,
  "bigcirc;": 9711,
  "bigodot;": 10752,
  "bigstar;": 9733,
  "bnequiv;": 8801,
  "boxplus;": 8862,
  "ccupssm;": 10832,
  "cemptyv;": 10674,
  "cirscir;": 10690,
  "coloneq;": 8788,
  "congdot;": 10861,
  "cudarrl;": 10552,
  "cudarrr;": 10549,
  "cularrp;": 10557,
  "curarrm;": 10556,
  "dbkarow;": 10511,
  "ddagger;": 8225,
  "ddotseq;": 10871,
  "demptyv;": 10673,
  "diamond;": 8900,
  "digamma;": 989,
  "dotplus;": 8724,
  "dwangle;": 10662,
  "epsilon;": 949,
  "eqcolon;": 8789,
  "equivDD;": 10872,
  "gesdoto;": 10882,
  "gtquest;": 10876,
  "gtrless;": 8823,
  "harrcir;": 10568,
  "intprod;": 10812,
  "isindot;": 8949,
  "larrbfs;": 10527,
  "larrsim;": 10611,
  "lbrksld;": 10639,
  "lbrkslu;": 10637,
  "ldrdhar;": 10599,
  "lesdoto;": 10881,
  "lessdot;": 8918,
  "lessgtr;": 8822,
  "lesssim;": 8818,
  "lotimes;": 10804,
  "lozenge;": 9674,
  "ltquest;": 10875,
  "luruhar;": 10598,
  "maltese;": 10016,
  "minusdu;": 10794,
  "napprox;": 8777,
  "natural;": 9838,
  "nearrow;": 8599,
  "nexists;": 8708,
  "notinva;": 8713,
  "notinvb;": 8951,
  "notinvc;": 8950,
  "notniva;": 8716,
  "notnivb;": 8958,
  "notnivc;": 8957,
  "npolint;": 10772,
  "npreceq;": 10927,
  "nsqsube;": 8930,
  "nsqsupe;": 8931,
  "nsubset;": 8834,
  "nsucceq;": 10928,
  "nsupset;": 8835,
  "nvinfin;": 10718,
  "nvltrie;": 8884,
  "nvrtrie;": 8885,
  "nwarrow;": 8598,
  "olcross;": 10683,
  "omicron;": 959,
  "orderof;": 8500,
  "orslope;": 10839,
  "pertenk;": 8241,
  "planckh;": 8462,
  "pluscir;": 10786,
  "plussim;": 10790,
  "plustwo;": 10791,
  "precsim;": 8830,
  "quatint;": 10774,
  "questeq;": 8799,
  "rarrbfs;": 10528,
  "rarrsim;": 10612,
  "rbrksld;": 10638,
  "rbrkslu;": 10640,
  "rdldhar;": 10601,
  "realine;": 8475,
  "rotimes;": 10805,
  "ruluhar;": 10600,
  "searrow;": 8600,
  "simplus;": 10788,
  "simrarr;": 10610,
  "subedot;": 10947,
  "submult;": 10945,
  "subplus;": 10943,
  "subrarr;": 10617,
  "succsim;": 8831,
  "supdsub;": 10968,
  "supedot;": 10948,
  "suphsol;": 10185,
  "suphsub;": 10967,
  "suplarr;": 10619,
  "supmult;": 10946,
  "supplus;": 10944,
  "swarrow;": 8601,
  "topfork;": 10970,
  "triplus;": 10809,
  "tritime;": 10811,
  "uparrow;": 8593,
  "upsilon;": 965,
  "uwangle;": 10663,
  "vzigzag;": 10650,
  "zigrarr;": 8669,
  "Aacute;": 193,
  "Abreve;": 258,
  "Agrave;": 192,
  "Assign;": 8788,
  "Atilde;": 195,
  "Barwed;": 8966,
  "Bumpeq;": 8782,
  "Cacute;": 262,
  "Ccaron;": 268,
  "Ccedil;": 199,
  "Colone;": 10868,
  "Conint;": 8751,
  "CupCap;": 8781,
  "Dagger;": 8225,
  "Dcaron;": 270,
  "DotDot;": 8412,
  "Dstrok;": 272,
  "Eacute;": 201,
  "Ecaron;": 282,
  "Egrave;": 200,
  "Exists;": 8707,
  "ForAll;": 8704,
  "Gammad;": 988,
  "Gbreve;": 286,
  "Gcedil;": 290,
  "HARDcy;": 1066,
  "Hstrok;": 294,
  "Iacute;": 205,
  "Igrave;": 204,
  "Itilde;": 296,
  "Jsercy;": 1032,
  "Kcedil;": 310,
  "Lacute;": 313,
  "Lambda;": 923,
  "Lcaron;": 317,
  "Lcedil;": 315,
  "Lmidot;": 319,
  "Lstrok;": 321,
  "Nacute;": 323,
  "Ncaron;": 327,
  "Ncedil;": 325,
  "Ntilde;": 209,
  "Oacute;": 211,
  "Odblac;": 336,
  "Ograve;": 210,
  "Oslash;": 216,
  "Otilde;": 213,
  "Otimes;": 10807,
  "Racute;": 340,
  "Rarrtl;": 10518,
  "Rcaron;": 344,
  "Rcedil;": 342,
  "SHCHcy;": 1065,
  "SOFTcy;": 1068,
  "Sacute;": 346,
  "Scaron;": 352,
  "Scedil;": 350,
  "Square;": 9633,
  "Subset;": 8912,
  "Supset;": 8913,
  "Tcaron;": 356,
  "Tcedil;": 354,
  "Tstrok;": 358,
  "Uacute;": 218,
  "Ubreve;": 364,
  "Udblac;": 368,
  "Ugrave;": 217,
  "Utilde;": 360,
  "Vdashl;": 10982,
  "Verbar;": 8214,
  "Vvdash;": 8874,
  "Yacute;": 221,
  "Zacute;": 377,
  "Zcaron;": 381,
  "aacute;": 225,
  "abreve;": 259,
  "agrave;": 224,
  "andand;": 10837,
  "angmsd;": 8737,
  "angsph;": 8738,
  "apacir;": 10863,
  "approx;": 8776,
  "atilde;": 227,
  "barvee;": 8893,
  "barwed;": 8965,
  "becaus;": 8757,
  "bernou;": 8492,
  "bigcap;": 8898,
  "bigcup;": 8899,
  "bigvee;": 8897,
  "bkarow;": 10509,
  "bottom;": 8869,
  "bowtie;": 8904,
  "boxbox;": 10697,
  "bprime;": 8245,
  "brvbar;": 166,
  "bullet;": 8226,
  "bumpeq;": 8783,
  "cacute;": 263,
  "capand;": 10820,
  "capcap;": 10827,
  "capcup;": 10823,
  "capdot;": 10816,
  "ccaron;": 269,
  "ccedil;": 231,
  "circeq;": 8791,
  "cirmid;": 10991,
  "colone;": 8788,
  "commat;": 64,
  "compfn;": 8728,
  "conint;": 8750,
  "coprod;": 8720,
  "copysr;": 8471,
  "cularr;": 8630,
  "cupcap;": 10822,
  "cupcup;": 10826,
  "cupdot;": 8845,
  "curarr;": 8631,
  "curren;": 164,
  "cylcty;": 9005,
  "dagger;": 8224,
  "daleth;": 8504,
  "dcaron;": 271,
  "dfisht;": 10623,
  "divide;": 247,
  "divonx;": 8903,
  "dlcorn;": 8990,
  "dlcrop;": 8973,
  "dollar;": 36,
  "drcorn;": 8991,
  "drcrop;": 8972,
  "dstrok;": 273,
  "eacute;": 233,
  "easter;": 10862,
  "ecaron;": 283,
  "ecolon;": 8789,
  "egrave;": 232,
  "egsdot;": 10904,
  "elsdot;": 10903,
  "emptyv;": 8709,
  "emsp13;": 8196,
  "emsp14;": 8197,
  "eparsl;": 10723,
  "eqcirc;": 8790,
  "equals;": 61,
  "equest;": 8799,
  "female;": 9792,
  "ffilig;": 64259,
  "ffllig;": 64260,
  "forall;": 8704,
  "frac12;": 189,
  "frac13;": 8531,
  "frac14;": 188,
  "frac15;": 8533,
  "frac16;": 8537,
  "frac18;": 8539,
  "frac23;": 8532,
  "frac25;": 8534,
  "frac34;": 190,
  "frac35;": 8535,
  "frac38;": 8540,
  "frac45;": 8536,
  "frac56;": 8538,
  "frac58;": 8541,
  "frac78;": 8542,
  "gacute;": 501,
  "gammad;": 989,
  "gbreve;": 287,
  "gesdot;": 10880,
  "gesles;": 10900,
  "gtlPar;": 10645,
  "gtrarr;": 10616,
  "gtrdot;": 8919,
  "gtrsim;": 8819,
  "hairsp;": 8202,
  "hamilt;": 8459,
  "hardcy;": 1098,
  "hearts;": 9829,
  "hellip;": 8230,
  "hercon;": 8889,
  "homtht;": 8763,
  "horbar;": 8213,
  "hslash;": 8463,
  "hstrok;": 295,
  "hybull;": 8259,
  "hyphen;": 8208,
  "iacute;": 237,
  "igrave;": 236,
  "iiiint;": 10764,
  "iinfin;": 10716,
  "incare;": 8453,
  "inodot;": 305,
  "intcal;": 8890,
  "iquest;": 191,
  "isinsv;": 8947,
  "itilde;": 297,
  "jsercy;": 1112,
  "kappav;": 1008,
  "kcedil;": 311,
  "kgreen;": 312,
  "lAtail;": 10523,
  "lacute;": 314,
  "lagran;": 8466,
  "lambda;": 955,
  "langle;": 10216,
  "larrfs;": 10525,
  "larrhk;": 8617,
  "larrlp;": 8619,
  "larrpl;": 10553,
  "larrtl;": 8610,
  "latail;": 10521,
  "lbrace;": 123,
  "lbrack;": 91,
  "lcaron;": 318,
  "lcedil;": 316,
  "ldquor;": 8222,
  "lesdot;": 10879,
  "lesges;": 10899,
  "lfisht;": 10620,
  "lfloor;": 8970,
  "lharul;": 10602,
  "llhard;": 10603,
  "lmidot;": 320,
  "lmoust;": 9136,
  "loplus;": 10797,
  "lowast;": 8727,
  "lowbar;": 95,
  "lparlt;": 10643,
  "lrhard;": 10605,
  "lsaquo;": 8249,
  "lsquor;": 8218,
  "lstrok;": 322,
  "lthree;": 8907,
  "ltimes;": 8905,
  "ltlarr;": 10614,
  "ltrPar;": 10646,
  "mapsto;": 8614,
  "marker;": 9646,
  "mcomma;": 10793,
  "midast;": 42,
  "midcir;": 10992,
  "middot;": 183,
  "minusb;": 8863,
  "minusd;": 8760,
  "mnplus;": 8723,
  "models;": 8871,
  "mstpos;": 8766,
  "nVDash;": 8879,
  "nVdash;": 8878,
  "nacute;": 324,
  "nbumpe;": 8783,
  "ncaron;": 328,
  "ncedil;": 326,
  "nearhk;": 10532,
  "nequiv;": 8802,
  "nesear;": 10536,
  "nexist;": 8708,
  "nltrie;": 8940,
  "notinE;": 8953,
  "nparsl;": 11005,
  "nprcue;": 8928,
  "nrarrc;": 10547,
  "nrarrw;": 8605,
  "nrtrie;": 8941,
  "nsccue;": 8929,
  "nsimeq;": 8772,
  "ntilde;": 241,
  "numero;": 8470,
  "nvDash;": 8877,
  "nvHarr;": 10500,
  "nvdash;": 8876,
  "nvlArr;": 10498,
  "nvrArr;": 10499,
  "nwarhk;": 10531,
  "nwnear;": 10535,
  "oacute;": 243,
  "odblac;": 337,
  "odsold;": 10684,
  "ograve;": 242,
  "ominus;": 8854,
  "origof;": 8886,
  "oslash;": 248,
  "otilde;": 245,
  "otimes;": 8855,
  "parsim;": 10995,
  "percnt;": 37,
  "period;": 46,
  "permil;": 8240,
  "phmmat;": 8499,
  "planck;": 8463,
  "plankv;": 8463,
  "plusdo;": 8724,
  "plusdu;": 10789,
  "plusmn;": 177,
  "preceq;": 10927,
  "primes;": 8473,
  "prnsim;": 8936,
  "propto;": 8733,
  "prurel;": 8880,
  "puncsp;": 8200,
  "qprime;": 8279,
  "rAtail;": 10524,
  "racute;": 341,
  "rangle;": 10217,
  "rarrap;": 10613,
  "rarrfs;": 10526,
  "rarrhk;": 8618,
  "rarrlp;": 8620,
  "rarrpl;": 10565,
  "rarrtl;": 8611,
  "ratail;": 10522,
  "rbrace;": 125,
  "rbrack;": 93,
  "rcaron;": 345,
  "rcedil;": 343,
  "rdquor;": 8221,
  "rfisht;": 10621,
  "rfloor;": 8971,
  "rharul;": 10604,
  "rmoust;": 9137,
  "roplus;": 10798,
  "rpargt;": 10644,
  "rsaquo;": 8250,
  "rsquor;": 8217,
  "rthree;": 8908,
  "rtimes;": 8906,
  "sacute;": 347,
  "scaron;": 353,
  "scedil;": 351,
  "scnsim;": 8937,
  "searhk;": 10533,
  "seswar;": 10537,
  "sfrown;": 8994,
  "shchcy;": 1097,
  "sigmaf;": 962,
  "sigmav;": 962,
  "simdot;": 10858,
  "smashp;": 10803,
  "softcy;": 1100,
  "solbar;": 9023,
  "spades;": 9824,
  "sqcaps;": 8851,
  "sqcups;": 8852,
  "sqsube;": 8849,
  "sqsupe;": 8850,
  "square;": 9633,
  "squarf;": 9642,
  "ssetmn;": 8726,
  "ssmile;": 8995,
  "sstarf;": 8902,
  "subdot;": 10941,
  "subset;": 8834,
  "subsim;": 10951,
  "subsub;": 10965,
  "subsup;": 10963,
  "succeq;": 10928,
  "supdot;": 10942,
  "supset;": 8835,
  "supsim;": 10952,
  "supsub;": 10964,
  "supsup;": 10966,
  "swarhk;": 10534,
  "swnwar;": 10538,
  "target;": 8982,
  "tcaron;": 357,
  "tcedil;": 355,
  "telrec;": 8981,
  "there4;": 8756,
  "thetav;": 977,
  "thinsp;": 8201,
  "thksim;": 8764,
  "timesb;": 8864,
  "timesd;": 10800,
  "topbot;": 9014,
  "topcir;": 10993,
  "tprime;": 8244,
  "tridot;": 9708,
  "tstrok;": 359,
  "uacute;": 250,
  "ubreve;": 365,
  "udblac;": 369,
  "ufisht;": 10622,
  "ugrave;": 249,
  "ulcorn;": 8988,
  "ulcrop;": 8975,
  "urcorn;": 8989,
  "urcrop;": 8974,
  "utilde;": 361,
  "vangrt;": 10652,
  "varphi;": 981,
  "varrho;": 1009,
  "veebar;": 8891,
  "vellip;": 8942,
  "verbar;": 124,
  "vsubnE;": 10955,
  "vsubne;": 8842,
  "vsupnE;": 10956,
  "vsupne;": 8843,
  "wedbar;": 10847,
  "wedgeq;": 8793,
  "weierp;": 8472,
  "wreath;": 8768,
  "xoplus;": 10753,
  "xotime;": 10754,
  "xsqcup;": 10758,
  "xuplus;": 10756,
  "xwedge;": 8896,
  "yacute;": 253,
  "zacute;": 378,
  "zcaron;": 382,
  "zeetrf;": 8488,
  "AElig;": 198,
  Aacute: 193,
  "Acirc;": 194,
  Agrave: 192,
  "Alpha;": 913,
  "Amacr;": 256,
  "Aogon;": 260,
  "Aring;": 197,
  Atilde: 195,
  "Breve;": 728,
  Ccedil: 199,
  "Ccirc;": 264,
  "Colon;": 8759,
  "Cross;": 10799,
  "Dashv;": 10980,
  "Delta;": 916,
  Eacute: 201,
  "Ecirc;": 202,
  Egrave: 200,
  "Emacr;": 274,
  "Eogon;": 280,
  "Equal;": 10869,
  "Gamma;": 915,
  "Gcirc;": 284,
  "Hacek;": 711,
  "Hcirc;": 292,
  "IJlig;": 306,
  Iacute: 205,
  "Icirc;": 206,
  Igrave: 204,
  "Imacr;": 298,
  "Iogon;": 302,
  "Iukcy;": 1030,
  "Jcirc;": 308,
  "Jukcy;": 1028,
  "Kappa;": 922,
  Ntilde: 209,
  "OElig;": 338,
  Oacute: 211,
  "Ocirc;": 212,
  Ograve: 210,
  "Omacr;": 332,
  "Omega;": 937,
  Oslash: 216,
  Otilde: 213,
  "Prime;": 8243,
  "RBarr;": 10512,
  "Scirc;": 348,
  "Sigma;": 931,
  "THORN;": 222,
  "TRADE;": 8482,
  "TSHcy;": 1035,
  "Theta;": 920,
  "Tilde;": 8764,
  Uacute: 218,
  "Ubrcy;": 1038,
  "Ucirc;": 219,
  Ugrave: 217,
  "Umacr;": 362,
  "Union;": 8899,
  "Uogon;": 370,
  "UpTee;": 8869,
  "Uring;": 366,
  "VDash;": 8875,
  "Vdash;": 8873,
  "Wcirc;": 372,
  "Wedge;": 8896,
  Yacute: 221,
  "Ycirc;": 374,
  aacute: 225,
  "acirc;": 226,
  "acute;": 180,
  "aelig;": 230,
  agrave: 224,
  "aleph;": 8501,
  "alpha;": 945,
  "amacr;": 257,
  "amalg;": 10815,
  "angle;": 8736,
  "angrt;": 8735,
  "angst;": 197,
  "aogon;": 261,
  "aring;": 229,
  "asymp;": 8776,
  atilde: 227,
  "awint;": 10769,
  "bcong;": 8780,
  "bdquo;": 8222,
  "bepsi;": 1014,
  "blank;": 9251,
  "blk12;": 9618,
  "blk14;": 9617,
  "blk34;": 9619,
  "block;": 9608,
  "boxDL;": 9559,
  "boxDR;": 9556,
  "boxDl;": 9558,
  "boxDr;": 9555,
  "boxHD;": 9574,
  "boxHU;": 9577,
  "boxHd;": 9572,
  "boxHu;": 9575,
  "boxUL;": 9565,
  "boxUR;": 9562,
  "boxUl;": 9564,
  "boxUr;": 9561,
  "boxVH;": 9580,
  "boxVL;": 9571,
  "boxVR;": 9568,
  "boxVh;": 9579,
  "boxVl;": 9570,
  "boxVr;": 9567,
  "boxdL;": 9557,
  "boxdR;": 9554,
  "boxdl;": 9488,
  "boxdr;": 9484,
  "boxhD;": 9573,
  "boxhU;": 9576,
  "boxhd;": 9516,
  "boxhu;": 9524,
  "boxuL;": 9563,
  "boxuR;": 9560,
  "boxul;": 9496,
  "boxur;": 9492,
  "boxvH;": 9578,
  "boxvL;": 9569,
  "boxvR;": 9566,
  "boxvh;": 9532,
  "boxvl;": 9508,
  "boxvr;": 9500,
  "breve;": 728,
  brvbar: 166,
  "bsemi;": 8271,
  "bsime;": 8909,
  "bsolb;": 10693,
  "bumpE;": 10926,
  "bumpe;": 8783,
  "caret;": 8257,
  "caron;": 711,
  "ccaps;": 10829,
  ccedil: 231,
  "ccirc;": 265,
  "ccups;": 10828,
  "cedil;": 184,
  "check;": 10003,
  "clubs;": 9827,
  "colon;": 58,
  "comma;": 44,
  "crarr;": 8629,
  "cross;": 10007,
  "csube;": 10961,
  "csupe;": 10962,
  "ctdot;": 8943,
  "cuepr;": 8926,
  "cuesc;": 8927,
  "cupor;": 10821,
  curren: 164,
  "cuvee;": 8910,
  "cuwed;": 8911,
  "cwint;": 8753,
  "dashv;": 8867,
  "dblac;": 733,
  "ddarr;": 8650,
  "delta;": 948,
  "dharl;": 8643,
  "dharr;": 8642,
  "diams;": 9830,
  "disin;": 8946,
  divide: 247,
  "doteq;": 8784,
  "dtdot;": 8945,
  "dtrif;": 9662,
  "duarr;": 8693,
  "duhar;": 10607,
  "eDDot;": 10871,
  eacute: 233,
  "ecirc;": 234,
  "efDot;": 8786,
  egrave: 232,
  "emacr;": 275,
  "empty;": 8709,
  "eogon;": 281,
  "eplus;": 10865,
  "epsiv;": 1013,
  "eqsim;": 8770,
  "equiv;": 8801,
  "erDot;": 8787,
  "erarr;": 10609,
  "esdot;": 8784,
  "exist;": 8707,
  "fflig;": 64256,
  "filig;": 64257,
  "fjlig;": 102,
  "fllig;": 64258,
  "fltns;": 9649,
  "forkv;": 10969,
  frac12: 189,
  frac14: 188,
  frac34: 190,
  "frasl;": 8260,
  "frown;": 8994,
  "gamma;": 947,
  "gcirc;": 285,
  "gescc;": 10921,
  "gimel;": 8503,
  "gneqq;": 8809,
  "gnsim;": 8935,
  "grave;": 96,
  "gsime;": 10894,
  "gsiml;": 10896,
  "gtcir;": 10874,
  "gtdot;": 8919,
  "harrw;": 8621,
  "hcirc;": 293,
  "hoarr;": 8703,
  iacute: 237,
  "icirc;": 238,
  "iexcl;": 161,
  igrave: 236,
  "iiint;": 8749,
  "iiota;": 8489,
  "ijlig;": 307,
  "imacr;": 299,
  "image;": 8465,
  "imath;": 305,
  "imped;": 437,
  "infin;": 8734,
  "iogon;": 303,
  "iprod;": 10812,
  iquest: 191,
  "isinE;": 8953,
  "isins;": 8948,
  "isinv;": 8712,
  "iukcy;": 1110,
  "jcirc;": 309,
  "jmath;": 567,
  "jukcy;": 1108,
  "kappa;": 954,
  "lAarr;": 8666,
  "lBarr;": 10510,
  "langd;": 10641,
  "laquo;": 171,
  "larrb;": 8676,
  "lates;": 10925,
  "lbarr;": 10508,
  "lbbrk;": 10098,
  "lbrke;": 10635,
  "lceil;": 8968,
  "ldquo;": 8220,
  "lescc;": 10920,
  "lhard;": 8637,
  "lharu;": 8636,
  "lhblk;": 9604,
  "llarr;": 8647,
  "lltri;": 9722,
  "lneqq;": 8808,
  "lnsim;": 8934,
  "loang;": 10220,
  "loarr;": 8701,
  "lobrk;": 10214,
  "lopar;": 10629,
  "lrarr;": 8646,
  "lrhar;": 8651,
  "lrtri;": 8895,
  "lsime;": 10893,
  "lsimg;": 10895,
  "lsquo;": 8216,
  "ltcir;": 10873,
  "ltdot;": 8918,
  "ltrie;": 8884,
  "ltrif;": 9666,
  "mDDot;": 8762,
  "mdash;": 8212,
  "micro;": 181,
  middot: 183,
  "minus;": 8722,
  "mumap;": 8888,
  "nabla;": 8711,
  "napid;": 8779,
  "napos;": 329,
  "natur;": 9838,
  "nbump;": 8782,
  "ncong;": 8775,
  "ndash;": 8211,
  "neArr;": 8663,
  "nearr;": 8599,
  "nedot;": 8784,
  "nesim;": 8770,
  "ngeqq;": 8807,
  "ngsim;": 8821,
  "nhArr;": 8654,
  "nharr;": 8622,
  "nhpar;": 10994,
  "nlArr;": 8653,
  "nlarr;": 8602,
  "nleqq;": 8806,
  "nless;": 8814,
  "nlsim;": 8820,
  "nltri;": 8938,
  "notin;": 8713,
  "notni;": 8716,
  "npart;": 8706,
  "nprec;": 8832,
  "nrArr;": 8655,
  "nrarr;": 8603,
  "nrtri;": 8939,
  "nsime;": 8772,
  "nsmid;": 8740,
  "nspar;": 8742,
  "nsubE;": 10949,
  "nsube;": 8840,
  "nsucc;": 8833,
  "nsupE;": 10950,
  "nsupe;": 8841,
  ntilde: 241,
  "numsp;": 8199,
  "nvsim;": 8764,
  "nwArr;": 8662,
  "nwarr;": 8598,
  oacute: 243,
  "ocirc;": 244,
  "odash;": 8861,
  "oelig;": 339,
  "ofcir;": 10687,
  ograve: 242,
  "ohbar;": 10677,
  "olarr;": 8634,
  "olcir;": 10686,
  "oline;": 8254,
  "omacr;": 333,
  "omega;": 969,
  "operp;": 10681,
  "oplus;": 8853,
  "orarr;": 8635,
  "order;": 8500,
  oslash: 248,
  otilde: 245,
  "ovbar;": 9021,
  "parsl;": 11005,
  "phone;": 9742,
  "plusb;": 8862,
  "pluse;": 10866,
  plusmn: 177,
  "pound;": 163,
  "prcue;": 8828,
  "prime;": 8242,
  "prnap;": 10937,
  "prsim;": 8830,
  "quest;": 63,
  "rAarr;": 8667,
  "rBarr;": 10511,
  "radic;": 8730,
  "rangd;": 10642,
  "range;": 10661,
  "raquo;": 187,
  "rarrb;": 8677,
  "rarrc;": 10547,
  "rarrw;": 8605,
  "ratio;": 8758,
  "rbarr;": 10509,
  "rbbrk;": 10099,
  "rbrke;": 10636,
  "rceil;": 8969,
  "rdquo;": 8221,
  "reals;": 8477,
  "rhard;": 8641,
  "rharu;": 8640,
  "rlarr;": 8644,
  "rlhar;": 8652,
  "rnmid;": 10990,
  "roang;": 10221,
  "roarr;": 8702,
  "robrk;": 10215,
  "ropar;": 10630,
  "rrarr;": 8649,
  "rsquo;": 8217,
  "rtrie;": 8885,
  "rtrif;": 9656,
  "sbquo;": 8218,
  "sccue;": 8829,
  "scirc;": 349,
  "scnap;": 10938,
  "scsim;": 8831,
  "sdotb;": 8865,
  "sdote;": 10854,
  "seArr;": 8664,
  "searr;": 8600,
  "setmn;": 8726,
  "sharp;": 9839,
  "sigma;": 963,
  "simeq;": 8771,
  "simgE;": 10912,
  "simlE;": 10911,
  "simne;": 8774,
  "slarr;": 8592,
  "smile;": 8995,
  "smtes;": 10924,
  "sqcap;": 8851,
  "sqcup;": 8852,
  "sqsub;": 8847,
  "sqsup;": 8848,
  "srarr;": 8594,
  "starf;": 9733,
  "strns;": 175,
  "subnE;": 10955,
  "subne;": 8842,
  "supnE;": 10956,
  "supne;": 8843,
  "swArr;": 8665,
  "swarr;": 8601,
  "szlig;": 223,
  "theta;": 952,
  "thkap;": 8776,
  "thorn;": 254,
  "tilde;": 732,
  "times;": 215,
  "trade;": 8482,
  "trisb;": 10701,
  "tshcy;": 1115,
  "twixt;": 8812,
  uacute: 250,
  "ubrcy;": 1118,
  "ucirc;": 251,
  "udarr;": 8645,
  "udhar;": 10606,
  ugrave: 249,
  "uharl;": 8639,
  "uharr;": 8638,
  "uhblk;": 9600,
  "ultri;": 9720,
  "umacr;": 363,
  "uogon;": 371,
  "uplus;": 8846,
  "upsih;": 978,
  "uring;": 367,
  "urtri;": 9721,
  "utdot;": 8944,
  "utrif;": 9652,
  "uuarr;": 8648,
  "vBarv;": 10985,
  "vDash;": 8872,
  "varpi;": 982,
  "vdash;": 8866,
  "veeeq;": 8794,
  "vltri;": 8882,
  "vnsub;": 8834,
  "vnsup;": 8835,
  "vprop;": 8733,
  "vrtri;": 8883,
  "wcirc;": 373,
  "wedge;": 8743,
  "xcirc;": 9711,
  "xdtri;": 9661,
  "xhArr;": 10234,
  "xharr;": 10231,
  "xlArr;": 10232,
  "xlarr;": 10229,
  "xodot;": 10752,
  "xrArr;": 10233,
  "xrarr;": 10230,
  "xutri;": 9651,
  yacute: 253,
  "ycirc;": 375,
  AElig: 198,
  Acirc: 194,
  "Aopf;": 120120,
  Aring: 197,
  "Ascr;": 119964,
  "Auml;": 196,
  "Barv;": 10983,
  "Beta;": 914,
  "Bopf;": 120121,
  "Bscr;": 8492,
  "CHcy;": 1063,
  "COPY;": 169,
  "Cdot;": 266,
  "Copf;": 8450,
  "Cscr;": 119966,
  "DJcy;": 1026,
  "DScy;": 1029,
  "DZcy;": 1039,
  "Darr;": 8609,
  "Dopf;": 120123,
  "Dscr;": 119967,
  Ecirc: 202,
  "Edot;": 278,
  "Eopf;": 120124,
  "Escr;": 8496,
  "Esim;": 10867,
  "Euml;": 203,
  "Fopf;": 120125,
  "Fscr;": 8497,
  "GJcy;": 1027,
  "Gdot;": 288,
  "Gopf;": 120126,
  "Gscr;": 119970,
  "Hopf;": 8461,
  "Hscr;": 8459,
  "IEcy;": 1045,
  "IOcy;": 1025,
  Icirc: 206,
  "Idot;": 304,
  "Iopf;": 120128,
  "Iota;": 921,
  "Iscr;": 8464,
  "Iuml;": 207,
  "Jopf;": 120129,
  "Jscr;": 119973,
  "KHcy;": 1061,
  "KJcy;": 1036,
  "Kopf;": 120130,
  "Kscr;": 119974,
  "LJcy;": 1033,
  "Lang;": 10218,
  "Larr;": 8606,
  "Lopf;": 120131,
  "Lscr;": 8466,
  "Mopf;": 120132,
  "Mscr;": 8499,
  "NJcy;": 1034,
  "Nopf;": 8469,
  "Nscr;": 119977,
  Ocirc: 212,
  "Oopf;": 120134,
  "Oscr;": 119978,
  "Ouml;": 214,
  "Popf;": 8473,
  "Pscr;": 119979,
  "QUOT;": 34,
  "Qopf;": 8474,
  "Qscr;": 119980,
  "Rang;": 10219,
  "Rarr;": 8608,
  "Ropf;": 8477,
  "Rscr;": 8475,
  "SHcy;": 1064,
  "Sopf;": 120138,
  "Sqrt;": 8730,
  "Sscr;": 119982,
  "Star;": 8902,
  THORN: 222,
  "TScy;": 1062,
  "Topf;": 120139,
  "Tscr;": 119983,
  "Uarr;": 8607,
  Ucirc: 219,
  "Uopf;": 120140,
  "Upsi;": 978,
  "Uscr;": 119984,
  "Uuml;": 220,
  "Vbar;": 10987,
  "Vert;": 8214,
  "Vopf;": 120141,
  "Vscr;": 119985,
  "Wopf;": 120142,
  "Wscr;": 119986,
  "Xopf;": 120143,
  "Xscr;": 119987,
  "YAcy;": 1071,
  "YIcy;": 1031,
  "YUcy;": 1070,
  "Yopf;": 120144,
  "Yscr;": 119988,
  "Yuml;": 376,
  "ZHcy;": 1046,
  "Zdot;": 379,
  "Zeta;": 918,
  "Zopf;": 8484,
  "Zscr;": 119989,
  acirc: 226,
  acute: 180,
  aelig: 230,
  "andd;": 10844,
  "andv;": 10842,
  "ange;": 10660,
  "aopf;": 120146,
  "apid;": 8779,
  "apos;": 39,
  aring: 229,
  "ascr;": 119990,
  "auml;": 228,
  "bNot;": 10989,
  "bbrk;": 9141,
  "beta;": 946,
  "beth;": 8502,
  "bnot;": 8976,
  "bopf;": 120147,
  "boxH;": 9552,
  "boxV;": 9553,
  "boxh;": 9472,
  "boxv;": 9474,
  "bscr;": 119991,
  "bsim;": 8765,
  "bsol;": 92,
  "bull;": 8226,
  "bump;": 8782,
  "caps;": 8745,
  "cdot;": 267,
  cedil: 184,
  "cent;": 162,
  "chcy;": 1095,
  "cirE;": 10691,
  "circ;": 710,
  "cire;": 8791,
  "comp;": 8705,
  "cong;": 8773,
  "copf;": 120148,
  "copy;": 169,
  "cscr;": 119992,
  "csub;": 10959,
  "csup;": 10960,
  "cups;": 8746,
  "dArr;": 8659,
  "dHar;": 10597,
  "darr;": 8595,
  "dash;": 8208,
  "diam;": 8900,
  "djcy;": 1106,
  "dopf;": 120149,
  "dscr;": 119993,
  "dscy;": 1109,
  "dsol;": 10742,
  "dtri;": 9663,
  "dzcy;": 1119,
  "eDot;": 8785,
  "ecir;": 8790,
  ecirc: 234,
  "edot;": 279,
  "emsp;": 8195,
  "ensp;": 8194,
  "eopf;": 120150,
  "epar;": 8917,
  "epsi;": 949,
  "escr;": 8495,
  "esim;": 8770,
  "euml;": 235,
  "euro;": 8364,
  "excl;": 33,
  "flat;": 9837,
  "fnof;": 402,
  "fopf;": 120151,
  "fork;": 8916,
  "fscr;": 119995,
  "gdot;": 289,
  "geqq;": 8807,
  "gesl;": 8923,
  "gjcy;": 1107,
  "gnap;": 10890,
  "gneq;": 10888,
  "gopf;": 120152,
  "gscr;": 8458,
  "gsim;": 8819,
  "gtcc;": 10919,
  "gvnE;": 8809,
  "hArr;": 8660,
  "half;": 189,
  "harr;": 8596,
  "hbar;": 8463,
  "hopf;": 120153,
  "hscr;": 119997,
  icirc: 238,
  "iecy;": 1077,
  iexcl: 161,
  "imof;": 8887,
  "iocy;": 1105,
  "iopf;": 120154,
  "iota;": 953,
  "iscr;": 119998,
  "isin;": 8712,
  "iuml;": 239,
  "jopf;": 120155,
  "jscr;": 119999,
  "khcy;": 1093,
  "kjcy;": 1116,
  "kopf;": 120156,
  "kscr;": 12e4,
  "lArr;": 8656,
  "lHar;": 10594,
  "lang;": 10216,
  laquo: 171,
  "larr;": 8592,
  "late;": 10925,
  "lcub;": 123,
  "ldca;": 10550,
  "ldsh;": 8626,
  "leqq;": 8806,
  "lesg;": 8922,
  "ljcy;": 1113,
  "lnap;": 10889,
  "lneq;": 10887,
  "lopf;": 120157,
  "lozf;": 10731,
  "lpar;": 40,
  "lscr;": 120001,
  "lsim;": 8818,
  "lsqb;": 91,
  "ltcc;": 10918,
  "ltri;": 9667,
  "lvnE;": 8808,
  "macr;": 175,
  "male;": 9794,
  "malt;": 10016,
  micro: 181,
  "mlcp;": 10971,
  "mldr;": 8230,
  "mopf;": 120158,
  "mscr;": 120002,
  "nGtv;": 8811,
  "nLtv;": 8810,
  "nang;": 8736,
  "napE;": 10864,
  "nbsp;": 160,
  "ncap;": 10819,
  "ncup;": 10818,
  "ngeq;": 8817,
  "nges;": 10878,
  "ngtr;": 8815,
  "nisd;": 8954,
  "njcy;": 1114,
  "nldr;": 8229,
  "nleq;": 8816,
  "nles;": 10877,
  "nmid;": 8740,
  "nopf;": 120159,
  "npar;": 8742,
  "npre;": 10927,
  "nsce;": 10928,
  "nscr;": 120003,
  "nsim;": 8769,
  "nsub;": 8836,
  "nsup;": 8837,
  "ntgl;": 8825,
  "ntlg;": 8824,
  "nvap;": 8781,
  "nvge;": 8805,
  "nvgt;": 62,
  "nvle;": 8804,
  "nvlt;": 60,
  "oast;": 8859,
  "ocir;": 8858,
  ocirc: 244,
  "odiv;": 10808,
  "odot;": 8857,
  "ogon;": 731,
  "oint;": 8750,
  "omid;": 10678,
  "oopf;": 120160,
  "opar;": 10679,
  "ordf;": 170,
  "ordm;": 186,
  "oror;": 10838,
  "oscr;": 8500,
  "osol;": 8856,
  "ouml;": 246,
  "para;": 182,
  "part;": 8706,
  "perp;": 8869,
  "phiv;": 981,
  "plus;": 43,
  "popf;": 120161,
  pound: 163,
  "prap;": 10935,
  "prec;": 8826,
  "prnE;": 10933,
  "prod;": 8719,
  "prop;": 8733,
  "pscr;": 120005,
  "qint;": 10764,
  "qopf;": 120162,
  "qscr;": 120006,
  "quot;": 34,
  "rArr;": 8658,
  "rHar;": 10596,
  "race;": 8765,
  "rang;": 10217,
  raquo: 187,
  "rarr;": 8594,
  "rcub;": 125,
  "rdca;": 10551,
  "rdsh;": 8627,
  "real;": 8476,
  "rect;": 9645,
  "rhov;": 1009,
  "ring;": 730,
  "ropf;": 120163,
  "rpar;": 41,
  "rscr;": 120007,
  "rsqb;": 93,
  "rtri;": 9657,
  "scap;": 10936,
  "scnE;": 10934,
  "sdot;": 8901,
  "sect;": 167,
  "semi;": 59,
  "sext;": 10038,
  "shcy;": 1096,
  "sime;": 8771,
  "simg;": 10910,
  "siml;": 10909,
  "smid;": 8739,
  "smte;": 10924,
  "solb;": 10692,
  "sopf;": 120164,
  "spar;": 8741,
  "squf;": 9642,
  "sscr;": 120008,
  "star;": 9734,
  "subE;": 10949,
  "sube;": 8838,
  "succ;": 8827,
  "sung;": 9834,
  "sup1;": 185,
  "sup2;": 178,
  "sup3;": 179,
  "supE;": 10950,
  "supe;": 8839,
  szlig: 223,
  "tbrk;": 9140,
  "tdot;": 8411,
  thorn: 254,
  times: 215,
  "tint;": 8749,
  "toea;": 10536,
  "topf;": 120165,
  "tosa;": 10537,
  "trie;": 8796,
  "tscr;": 120009,
  "tscy;": 1094,
  "uArr;": 8657,
  "uHar;": 10595,
  "uarr;": 8593,
  ucirc: 251,
  "uopf;": 120166,
  "upsi;": 965,
  "uscr;": 120010,
  "utri;": 9653,
  "uuml;": 252,
  "vArr;": 8661,
  "vBar;": 10984,
  "varr;": 8597,
  "vert;": 124,
  "vopf;": 120167,
  "vscr;": 120011,
  "wopf;": 120168,
  "wscr;": 120012,
  "xcap;": 8898,
  "xcup;": 8899,
  "xmap;": 10236,
  "xnis;": 8955,
  "xopf;": 120169,
  "xscr;": 120013,
  "xvee;": 8897,
  "yacy;": 1103,
  "yicy;": 1111,
  "yopf;": 120170,
  "yscr;": 120014,
  "yucy;": 1102,
  "yuml;": 255,
  "zdot;": 380,
  "zeta;": 950,
  "zhcy;": 1078,
  "zopf;": 120171,
  "zscr;": 120015,
  "zwnj;": 8204,
  "AMP;": 38,
  "Acy;": 1040,
  "Afr;": 120068,
  "And;": 10835,
  Auml: 196,
  "Bcy;": 1041,
  "Bfr;": 120069,
  COPY: 169,
  "Cap;": 8914,
  "Cfr;": 8493,
  "Chi;": 935,
  "Cup;": 8915,
  "Dcy;": 1044,
  "Del;": 8711,
  "Dfr;": 120071,
  "Dot;": 168,
  "ENG;": 330,
  "ETH;": 208,
  "Ecy;": 1069,
  "Efr;": 120072,
  "Eta;": 919,
  Euml: 203,
  "Fcy;": 1060,
  "Ffr;": 120073,
  "Gcy;": 1043,
  "Gfr;": 120074,
  "Hat;": 94,
  "Hfr;": 8460,
  "Icy;": 1048,
  "Ifr;": 8465,
  "Int;": 8748,
  Iuml: 207,
  "Jcy;": 1049,
  "Jfr;": 120077,
  "Kcy;": 1050,
  "Kfr;": 120078,
  "Lcy;": 1051,
  "Lfr;": 120079,
  "Lsh;": 8624,
  "Map;": 10501,
  "Mcy;": 1052,
  "Mfr;": 120080,
  "Ncy;": 1053,
  "Nfr;": 120081,
  "Not;": 10988,
  "Ocy;": 1054,
  "Ofr;": 120082,
  Ouml: 214,
  "Pcy;": 1055,
  "Pfr;": 120083,
  "Phi;": 934,
  "Psi;": 936,
  QUOT: 34,
  "Qfr;": 120084,
  "REG;": 174,
  "Rcy;": 1056,
  "Rfr;": 8476,
  "Rho;": 929,
  "Rsh;": 8625,
  "Scy;": 1057,
  "Sfr;": 120086,
  "Sub;": 8912,
  "Sum;": 8721,
  "Sup;": 8913,
  "Tab;": 9,
  "Tau;": 932,
  "Tcy;": 1058,
  "Tfr;": 120087,
  "Ucy;": 1059,
  "Ufr;": 120088,
  Uuml: 220,
  "Vcy;": 1042,
  "Vee;": 8897,
  "Vfr;": 120089,
  "Wfr;": 120090,
  "Xfr;": 120091,
  "Ycy;": 1067,
  "Yfr;": 120092,
  "Zcy;": 1047,
  "Zfr;": 8488,
  "acE;": 8766,
  "acd;": 8767,
  "acy;": 1072,
  "afr;": 120094,
  "amp;": 38,
  "and;": 8743,
  "ang;": 8736,
  "apE;": 10864,
  "ape;": 8778,
  "ast;": 42,
  auml: 228,
  "bcy;": 1073,
  "bfr;": 120095,
  "bne;": 61,
  "bot;": 8869,
  "cap;": 8745,
  cent: 162,
  "cfr;": 120096,
  "chi;": 967,
  "cir;": 9675,
  copy: 169,
  "cup;": 8746,
  "dcy;": 1076,
  "deg;": 176,
  "dfr;": 120097,
  "die;": 168,
  "div;": 247,
  "dot;": 729,
  "ecy;": 1101,
  "efr;": 120098,
  "egs;": 10902,
  "ell;": 8467,
  "els;": 10901,
  "eng;": 331,
  "eta;": 951,
  "eth;": 240,
  euml: 235,
  "fcy;": 1092,
  "ffr;": 120099,
  "gEl;": 10892,
  "gap;": 10886,
  "gcy;": 1075,
  "gel;": 8923,
  "geq;": 8805,
  "ges;": 10878,
  "gfr;": 120100,
  "ggg;": 8921,
  "glE;": 10898,
  "gla;": 10917,
  "glj;": 10916,
  "gnE;": 8809,
  "gne;": 10888,
  "hfr;": 120101,
  "icy;": 1080,
  "iff;": 8660,
  "ifr;": 120102,
  "int;": 8747,
  iuml: 239,
  "jcy;": 1081,
  "jfr;": 120103,
  "kcy;": 1082,
  "kfr;": 120104,
  "lEg;": 10891,
  "lap;": 10885,
  "lat;": 10923,
  "lcy;": 1083,
  "leg;": 8922,
  "leq;": 8804,
  "les;": 10877,
  "lfr;": 120105,
  "lgE;": 10897,
  "lnE;": 8808,
  "lne;": 10887,
  "loz;": 9674,
  "lrm;": 8206,
  "lsh;": 8624,
  macr: 175,
  "map;": 8614,
  "mcy;": 1084,
  "mfr;": 120106,
  "mho;": 8487,
  "mid;": 8739,
  "nGg;": 8921,
  "nGt;": 8811,
  "nLl;": 8920,
  "nLt;": 8810,
  "nap;": 8777,
  nbsp: 160,
  "ncy;": 1085,
  "nfr;": 120107,
  "ngE;": 8807,
  "nge;": 8817,
  "ngt;": 8815,
  "nis;": 8956,
  "niv;": 8715,
  "nlE;": 8806,
  "nle;": 8816,
  "nlt;": 8814,
  "not;": 172,
  "npr;": 8832,
  "nsc;": 8833,
  "num;": 35,
  "ocy;": 1086,
  "ofr;": 120108,
  "ogt;": 10689,
  "ohm;": 937,
  "olt;": 10688,
  "ord;": 10845,
  ordf: 170,
  ordm: 186,
  "orv;": 10843,
  ouml: 246,
  "par;": 8741,
  para: 182,
  "pcy;": 1087,
  "pfr;": 120109,
  "phi;": 966,
  "piv;": 982,
  "prE;": 10931,
  "pre;": 10927,
  "psi;": 968,
  "qfr;": 120110,
  quot: 34,
  "rcy;": 1088,
  "reg;": 174,
  "rfr;": 120111,
  "rho;": 961,
  "rlm;": 8207,
  "rsh;": 8625,
  "scE;": 10932,
  "sce;": 10928,
  "scy;": 1089,
  sect: 167,
  "sfr;": 120112,
  "shy;": 173,
  "sim;": 8764,
  "smt;": 10922,
  "sol;": 47,
  "squ;": 9633,
  "sub;": 8834,
  "sum;": 8721,
  sup1: 185,
  sup2: 178,
  sup3: 179,
  "sup;": 8835,
  "tau;": 964,
  "tcy;": 1090,
  "tfr;": 120113,
  "top;": 8868,
  "ucy;": 1091,
  "ufr;": 120114,
  "uml;": 168,
  uuml: 252,
  "vcy;": 1074,
  "vee;": 8744,
  "vfr;": 120115,
  "wfr;": 120116,
  "xfr;": 120117,
  "ycy;": 1099,
  "yen;": 165,
  "yfr;": 120118,
  yuml: 255,
  "zcy;": 1079,
  "zfr;": 120119,
  "zwj;": 8205,
  AMP: 38,
  "DD;": 8517,
  ETH: 208,
  "GT;": 62,
  "Gg;": 8921,
  "Gt;": 8811,
  "Im;": 8465,
  "LT;": 60,
  "Ll;": 8920,
  "Lt;": 8810,
  "Mu;": 924,
  "Nu;": 925,
  "Or;": 10836,
  "Pi;": 928,
  "Pr;": 10939,
  REG: 174,
  "Re;": 8476,
  "Sc;": 10940,
  "Xi;": 926,
  "ac;": 8766,
  "af;": 8289,
  amp: 38,
  "ap;": 8776,
  "dd;": 8518,
  deg: 176,
  "ee;": 8519,
  "eg;": 10906,
  "el;": 10905,
  eth: 240,
  "gE;": 8807,
  "ge;": 8805,
  "gg;": 8811,
  "gl;": 8823,
  "gt;": 62,
  "ic;": 8291,
  "ii;": 8520,
  "in;": 8712,
  "it;": 8290,
  "lE;": 8806,
  "le;": 8804,
  "lg;": 8822,
  "ll;": 8810,
  "lt;": 60,
  "mp;": 8723,
  "mu;": 956,
  "ne;": 8800,
  "ni;": 8715,
  not: 172,
  "nu;": 957,
  "oS;": 9416,
  "or;": 8744,
  "pi;": 960,
  "pm;": 177,
  "pr;": 8826,
  reg: 174,
  "rx;": 8478,
  "sc;": 8827,
  shy: 173,
  uml: 168,
  "wp;": 8472,
  "wr;": 8768,
  "xi;": 958,
  yen: 165,
  GT: 62,
  LT: 60,
  gt: 62,
  lt: 60
};

// node_modules/.deno/svelte@5.43.8/node_modules/svelte/src/compiler/phases/1-parse/utils/html.js
var windows_1252 = [
  8364,
  129,
  8218,
  402,
  8222,
  8230,
  8224,
  8225,
  710,
  8240,
  352,
  8249,
  338,
  141,
  381,
  143,
  144,
  8216,
  8217,
  8220,
  8221,
  8226,
  8211,
  8212,
  732,
  8482,
  353,
  8250,
  339,
  157,
  382,
  376
];
function reg_exp_entity(entity_name, is_attribute_value) {
  if (is_attribute_value && !entity_name.endsWith(";")) {
    return `${entity_name}\\b(?!=)`;
  }
  return entity_name;
}
function get_entity_pattern(is_attribute_value) {
  const reg_exp_num = "#(?:x[a-fA-F\\d]+|\\d+)(?:;)?";
  const reg_exp_entities = Object.keys(entities_default).map(
    /** @param {any} entity_name */
    (entity_name) => reg_exp_entity(entity_name, is_attribute_value)
  );
  const entity_pattern = new RegExp(`&(${reg_exp_num}|${reg_exp_entities.join("|")})`, "g");
  return entity_pattern;
}
var entity_pattern_content = get_entity_pattern(false);
var entity_pattern_attr_value = get_entity_pattern(true);
function decode_character_references(html2, is_attribute_value) {
  const entity_pattern = is_attribute_value ? entity_pattern_attr_value : entity_pattern_content;
  return html2.replace(
    entity_pattern,
    /**
     * @param {any} match
     * @param {keyof typeof entities} entity
     */
    (match, entity) => {
      let code2;
      if (entity[0] !== "#") {
        code2 = entities_default[entity];
      } else if (entity[1] === "x") {
        code2 = parseInt(entity.substring(2), 16);
      } else {
        code2 = parseInt(entity.substring(1), 10);
      }
      if (!code2) {
        return match;
      }
      return String.fromCodePoint(validate_code(code2));
    }
  );
}
var NUL = 0;
function validate_code(code2) {
  if (code2 === 10) {
    return 32;
  }
  if (code2 < 128) {
    return code2;
  }
  if (code2 <= 159) {
    return windows_1252[code2 - 128];
  }
  if (code2 < 55296) {
    return code2;
  }
  if (code2 <= 57343) {
    return NUL;
  }
  if (code2 <= 65535) {
    return code2;
  }
  if (code2 >= 65536 && code2 <= 131071) {
    return code2;
  }
  if (code2 >= 131072 && code2 <= 196607) {
    return code2;
  }
  if (code2 >= 917504 && code2 <= 917631 || code2 >= 917760 && code2 <= 917999) {
    return code2;
  }
  return NUL;
}

// node_modules/.deno/svelte@5.43.8/node_modules/svelte/src/compiler/phases/1-parse/utils/create.js
function create_fragment(transparent = false) {
  return {
    type: "Fragment",
    nodes: [],
    metadata: {
      transparent,
      dynamic: false,
      has_await: false
    }
  };
}

// node_modules/.deno/svelte@5.43.8/node_modules/svelte/src/compiler/phases/nodes.js
var element_nodes = [
  "SvelteElement",
  "RegularElement",
  "SvelteFragment",
  "Component",
  "SvelteComponent",
  "SvelteSelf",
  "SlotElement"
];
function is_element_node(node) {
  return element_nodes.includes(node.type);
}
function create_attribute(name2, start2, end2, value) {
  return {
    type: "Attribute",
    start: start2,
    end: end2,
    name: name2,
    value,
    metadata: {
      delegated: false,
      needs_clsx: false
    }
  };
}
var ExpressionMetadata = class {
  /** True if the expression references state directly, or _might_ (via member/call expressions) */
  has_state = false;
  /** True if the expression involves a call expression (often, it will need to be wrapped in a derived) */
  has_call = false;
  /** True if the expression contains `await` */
  has_await = false;
  /** True if the expression includes a member expression */
  has_member_expression = false;
  /** True if the expression includes an assignment or an update */
  has_assignment = false;
  /**
   * All the bindings that are referenced eagerly (not inside functions) in this expression
   * @type {Set<Binding>}
   */
  dependencies = /* @__PURE__ */ new Set();
  /**
   * True if the expression references state directly, or _might_ (via member/call expressions)
   * @type {Set<Binding>}
   */
  references = /* @__PURE__ */ new Set();
  /** @type {null | Set<Expression>} */
  #blockers = null;
  #get_blockers() {
    if (!this.#blockers) {
      this.#blockers = /* @__PURE__ */ new Set();
      for (const d of this.dependencies) {
        if (d.blocker) this.#blockers.add(d.blocker);
      }
    }
    return this.#blockers;
  }
  blockers() {
    return array([...this.#get_blockers()]);
  }
  is_async() {
    return this.has_await || this.#get_blockers().size > 0;
  }
  /**
   * @param {ExpressionMetadata} source
   */
  merge(source2) {
    this.has_state ||= source2.has_state;
    this.has_call ||= source2.has_call;
    this.has_await ||= source2.has_await;
    this.has_member_expression ||= source2.has_member_expression;
    this.has_assignment ||= source2.has_assignment;
    this.#blockers = null;
    for (const r of source2.references) this.references.add(r);
    for (const b of source2.dependencies) this.dependencies.add(b);
  }
};

// node_modules/.deno/svelte@5.43.8/node_modules/svelte/src/html-tree-validation.js
var autoclosing_children = {
  // based on http://developers.whatwg.org/syntax.html#syntax-tag-omission
  li: { direct: ["li"] },
  // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dt#technical_summary
  dt: { descendant: ["dt", "dd"], reset_by: ["dl"] },
  dd: { descendant: ["dt", "dd"], reset_by: ["dl"] },
  p: {
    descendant: [
      "address",
      "article",
      "aside",
      "blockquote",
      "div",
      "dl",
      "fieldset",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "header",
      "hgroup",
      "hr",
      "main",
      "menu",
      "nav",
      "ol",
      "p",
      "pre",
      "section",
      "table",
      "ul"
    ]
  },
  rt: { descendant: ["rt", "rp"] },
  rp: { descendant: ["rt", "rp"] },
  optgroup: { descendant: ["optgroup"] },
  option: { descendant: ["option", "optgroup"] },
  thead: { direct: ["tbody", "tfoot"] },
  tbody: { direct: ["tbody", "tfoot"] },
  tfoot: { direct: ["tbody"] },
  tr: { direct: ["tr", "tbody"] },
  td: { direct: ["td", "th", "tr"] },
  th: { direct: ["td", "th", "tr"] }
};
function closing_tag_omitted(current2, next2) {
  const disallowed2 = autoclosing_children[current2];
  if (disallowed2) {
    if (!next2 || ("direct" in disallowed2 ? disallowed2.direct : disallowed2.descendant).includes(next2)) {
      return true;
    }
  }
  return false;
}
var disallowed_children = {
  ...autoclosing_children,
  optgroup: { only: ["option", "#text"] },
  // Strictly speaking, seeing an <option> doesn't mean we're in a <select>, but we assume it here
  option: { only: ["#text"] },
  form: { descendant: ["form"] },
  a: { descendant: ["a"] },
  button: { descendant: ["button"] },
  h1: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
  h2: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
  h3: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
  h4: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
  h5: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
  h6: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
  select: { only: ["option", "optgroup", "#text", "hr", "script", "template"] },
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
  // No special behavior since these rules fall back to "in body" mode for
  // all except special table nodes which cause bad parsing behavior anyway.
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
  tr: { only: ["th", "td", "style", "script", "template"] },
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
  tbody: { only: ["tr", "style", "script", "template"] },
  thead: { only: ["tr", "style", "script", "template"] },
  tfoot: { only: ["tr", "style", "script", "template"] },
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
  colgroup: { only: ["col", "template"] },
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
  table: {
    only: ["caption", "colgroup", "tbody", "thead", "tfoot", "style", "script", "template"]
  },
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
  head: {
    only: [
      "base",
      "basefont",
      "bgsound",
      "link",
      "meta",
      "title",
      "noscript",
      "noframes",
      "style",
      "script",
      "template"
    ]
  },
  // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
  html: { only: ["head", "body", "frameset"] },
  frameset: { only: ["frame"] },
  "#document": { only: ["html"] }
};

// node_modules/.deno/svelte@5.43.8/node_modules/svelte/src/compiler/utils/string.js
function list(strings, conjunction = "or") {
  if (strings.length === 1) return strings[0];
  if (strings.length === 2) return `${strings[0]} ${conjunction} ${strings[1]}`;
  return `${strings.slice(0, -1).join(", ")} ${conjunction} ${strings[strings.length - 1]}`;
}

// node_modules/.deno/svelte@5.43.8/node_modules/svelte/src/compiler/phases/1-parse/state/element.js
var regex_invalid_unquoted_attribute_value = /^(\/>|[\s"'=<>`])/;
var regex_closing_textarea_tag = /^<\/textarea(\s[^>]*)?>/i;
var regex_closing_comment = /-->/;
var regex_whitespace_or_slash_or_closing_tag = /(\s|\/|>)/;
var regex_token_ending_character = /[\s=/>"']/;
var regex_starts_with_quote_characters = /^["']/;
var regex_attribute_value = /^(?:"([^"]*)"|'([^'])*'|([^>\s]+))/;
var regex_valid_element_name = /^(?:![a-zA-Z]+|[a-zA-Z](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?|[a-zA-Z][a-zA-Z0-9]*:[a-zA-Z][a-zA-Z0-9-]*[a-zA-Z0-9])$/;
var regex_valid_component_name = (
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#identifiers adjusted for our needs
  // (must start with uppercase letter if no dots, can contain dots)
  new RegExp("^(?:\\p{Lu}[$\\u200c\\u200d\\p{ID_Continue}.]*|\\p{ID_Start}[$\\u200c\\u200d\\p{ID_Continue}]*(?:\\.[$\\u200c\\u200d\\p{ID_Continue}]+)+)$", "u")
);
var root_only_meta_tags = /* @__PURE__ */ new Map([
  ["svelte:head", "SvelteHead"],
  ["svelte:options", "SvelteOptions"],
  ["svelte:window", "SvelteWindow"],
  ["svelte:document", "SvelteDocument"],
  ["svelte:body", "SvelteBody"]
]);
var meta_tags = new Map([
  ...root_only_meta_tags,
  ["svelte:element", "SvelteElement"],
  ["svelte:component", "SvelteComponent"],
  ["svelte:self", "SvelteSelf"],
  ["svelte:fragment", "SvelteFragment"],
  ["svelte:boundary", "SvelteBoundary"]
]);
function element(parser2) {
  const start2 = parser2.index++;
  let parent = parser2.current();
  if (parser2.eat("!--")) {
    const data3 = parser2.read_until(regex_closing_comment);
    parser2.eat("-->", true);
    parser2.append({
      type: "Comment",
      start: start2,
      end: parser2.index,
      data: data3
    });
    return;
  }
  const is_closing_tag = parser2.eat("/");
  const name2 = parser2.read_until(regex_whitespace_or_slash_or_closing_tag);
  if (is_closing_tag) {
    parser2.allow_whitespace();
    parser2.eat(">", true);
    if (is_void(name2)) {
      void_element_invalid_content(start2);
    }
    while (
      /** @type {AST.RegularElement} */
      parent.name !== name2
    ) {
      if (parser2.loose) {
        if (is_element_node(parent)) {
          const last = parent.attributes.at(-1);
          if (last?.type === "Attribute" && last.name === `<${name2}`) {
            parser2.index = last.start;
            parent.attributes.pop();
            break;
          }
        }
      }
      if (parent.type === "RegularElement") {
        if (!parser2.last_auto_closed_tag || parser2.last_auto_closed_tag.tag !== name2) {
          const end2 = parent.fragment.nodes[0]?.start ?? start2;
          element_implicitly_closed(
            { start: parent.start, end: end2 },
            `</${name2}>`,
            `</${parent.name}>`
          );
        }
      } else if (!parser2.loose) {
        if (parser2.last_auto_closed_tag && parser2.last_auto_closed_tag.tag === name2) {
          element_invalid_closing_tag_autoclosed(start2, name2, parser2.last_auto_closed_tag.reason);
        } else {
          element_invalid_closing_tag(start2, name2);
        }
      }
      parent.end = start2;
      parser2.pop();
      parent = parser2.current();
    }
    parent.end = parser2.index;
    parser2.pop();
    if (parser2.last_auto_closed_tag && parser2.stack.length < parser2.last_auto_closed_tag.depth) {
      parser2.last_auto_closed_tag = void 0;
    }
    return;
  }
  if (name2.startsWith("svelte:") && !meta_tags.has(name2)) {
    const bounds = { start: start2 + 1, end: start2 + 1 + name2.length };
    svelte_meta_invalid_tag(bounds, list(Array.from(meta_tags.keys())));
  }
  if (!regex_valid_element_name.test(name2) && !regex_valid_component_name.test(name2)) {
    if (!parser2.loose || !name2.endsWith(".")) {
      const bounds = { start: start2 + 1, end: start2 + 1 + name2.length };
      tag_invalid_name(bounds);
    }
  }
  if (root_only_meta_tags.has(name2)) {
    if (name2 in parser2.meta_tags) {
      svelte_meta_duplicate(start2, name2);
    }
    if (parent.type !== "Root") {
      svelte_meta_invalid_placement(start2, name2);
    }
    parser2.meta_tags[name2] = true;
  }
  const type2 = meta_tags.has(name2) ? meta_tags.get(name2) : regex_valid_component_name.test(name2) || parser2.loose && name2.endsWith(".") ? "Component" : name2 === "title" && parent_is_head(parser2.stack) ? "TitleElement" : (
    // TODO Svelte 6/7: once slots are removed in favor of snippets, always keep slot as a regular element
    name2 === "slot" && !parent_is_shadowroot_template(parser2.stack) ? "SlotElement" : "RegularElement"
  );
  const element3 = type2 === "RegularElement" ? {
    type: type2,
    start: start2,
    end: -1,
    name: name2,
    attributes: [],
    fragment: create_fragment(true),
    metadata: {
      svg: false,
      mathml: false,
      scoped: false,
      has_spread: false,
      path: [],
      synthetic_value_node: null
    }
  } : (
    /** @type {AST.ElementLike} */
    {
      type: type2,
      start: start2,
      end: -1,
      name: name2,
      attributes: [],
      fragment: create_fragment(true),
      metadata: {
        // unpopulated at first, differs between types
      }
    }
  );
  parser2.allow_whitespace();
  if (parent.type === "RegularElement" && closing_tag_omitted(parent.name, name2)) {
    const end2 = parent.fragment.nodes[0]?.start ?? start2;
    element_implicitly_closed({ start: parent.start, end: end2 }, `<${name2}>`, `</${parent.name}>`);
    parent.end = start2;
    parser2.pop();
    parser2.last_auto_closed_tag = {
      tag: parent.name,
      reason: name2,
      depth: parser2.stack.length
    };
  }
  const unique_names = [];
  const current2 = parser2.current();
  const is_top_level_script_or_style = (name2 === "script" || name2 === "style") && current2.type === "Root";
  const read = is_top_level_script_or_style ? read_static_attribute : read_attribute;
  let attribute2;
  while (attribute2 = read(parser2)) {
    if (attribute2.type === "Attribute" || attribute2.type === "BindDirective" || attribute2.type === "StyleDirective" || attribute2.type === "ClassDirective") {
      const type3 = attribute2.type === "BindDirective" ? "Attribute" : attribute2.type;
      if (unique_names.includes(type3 + attribute2.name)) {
        attribute_duplicate(attribute2);
      } else if (attribute2.name !== "this") {
        unique_names.push(type3 + attribute2.name);
      }
    }
    element3.attributes.push(attribute2);
    parser2.allow_whitespace();
  }
  if (element3.type === "Component") {
    element3.metadata.expression = new ExpressionMetadata();
  }
  if (element3.type === "SvelteComponent") {
    const index2 = element3.attributes.findIndex(
      /** @param {any} attr */
      (attr) => attr.type === "Attribute" && attr.name === "this"
    );
    if (index2 === -1) {
      svelte_component_missing_this(start2);
    }
    const definition = (
      /** @type {AST.Attribute} */
      element3.attributes.splice(index2, 1)[0]
    );
    if (!is_expression_attribute(definition)) {
      svelte_component_invalid_this(definition.start);
    }
    element3.expression = get_attribute_expression(definition);
    element3.metadata.expression = new ExpressionMetadata();
  }
  if (element3.type === "SvelteElement") {
    const index2 = element3.attributes.findIndex(
      /** @param {any} attr */
      (attr) => attr.type === "Attribute" && attr.name === "this"
    );
    if (index2 === -1) {
      svelte_element_missing_this(start2);
    }
    const definition = (
      /** @type {AST.Attribute} */
      element3.attributes.splice(index2, 1)[0]
    );
    if (definition.value === true) {
      svelte_element_missing_this(definition);
    }
    if (!is_expression_attribute(definition)) {
      svelte_element_invalid_this(definition);
      const chunk = (
        /** @type {Array<AST.ExpressionTag | AST.Text>} */
        definition.value[0]
      );
      element3.tag = chunk.type === "Text" ? {
        type: "Literal",
        value: chunk.data,
        raw: `'${chunk.raw}'`,
        start: chunk.start,
        end: chunk.end
      } : chunk.expression;
    } else {
      element3.tag = get_attribute_expression(definition);
    }
    element3.metadata.expression = new ExpressionMetadata();
  }
  if (is_top_level_script_or_style) {
    parser2.eat(">", true);
    let prev_comment = null;
    for (let i = current2.fragment.nodes.length - 1; i >= 0; i--) {
      const node = current2.fragment.nodes[i];
      if (i === current2.fragment.nodes.length - 1 && node.end !== start2) {
        break;
      }
      if (node.type === "Comment") {
        prev_comment = node;
        break;
      } else if (node.type !== "Text" || node.data.trim()) {
        break;
      }
    }
    if (name2 === "script") {
      const content = read_script(parser2, start2, element3.attributes);
      if (prev_comment) {
        content.content.leadingComments = [{ type: "Line", value: prev_comment.data }];
      }
      if (content.context === "module") {
        if (current2.module) script_duplicate(start2);
        current2.module = content;
      } else {
        if (current2.instance) script_duplicate(start2);
        current2.instance = content;
      }
    } else {
      const content = read_style(parser2, start2, element3.attributes);
      content.content.comment = prev_comment;
      if (current2.css) style_duplicate(start2);
      current2.css = content;
    }
    return;
  }
  parser2.append(element3);
  const self_closing = parser2.eat("/") || is_void(name2);
  const closed = parser2.eat(">", true, false);
  if (!closed) {
    const last = element3.attributes.at(-1);
    if (last?.type === "Attribute" && last.name === "<") {
      parser2.index = last.start;
      element3.attributes.pop();
    } else {
      const prev_1 = parser2.template[parser2.index - 1];
      const prev_2 = parser2.template[parser2.index - 2];
      const current3 = parser2.template[parser2.index];
      if (prev_2 === "{" && prev_1 === "/") {
        parser2.index -= 2;
      } else if (prev_1 === "{" && (current3 === "#" || current3 === "@" || current3 === ":")) {
        parser2.index -= 1;
      } else {
        parser2.allow_whitespace();
      }
    }
  }
  if (self_closing || !closed) {
    element3.end = parser2.index;
  } else if (name2 === "textarea") {
    element3.fragment.nodes = read_sequence(
      parser2,
      () => regex_closing_textarea_tag.test(parser2.template.slice(parser2.index)),
      "inside <textarea>"
    );
    parser2.read(regex_closing_textarea_tag);
    element3.end = parser2.index;
  } else if (name2 === "script" || name2 === "style") {
    const start3 = parser2.index;
    const data3 = parser2.read_until(new RegExp(`</${name2}>`));
    const end2 = parser2.index;
    const node = {
      start: start3,
      end: end2,
      type: "Text",
      data: data3,
      raw: data3
    };
    element3.fragment.nodes.push(node);
    parser2.eat(`</${name2}>`, true);
    element3.end = parser2.index;
  } else {
    parser2.stack.push(element3);
    parser2.fragments.push(element3.fragment);
  }
}
function parent_is_head(stack) {
  let i = stack.length;
  while (i--) {
    const { type: type2 } = stack[i];
    if (type2 === "SvelteHead") return true;
    if (type2 === "RegularElement" || type2 === "Component") return false;
  }
  return false;
}
function parent_is_shadowroot_template(stack) {
  let i = stack.length;
  while (i--) {
    if (stack[i].type === "RegularElement" && /** @type {AST.RegularElement} */
    stack[i].attributes.some(
      (a) => a.type === "Attribute" && a.name === "shadowrootmode"
    )) {
      return true;
    }
  }
  return false;
}
function read_static_attribute(parser2) {
  const start2 = parser2.index;
  const name2 = parser2.read_until(regex_token_ending_character);
  if (!name2) return null;
  let value = true;
  if (parser2.eat("=")) {
    parser2.allow_whitespace();
    let raw2 = parser2.match_regex(regex_attribute_value);
    if (!raw2) {
      expected_attribute_value(parser2.index);
    }
    parser2.index += raw2.length;
    const quoted = raw2[0] === '"' || raw2[0] === "'";
    if (quoted) {
      raw2 = raw2.slice(1, -1);
    }
    value = [
      {
        start: parser2.index - raw2.length - (quoted ? 1 : 0),
        end: quoted ? parser2.index - 1 : parser2.index,
        type: "Text",
        raw: raw2,
        data: decode_character_references(raw2, true)
      }
    ];
  }
  if (parser2.match_regex(regex_starts_with_quote_characters)) {
    expected_token(parser2.index, "=");
  }
  return create_attribute(name2, start2, parser2.index, value);
}
function read_attribute(parser2) {
  const start2 = parser2.index;
  if (parser2.eat("{")) {
    parser2.allow_whitespace();
    if (parser2.eat("@attach")) {
      parser2.require_whitespace();
      const expression = read_expression(parser2);
      parser2.allow_whitespace();
      parser2.eat("}", true);
      const attachment = {
        type: "AttachTag",
        start: start2,
        end: parser2.index,
        expression,
        metadata: {
          expression: new ExpressionMetadata()
        }
      };
      return attachment;
    }
    if (parser2.eat("...")) {
      const expression = read_expression(parser2);
      parser2.allow_whitespace();
      parser2.eat("}", true);
      const spread2 = {
        type: "SpreadAttribute",
        start: start2,
        end: parser2.index,
        expression,
        metadata: {
          expression: new ExpressionMetadata()
        }
      };
      return spread2;
    } else {
      const value_start = parser2.index;
      let name3 = parser2.read_identifier();
      if (name3 === null) {
        if (parser2.loose && (parser2.match("#") || parser2.match("/") || parser2.match("@") || parser2.match(":"))) {
          return null;
        } else if (parser2.loose && parser2.match("}")) {
          name3 = "";
        } else {
          attribute_empty_shorthand(start2);
        }
      }
      parser2.allow_whitespace();
      parser2.eat("}", true);
      const expression = {
        type: "ExpressionTag",
        start: value_start,
        end: value_start + name3.length,
        expression: {
          start: value_start,
          end: value_start + name3.length,
          type: "Identifier",
          name: name3
        },
        metadata: {
          expression: new ExpressionMetadata()
        }
      };
      return create_attribute(name3, start2, parser2.index, expression);
    }
  }
  const name2 = parser2.read_until(regex_token_ending_character);
  if (!name2) return null;
  let end2 = parser2.index;
  parser2.allow_whitespace();
  const colon_index = name2.indexOf(":");
  const type2 = colon_index !== -1 && get_directive_type(name2.slice(0, colon_index));
  let value = true;
  if (parser2.eat("=")) {
    parser2.allow_whitespace();
    if (parser2.template[parser2.index] === "/" && parser2.template[parser2.index + 1] === ">") {
      const char_start = parser2.index;
      parser2.index++;
      value = [
        {
          start: char_start,
          end: char_start + 1,
          type: "Text",
          raw: "/",
          data: "/"
        }
      ];
      end2 = parser2.index;
    } else {
      value = read_attribute_value2(parser2);
      end2 = parser2.index;
    }
  } else if (parser2.match_regex(regex_starts_with_quote_characters)) {
    expected_token(parser2.index, "=");
  }
  if (type2) {
    const [directive_name, ...modifiers] = name2.slice(colon_index + 1).split("|");
    if (directive_name === "") {
      directive_missing_name({ start: start2, end: start2 + colon_index + 1 }, name2);
    }
    if (type2 === "StyleDirective") {
      return {
        start: start2,
        end: end2,
        type: type2,
        name: directive_name,
        modifiers: (
          /** @type {Array<'important'>} */
          modifiers
        ),
        value,
        metadata: {
          expression: new ExpressionMetadata()
        }
      };
    }
    const first_value = value === true ? void 0 : Array.isArray(value) ? value[0] : value;
    let expression = null;
    if (first_value) {
      const attribute_contains_text = (
        /** @type {any[]} */
        value.length > 1 || first_value.type === "Text"
      );
      if (attribute_contains_text) {
        directive_invalid_value(
          /** @type {number} */
          first_value.start
        );
      } else {
        expression = first_value.expression;
      }
    }
    const directive = {
      start: start2,
      end: end2,
      type: type2,
      name: directive_name,
      expression,
      metadata: {
        expression: new ExpressionMetadata()
      }
    };
    directive.modifiers = modifiers;
    if (directive.type === "TransitionDirective") {
      const direction = name2.slice(0, colon_index);
      directive.intro = direction === "in" || direction === "transition";
      directive.outro = direction === "out" || direction === "transition";
    }
    if ((directive.type === "BindDirective" || directive.type === "ClassDirective") && !directive.expression) {
      directive.expression = /** @type {any} */
      {
        start: start2 + colon_index + 1,
        end: end2,
        type: "Identifier",
        name: directive.name
      };
    }
    return directive;
  }
  return create_attribute(name2, start2, end2, value);
}
function get_directive_type(name2) {
  if (name2 === "use") return "UseDirective";
  if (name2 === "animate") return "AnimateDirective";
  if (name2 === "bind") return "BindDirective";
  if (name2 === "class") return "ClassDirective";
  if (name2 === "style") return "StyleDirective";
  if (name2 === "on") return "OnDirective";
  if (name2 === "let") return "LetDirective";
  if (name2 === "in" || name2 === "out" || name2 === "transition") return "TransitionDirective";
  return false;
}
function read_attribute_value2(parser2) {
  const quote_mark = parser2.eat("'") ? "'" : parser2.eat('"') ? '"' : null;
  if (quote_mark && parser2.eat(quote_mark)) {
    return [
      {
        start: parser2.index - 1,
        end: parser2.index - 1,
        type: "Text",
        raw: "",
        data: ""
      }
    ];
  }
  let value;
  try {
    value = read_sequence(
      parser2,
      () => {
        if (quote_mark) return parser2.match(quote_mark);
        return !!parser2.match_regex(regex_invalid_unquoted_attribute_value);
      },
      "in attribute value"
    );
  } catch (error) {
    if (error.code === "js_parse_error") {
      const pos = error.position?.[0];
      if (pos !== void 0 && parser2.template.slice(pos - 1, pos + 1) === "/>") {
        parser2.index = pos;
        expected_token(pos, quote_mark || "}");
      }
    }
    throw error;
  }
  if (value.length === 0 && !quote_mark) {
    expected_attribute_value(parser2.index);
  }
  if (quote_mark) parser2.index += 1;
  if (quote_mark || value.length > 1 || value[0].type === "Text") {
    return value;
  } else {
    return value[0];
  }
}
function read_sequence(parser2, done, location) {
  let current_chunk = {
    start: parser2.index,
    end: -1,
    type: "Text",
    raw: "",
    data: ""
  };
  const chunks = [];
  function flush(end2) {
    if (current_chunk.raw) {
      current_chunk.data = decode_character_references(current_chunk.raw, true);
      current_chunk.end = end2;
      chunks.push(current_chunk);
    }
  }
  while (parser2.index < parser2.template.length) {
    const index2 = parser2.index;
    if (done()) {
      flush(parser2.index);
      return chunks;
    } else if (parser2.eat("{")) {
      if (parser2.match("#")) {
        const index3 = parser2.index - 1;
        parser2.eat("#");
        const name2 = parser2.read_until(/[^a-z]/);
        block_invalid_placement(index3, name2, location);
      } else if (parser2.match("@")) {
        const index3 = parser2.index - 1;
        parser2.eat("@");
        const name2 = parser2.read_until(/[^a-z]/);
        tag_invalid_placement(index3, name2, location);
      }
      flush(parser2.index - 1);
      parser2.allow_whitespace();
      const expression = read_expression(parser2);
      parser2.allow_whitespace();
      parser2.eat("}", true);
      const chunk = {
        type: "ExpressionTag",
        start: index2,
        end: parser2.index,
        expression,
        metadata: {
          expression: new ExpressionMetadata()
        }
      };
      chunks.push(chunk);
      current_chunk = {
        start: parser2.index,
        end: -1,
        type: "Text",
        raw: "",
        data: ""
      };
    } else {
      current_chunk.raw += parser2.template[parser2.index++];
    }
  }
  if (parser2.loose) {
    return chunks;
  } else {
    unexpected_eof(parser2.template.length);
  }
}

// node_modules/.deno/svelte@5.43.8/node_modules/svelte/src/compiler/phases/1-parse/read/context.js
function read_pattern(parser2) {
  const start2 = parser2.index;
  let i = parser2.index;
  const name2 = parser2.read_identifier();
  if (name2 !== null) {
    const annotation = read_type_annotation(parser2);
    return {
      type: "Identifier",
      name: name2,
      start: start2,
      loc: {
        start: (
          /** @type {Location} */
          locator(start2)
        ),
        end: (
          /** @type {Location} */
          locator(parser2.index)
        )
      },
      end: parser2.index,
      typeAnnotation: annotation
    };
  }
  const char = parser2.template[i];
  if (char !== "{" && char !== "[") {
    expected_pattern(i);
  }
  i = match_bracket(parser2, start2);
  parser2.index = i;
  const pattern_string = parser2.template.slice(start2, i);
  try {
    let space_with_newline = parser2.template.slice(0, start2).replace(regex_not_newline_characters, " ");
    const first_space = space_with_newline.indexOf(" ");
    space_with_newline = space_with_newline.slice(0, first_space) + space_with_newline.slice(first_space + 1);
    const expression = (
      /** @type {any} */
      parse_expression_at(
        `${space_with_newline}(${pattern_string} = 1)`,
        parser2.root.comments,
        parser2.ts,
        start2 - 1
      ).left
    );
    expression.typeAnnotation = read_type_annotation(parser2);
    if (expression.typeAnnotation) {
      expression.end = expression.typeAnnotation.end;
    }
    return expression;
  } catch (error) {
    parser2.acorn_error(error);
  }
}
function read_type_annotation(parser2) {
  const start2 = parser2.index;
  parser2.allow_whitespace();
  if (!parser2.eat(":")) {
    parser2.index = start2;
    return void 0;
  }
  const insert = "_ as ";
  let a = parser2.index - insert.length;
  const template2 = parser2.template.slice(0, a).replace(/[^\n]/g, " ") + insert + // If this is a type annotation for a function parameter, Acorn-TS will treat subsequent
  // parameters as part of a sequence expression instead, and will then error on optional
  // parameters (`?:`). Therefore replace that sequence with something that will not error.
  parser2.template.slice(parser2.index).replace(/\?\s*:/g, ":");
  let expression = parse_expression_at(template2, parser2.root.comments, parser2.ts, a);
  if (expression.type === "AssignmentExpression") {
    let b = expression.right.start;
    while (template2[b] !== "=") b -= 1;
    expression = parse_expression_at(template2.slice(0, b), parser2.root.comments, parser2.ts, a);
  }
  if (expression.type === "SequenceExpression") {
    expression = expression.expressions[0];
  }
  parser2.index = /** @type {number} */
  expression.end;
  return {
    type: "TSTypeAnnotation",
    start: start2,
    end: parser2.index,
    typeAnnotation: (
      /** @type {any} */
      expression.typeAnnotation
    )
  };
}

// node_modules/.deno/svelte@5.43.8/node_modules/svelte/src/compiler/phases/1-parse/state/tag.js
var regex_whitespace_with_closing_curly_brace = /^\s*}/;
var pointy_bois = { "<": ">" };
function tag(parser2) {
  const start2 = parser2.index;
  parser2.index += 1;
  parser2.allow_whitespace();
  if (parser2.eat("#")) return open(parser2);
  if (parser2.eat(":")) return next(parser2);
  if (parser2.eat("@")) return special(parser2);
  if (parser2.match("/")) {
    if (!parser2.match("/*") && !parser2.match("//")) {
      parser2.eat("/");
      return close(parser2);
    }
  }
  const expression = read_expression(parser2);
  parser2.allow_whitespace();
  parser2.eat("}", true);
  parser2.append({
    type: "ExpressionTag",
    start: start2,
    end: parser2.index,
    expression,
    metadata: {
      expression: new ExpressionMetadata()
    }
  });
}
function open(parser2) {
  let start2 = parser2.index - 2;
  while (parser2.template[start2] !== "{") start2 -= 1;
  if (parser2.eat("if")) {
    parser2.require_whitespace();
    const block3 = parser2.append({
      type: "IfBlock",
      elseif: false,
      start: start2,
      end: -1,
      test: read_expression(parser2),
      consequent: create_fragment(),
      alternate: null,
      metadata: {
        expression: new ExpressionMetadata()
      }
    });
    parser2.allow_whitespace();
    parser2.eat("}", true);
    parser2.stack.push(block3);
    parser2.fragments.push(block3.consequent);
    return;
  }
  if (parser2.eat("each")) {
    parser2.require_whitespace();
    const template2 = parser2.template;
    let end2 = parser2.template.length;
    let expression;
    while (!expression) {
      try {
        expression = read_expression(parser2, void 0, true);
      } catch (err) {
        end2 = /** @type {any} */
        err.position[0] - 2;
        while (end2 > start2 && parser2.template.slice(end2, end2 + 2) !== "as") {
          end2 -= 1;
        }
        if (end2 <= start2) {
          if (parser2.loose) {
            expression = get_loose_identifier(parser2);
            if (expression) {
              break;
            }
          }
          throw err;
        }
        parser2.template = template2.slice(0, end2);
      }
    }
    parser2.template = template2;
    parser2.allow_whitespace();
    if (!parser2.match("as")) {
      if (expression.type === "SequenceExpression") {
        expression = expression.expressions[0];
      }
      let assertion = null;
      let end3 = expression.end;
      expression = walk(expression, null, {
        // @ts-expect-error
        TSAsExpression(node, context3) {
          if (node.end === /** @type {Expression} */
          expression.end) {
            assertion = node;
            end3 = node.expression.end;
            return node.expression;
          }
          context3.next();
        }
      });
      expression.end = end3;
      if (assertion) {
        let end4 = (
          /** @type {any} */
          /** @type {any} */
          assertion.typeAnnotation.start - 2
        );
        while (parser2.template.slice(end4, end4 + 2) !== "as") end4 -= 1;
        parser2.index = end4;
      }
    }
    let context2 = null;
    let index2;
    let key2;
    if (parser2.eat("as")) {
      parser2.require_whitespace();
      context2 = read_pattern(parser2);
    } else {
      parser2.index = /** @type {number} */
      expression.end;
    }
    parser2.allow_whitespace();
    if (parser2.eat(",")) {
      parser2.allow_whitespace();
      index2 = parser2.read_identifier();
      if (!index2) {
        expected_identifier(parser2.index);
      }
      parser2.allow_whitespace();
    }
    if (parser2.eat("(")) {
      parser2.allow_whitespace();
      key2 = read_expression(parser2, "(");
      parser2.allow_whitespace();
      parser2.eat(")", true);
      parser2.allow_whitespace();
    }
    const matches = parser2.eat("}", true, false);
    if (!matches) {
      if (parser2.template.slice(parser2.index - 4, parser2.index) === " as ") {
        const prev_index = parser2.index;
        context2 = read_pattern(parser2);
        parser2.eat("}", true);
        expression = {
          type: "Identifier",
          name: "",
          start: expression.start,
          end: prev_index - 4
        };
      } else {
        parser2.eat("}", true);
      }
    }
    const block3 = parser2.append({
      type: "EachBlock",
      start: start2,
      end: -1,
      expression,
      body: create_fragment(),
      context: context2,
      index: index2,
      key: key2,
      metadata: (
        /** @type {any} */
        null
      )
      // filled in later
    });
    parser2.stack.push(block3);
    parser2.fragments.push(block3.body);
    return;
  }
  if (parser2.eat("await")) {
    parser2.require_whitespace();
    const expression = read_expression(parser2);
    parser2.allow_whitespace();
    const block3 = parser2.append({
      type: "AwaitBlock",
      start: start2,
      end: -1,
      expression,
      value: null,
      error: null,
      pending: null,
      then: null,
      catch: null,
      metadata: {
        expression: new ExpressionMetadata()
      }
    });
    if (parser2.eat("then")) {
      if (parser2.match_regex(regex_whitespace_with_closing_curly_brace)) {
        parser2.allow_whitespace();
      } else {
        parser2.require_whitespace();
        block3.value = read_pattern(parser2);
        parser2.allow_whitespace();
      }
      block3.then = create_fragment();
      parser2.fragments.push(block3.then);
    } else if (parser2.eat("catch")) {
      if (parser2.match_regex(regex_whitespace_with_closing_curly_brace)) {
        parser2.allow_whitespace();
      } else {
        parser2.require_whitespace();
        block3.error = read_pattern(parser2);
        parser2.allow_whitespace();
      }
      block3.catch = create_fragment();
      parser2.fragments.push(block3.catch);
    } else {
      block3.pending = create_fragment();
      parser2.fragments.push(block3.pending);
    }
    const matches = parser2.eat("}", true, false);
    if (!matches) {
      if (parser2.template.slice(parser2.index - 6, parser2.index) === " then ") {
        const prev_index = parser2.index;
        block3.value = read_pattern(parser2);
        parser2.eat("}", true);
        block3.expression = {
          type: "Identifier",
          name: "",
          start: expression.start,
          end: prev_index - 6
        };
        block3.then = block3.pending;
        block3.pending = null;
      } else if (parser2.template.slice(parser2.index - 7, parser2.index) === " catch ") {
        const prev_index = parser2.index;
        block3.error = read_pattern(parser2);
        parser2.eat("}", true);
        block3.expression = {
          type: "Identifier",
          name: "",
          start: expression.start,
          end: prev_index - 7
        };
        block3.catch = block3.pending;
        block3.pending = null;
      } else {
        parser2.eat("}", true);
      }
    }
    parser2.stack.push(block3);
    return;
  }
  if (parser2.eat("key")) {
    parser2.require_whitespace();
    const expression = read_expression(parser2);
    parser2.allow_whitespace();
    parser2.eat("}", true);
    const block3 = parser2.append({
      type: "KeyBlock",
      start: start2,
      end: -1,
      expression,
      fragment: create_fragment(),
      metadata: {
        expression: new ExpressionMetadata()
      }
    });
    parser2.stack.push(block3);
    parser2.fragments.push(block3.fragment);
    return;
  }
  if (parser2.eat("snippet")) {
    parser2.require_whitespace();
    const name_start = parser2.index;
    let name2 = parser2.read_identifier();
    const name_end = parser2.index;
    if (name2 === null) {
      if (parser2.loose) {
        name2 = "";
      } else {
        expected_identifier(parser2.index);
      }
    }
    parser2.allow_whitespace();
    const params_start = parser2.index;
    let type_params;
    if (parser2.ts && parser2.match("<")) {
      const start3 = parser2.index;
      const end2 = match_bracket(parser2, start3, pointy_bois);
      type_params = parser2.template.slice(start3 + 1, end2 - 1);
      parser2.index = end2;
    }
    parser2.allow_whitespace();
    const matched = parser2.eat("(", true, false);
    if (matched) {
      let parentheses = 1;
      while (parser2.index < parser2.template.length && (!parser2.match(")") || parentheses !== 1)) {
        if (parser2.match("(")) parentheses++;
        if (parser2.match(")")) parentheses--;
        parser2.index += 1;
      }
      parser2.eat(")", true);
    }
    const prelude = parser2.template.slice(0, params_start).replace(/\S/g, " ");
    const params = parser2.template.slice(params_start, parser2.index);
    let function_expression = matched ? (
      /** @type {ArrowFunctionExpression} */
      parse_expression_at(
        prelude + `${params} => {}`,
        parser2.root.comments,
        parser2.ts,
        params_start
      )
    ) : { params: [] };
    parser2.allow_whitespace();
    parser2.eat("}", true);
    const block3 = parser2.append({
      type: "SnippetBlock",
      start: start2,
      end: -1,
      expression: {
        type: "Identifier",
        start: name_start,
        end: name_end,
        name: name2
      },
      typeParams: type_params,
      parameters: function_expression.params,
      body: create_fragment(),
      metadata: {
        can_hoist: false,
        sites: /* @__PURE__ */ new Set()
      }
    });
    parser2.stack.push(block3);
    parser2.fragments.push(block3.body);
    return;
  }
  expected_block_type(parser2.index);
}
function next(parser2) {
  const start2 = parser2.index - 1;
  const block3 = parser2.current();
  if (block3.type === "IfBlock") {
    if (!parser2.eat("else")) expected_token(start2, "{:else} or {:else if}");
    if (parser2.eat("if")) block_invalid_elseif(start2);
    parser2.allow_whitespace();
    parser2.fragments.pop();
    block3.alternate = create_fragment();
    parser2.fragments.push(block3.alternate);
    if (parser2.eat("if")) {
      parser2.require_whitespace();
      const expression = read_expression(parser2);
      parser2.allow_whitespace();
      parser2.eat("}", true);
      let elseif_start = start2 - 1;
      while (parser2.template[elseif_start] !== "{") elseif_start -= 1;
      const child = parser2.append({
        start: elseif_start,
        end: -1,
        type: "IfBlock",
        elseif: true,
        test: expression,
        consequent: create_fragment(),
        alternate: null,
        metadata: {
          expression: new ExpressionMetadata()
        }
      });
      parser2.stack.push(child);
      parser2.fragments.pop();
      parser2.fragments.push(child.consequent);
    } else {
      parser2.allow_whitespace();
      parser2.eat("}", true);
    }
    return;
  }
  if (block3.type === "EachBlock") {
    if (!parser2.eat("else")) expected_token(start2, "{:else}");
    parser2.allow_whitespace();
    parser2.eat("}", true);
    block3.fallback = create_fragment();
    parser2.fragments.pop();
    parser2.fragments.push(block3.fallback);
    return;
  }
  if (block3.type === "AwaitBlock") {
    if (parser2.eat("then")) {
      if (block3.then) {
        block_duplicate_clause(start2, "{:then}");
      }
      if (!parser2.eat("}")) {
        parser2.require_whitespace();
        block3.value = read_pattern(parser2);
        parser2.allow_whitespace();
        parser2.eat("}", true);
      }
      block3.then = create_fragment();
      parser2.fragments.pop();
      parser2.fragments.push(block3.then);
      return;
    }
    if (parser2.eat("catch")) {
      if (block3.catch) {
        block_duplicate_clause(start2, "{:catch}");
      }
      if (!parser2.eat("}")) {
        parser2.require_whitespace();
        block3.error = read_pattern(parser2);
        parser2.allow_whitespace();
        parser2.eat("}", true);
      }
      block3.catch = create_fragment();
      parser2.fragments.pop();
      parser2.fragments.push(block3.catch);
      return;
    }
    expected_token(start2, "{:then ...} or {:catch ...}");
  }
  block_invalid_continuation_placement(start2);
}
function close(parser2) {
  const start2 = parser2.index - 1;
  let block3 = parser2.current();
  let matched;
  switch (block3.type) {
    case "IfBlock":
      matched = parser2.eat("if", true, false);
      if (!matched) {
        block3.end = start2 - 1;
        parser2.pop();
        close(parser2);
        return;
      }
      parser2.allow_whitespace();
      parser2.eat("}", true);
      while (block3.elseif) {
        block3.end = parser2.index;
        parser2.stack.pop();
        block3 = /** @type {AST.IfBlock} */
        parser2.current();
      }
      block3.end = parser2.index;
      parser2.pop();
      return;
    case "EachBlock":
      matched = parser2.eat("each", true, false);
      break;
    case "KeyBlock":
      matched = parser2.eat("key", true, false);
      break;
    case "AwaitBlock":
      matched = parser2.eat("await", true, false);
      break;
    case "SnippetBlock":
      matched = parser2.eat("snippet", true, false);
      break;
    case "RegularElement":
      if (parser2.loose) {
        matched = false;
      } else {
        block_unexpected_close(start2);
      }
      break;
    default:
      block_unexpected_close(start2);
  }
  if (!matched) {
    block3.end = start2 - 1;
    parser2.pop();
    close(parser2);
    return;
  }
  parser2.allow_whitespace();
  parser2.eat("}", true);
  block3.end = parser2.index;
  parser2.pop();
}
function special(parser2) {
  let start2 = parser2.index;
  while (parser2.template[start2] !== "{") start2 -= 1;
  if (parser2.eat("html")) {
    parser2.require_whitespace();
    const expression = read_expression(parser2);
    parser2.allow_whitespace();
    parser2.eat("}", true);
    parser2.append({
      type: "HtmlTag",
      start: start2,
      end: parser2.index,
      expression,
      metadata: {
        expression: new ExpressionMetadata()
      }
    });
    return;
  }
  if (parser2.eat("debug")) {
    let identifiers;
    if (parser2.read(regex_whitespace_with_closing_curly_brace)) {
      identifiers = [];
    } else {
      const expression = read_expression(parser2);
      identifiers = expression.type === "SequenceExpression" ? (
        /** @type {Identifier[]} */
        expression.expressions
      ) : [
        /** @type {Identifier} */
        expression
      ];
      identifiers.forEach(
        /** @param {any} node */
        (node) => {
          if (node.type !== "Identifier") {
            debug_tag_invalid_arguments(
              /** @type {number} */
              node.start
            );
          }
        }
      );
      parser2.allow_whitespace();
      parser2.eat("}", true);
    }
    parser2.append({
      type: "DebugTag",
      start: start2,
      end: parser2.index,
      identifiers
    });
    return;
  }
  if (parser2.eat("const")) {
    parser2.require_whitespace();
    const id2 = read_pattern(parser2);
    parser2.allow_whitespace();
    parser2.eat("=", true);
    parser2.allow_whitespace();
    const expression_start = parser2.index;
    const init2 = read_expression(parser2);
    if (init2.type === "SequenceExpression" && !parser2.template.substring(expression_start, init2.start).includes("(")) {
      const_tag_invalid_expression(init2);
    }
    parser2.allow_whitespace();
    parser2.eat("}", true);
    parser2.append({
      type: "ConstTag",
      start: start2,
      end: parser2.index,
      declaration: {
        type: "VariableDeclaration",
        kind: "const",
        declarations: [{ type: "VariableDeclarator", id: id2, init: init2, start: id2.start, end: init2.end }],
        start: start2 + 2,
        // start at const, not at @const
        end: parser2.index - 1
      },
      metadata: {
        expression: new ExpressionMetadata()
      }
    });
  }
  if (parser2.eat("render")) {
    parser2.require_whitespace();
    const expression = read_expression(parser2);
    if (expression.type !== "CallExpression" && (expression.type !== "ChainExpression" || expression.expression.type !== "CallExpression")) {
      render_tag_invalid_expression(expression);
    }
    parser2.allow_whitespace();
    parser2.eat("}", true);
    parser2.append({
      type: "RenderTag",
      start: start2,
      end: parser2.index,
      expression: (
        /** @type {AST.RenderTag['expression']} */
        expression
      ),
      metadata: {
        expression: new ExpressionMetadata(),
        dynamic: false,
        arguments: [],
        path: [],
        snippets: /* @__PURE__ */ new Set()
      }
    });
  }
}

// node_modules/.deno/svelte@5.43.8/node_modules/svelte/src/compiler/phases/1-parse/state/text.js
function text(parser2) {
  const start2 = parser2.index;
  let data3 = "";
  while (parser2.index < parser2.template.length && !parser2.match("<") && !parser2.match("{")) {
    data3 += parser2.template[parser2.index++];
  }
  parser2.append({
    type: "Text",
    start: start2,
    end: parser2.index,
    raw: data3,
    data: decode_character_references(data3, false)
  });
}

// node_modules/.deno/svelte@5.43.8/node_modules/svelte/src/compiler/phases/1-parse/state/fragment.js
function fragment(parser2) {
  if (parser2.match("<")) {
    return element;
  }
  if (parser2.match("{")) {
    return tag;
  }
  return text;
}

// node_modules/.deno/svelte@5.43.8/node_modules/svelte/src/compiler/phases/1-parse/read/options.js
function read_options(node) {
  const component_options2 = {
    start: node.start,
    end: node.end,
    // @ts-ignore
    attributes: node.attributes
  };
  if (!node) {
    return component_options2;
  }
  for (const attribute2 of node.attributes) {
    if (attribute2.type !== "Attribute") {
      svelte_options_invalid_attribute(attribute2);
    }
    const { name: name2 } = attribute2;
    switch (name2) {
      case "runes": {
        component_options2.runes = get_boolean_value(attribute2);
        break;
      }
      case "tag": {
        svelte_options_deprecated_tag(attribute2);
        break;
      }
      case "customElement": {
        const ce = {};
        const { value: v } = attribute2;
        const value = v === true || Array.isArray(v) ? v : [v];
        if (value === true) {
          svelte_options_invalid_customelement(attribute2);
        } else if (value[0].type === "Text") {
          const tag4 = get_static_value(attribute2);
          validate_tag(attribute2, tag4);
          ce.tag = tag4;
          component_options2.customElement = ce;
          break;
        } else if (value[0].expression.type !== "ObjectExpression") {
          if (value[0].expression.type === "Literal" && value[0].expression.value === null) {
            break;
          }
          svelte_options_invalid_customelement(attribute2);
        }
        const properties = [];
        for (const property of value[0].expression.properties) {
          if (property.type !== "Property" || property.computed || property.key.type !== "Identifier") {
            svelte_options_invalid_customelement(attribute2);
          }
          properties.push([property.key.name, property.value]);
        }
        const tag3 = properties.find(([name3]) => name3 === "tag");
        if (tag3) {
          const tag_value = tag3[1]?.value;
          validate_tag(tag3, tag_value);
          ce.tag = tag_value;
        }
        const props = properties.find(([name3]) => name3 === "props")?.[1];
        if (props) {
          if (props.type !== "ObjectExpression") {
            svelte_options_invalid_customelement_props(attribute2);
          }
          ce.props = {};
          for (
            const property of
            /** @type {ObjectExpression} */
            props.properties
          ) {
            if (property.type !== "Property" || property.computed || property.key.type !== "Identifier" || property.value.type !== "ObjectExpression") {
              svelte_options_invalid_customelement_props(attribute2);
            }
            ce.props[property.key.name] = {};
            for (const prop3 of property.value.properties) {
              if (prop3.type !== "Property" || prop3.computed || prop3.key.type !== "Identifier" || prop3.value.type !== "Literal") {
                svelte_options_invalid_customelement_props(attribute2);
              }
              if (prop3.key.name === "type") {
                if (["String", "Number", "Boolean", "Array", "Object"].indexOf(
                  /** @type {string} */
                  prop3.value.value
                ) === -1) {
                  svelte_options_invalid_customelement_props(attribute2);
                }
                ce.props[property.key.name].type = /** @type {any} */
                prop3.value.value;
              } else if (prop3.key.name === "reflect") {
                if (typeof prop3.value.value !== "boolean") {
                  svelte_options_invalid_customelement_props(attribute2);
                }
                ce.props[property.key.name].reflect = prop3.value.value;
              } else if (prop3.key.name === "attribute") {
                if (typeof prop3.value.value !== "string") {
                  svelte_options_invalid_customelement_props(attribute2);
                }
                ce.props[property.key.name].attribute = prop3.value.value;
              } else {
                svelte_options_invalid_customelement_props(attribute2);
              }
            }
          }
        }
        const shadow = properties.find(([name3]) => name3 === "shadow")?.[1];
        if (shadow) {
          const shadowdom = shadow?.value;
          if (shadowdom !== "open" && shadowdom !== "none") {
            svelte_options_invalid_customelement_shadow(shadow);
          }
          ce.shadow = shadowdom;
        }
        const extend4 = properties.find(([name3]) => name3 === "extend")?.[1];
        if (extend4) {
          ce.extend = extend4;
        }
        component_options2.customElement = ce;
        break;
      }
      case "namespace": {
        const value = get_static_value(attribute2);
        if (value === NAMESPACE_SVG) {
          component_options2.namespace = "svg";
        } else if (value === NAMESPACE_MATHML) {
          component_options2.namespace = "mathml";
        } else if (value === "html" || value === "mathml" || value === "svg") {
          component_options2.namespace = value;
        } else {
          svelte_options_invalid_attribute_value(attribute2, `"html", "mathml" or "svg"`);
        }
        break;
      }
      case "css": {
        const value = get_static_value(attribute2);
        if (value === "injected") {
          component_options2.css = value;
        } else {
          svelte_options_invalid_attribute_value(attribute2, `"injected"`);
        }
        break;
      }
      case "immutable": {
        component_options2.immutable = get_boolean_value(attribute2);
        break;
      }
      case "preserveWhitespace": {
        component_options2.preserveWhitespace = get_boolean_value(attribute2);
        break;
      }
      case "accessors": {
        component_options2.accessors = get_boolean_value(attribute2);
        break;
      }
      default:
        svelte_options_unknown_attribute(attribute2, name2);
    }
  }
  return component_options2;
}
function get_static_value(attribute2) {
  const { value } = attribute2;
  if (value === true) return true;
  const chunk = Array.isArray(value) ? value[0] : value;
  if (!chunk) return true;
  if (value.length > 1) {
    return null;
  }
  if (chunk.type === "Text") return chunk.data;
  if (chunk.expression.type !== "Literal") {
    return null;
  }
  return chunk.expression.value;
}
function get_boolean_value(attribute2) {
  const value = get_static_value(attribute2);
  if (typeof value !== "boolean") {
    svelte_options_invalid_attribute_value(attribute2, "true or false");
  }
  return value;
}
var tag_name_char = "[a-z0-9_.-------------]";
var regex_valid_tag_name = new RegExp(`^[a-z]${tag_name_char}*-${tag_name_char}*$`, "u");
var reserved_tag_names = [
  "annotation-xml",
  "color-profile",
  "font-face",
  "font-face-src",
  "font-face-uri",
  "font-face-format",
  "font-face-name",
  "missing-glyph"
];
function validate_tag(attribute2, tag3) {
  if (typeof tag3 !== "string") {
    svelte_options_invalid_tagname(attribute2);
  }
  if (tag3) {
    if (!regex_valid_tag_name.test(tag3)) {
      svelte_options_invalid_tagname(attribute2);
    } else if (reserved_tag_names.includes(tag3)) {
      svelte_options_reserved_tagname(attribute2);
    }
  }
}

// node_modules/.deno/svelte@5.43.8/node_modules/svelte/src/compiler/phases/2-analyze/visitors/shared/special-element.js
function disallow_children(node) {
  const { nodes } = node.fragment;
  if (nodes.length > 0) {
    const first2 = nodes[0];
    const last = nodes[nodes.length - 1];
    svelte_meta_invalid_content({ start: first2.start, end: last.end }, node.name);
  }
}

// node_modules/.deno/svelte@5.43.8/node_modules/svelte/src/compiler/phases/1-parse/index.js
var regex_position_indicator = / \(\d+:\d+\)$/;
var regex_lang_attribute = /<!--[^]*?-->|<script\s+(?:[^>]*|(?:[^=>'"/]+=(?:"[^"]*"|'[^']*'|[^>\s]+)\s+)*)lang=(["'])?([^"' >]+)\1[^>]*>/g;
var Parser3 = class {
  /**
   * @readonly
   * @type {string}
   */
  template;
  /**
   * Whether or not we're in loose parsing mode, in which
   * case we try to continue parsing as much as possible
   * @type {boolean}
   */
  loose;
  /** */
  index = 0;
  /** Whether we're parsing in TypeScript mode */
  ts = false;
  /** @type {AST.TemplateNode[]} */
  stack = [];
  /** @type {AST.Fragment[]} */
  fragments = [];
  /** @type {AST.Root} */
  root;
  /** @type {Record<string, boolean>} */
  meta_tags = {};
  /** @type {LastAutoClosedTag | undefined} */
  last_auto_closed_tag;
  /**
   * @param {string} template
   * @param {boolean} loose
   */
  constructor(template2, loose) {
    if (typeof template2 !== "string") {
      throw new TypeError("Template must be a string");
    }
    this.loose = loose;
    this.template = template2.trimEnd();
    let match_lang;
    do
      match_lang = regex_lang_attribute.exec(template2);
    while (match_lang && match_lang[0][1] !== "s");
    regex_lang_attribute.lastIndex = 0;
    this.ts = match_lang?.[2] === "ts";
    this.root = {
      css: null,
      js: [],
      // @ts-ignore
      start: null,
      // @ts-ignore
      end: null,
      type: "Root",
      fragment: create_fragment(),
      options: null,
      comments: [],
      metadata: {
        ts: this.ts
      }
    };
    this.stack.push(this.root);
    this.fragments.push(this.root.fragment);
    let state = fragment;
    while (this.index < this.template.length) {
      state = state(this) || fragment;
    }
    if (this.stack.length > 1) {
      const current2 = this.current();
      if (this.loose) {
        current2.end = this.template.length;
      } else if (current2.type === "RegularElement") {
        current2.end = current2.start + 1;
        element_unclosed(current2, current2.name);
      } else {
        current2.end = current2.start + 1;
        block_unclosed(current2);
      }
    }
    if (state !== fragment) {
      unexpected_eof(this.index);
    }
    if (this.root.fragment.nodes.length) {
      let start2 = (
        /** @type {number} */
        this.root.fragment.nodes[0].start
      );
      while (regex_whitespace.test(template2[start2])) start2 += 1;
      let end2 = (
        /** @type {number} */
        this.root.fragment.nodes[this.root.fragment.nodes.length - 1].end
      );
      while (regex_whitespace.test(template2[end2 - 1])) end2 -= 1;
      this.root.start = start2;
      this.root.end = end2;
    } else {
      this.root.start = this.root.end = null;
    }
    const options_index = this.root.fragment.nodes.findIndex(
      /** @param {any} thing */
      (thing) => thing.type === "SvelteOptions"
    );
    if (options_index !== -1) {
      const options2 = (
        /** @type {AST.SvelteOptionsRaw} */
        this.root.fragment.nodes[options_index]
      );
      this.root.fragment.nodes.splice(options_index, 1);
      this.root.options = read_options(options2);
      disallow_children(options2);
      Object.defineProperty(this.root.options, "__raw__", {
        value: options2,
        enumerable: false
      });
    }
  }
  current() {
    return this.stack[this.stack.length - 1];
  }
  /**
   * @param {any} err
   * @returns {never}
   */
  acorn_error(err) {
    js_parse_error(err.pos, err.message.replace(regex_position_indicator, ""));
  }
  /**
   * @param {string} str
   * @param {boolean} required
   * @param {boolean} required_in_loose
   */
  eat(str2, required = false, required_in_loose = true) {
    if (this.match(str2)) {
      this.index += str2.length;
      return true;
    }
    if (required && (!this.loose || required_in_loose)) {
      expected_token(this.index, str2);
    }
    return false;
  }
  /** @param {string} str */
  match(str2) {
    const length = str2.length;
    if (length === 1) {
      return this.template[this.index] === str2;
    }
    return this.template.slice(this.index, this.index + length) === str2;
  }
  /**
   * Match a regex at the current index
   * @param {RegExp} pattern  Should have a ^ anchor at the start so the regex doesn't search past the beginning, resulting in worse performance
   */
  match_regex(pattern) {
    const match = pattern.exec(this.template.slice(this.index));
    if (!match || match.index !== 0) return null;
    return match[0];
  }
  allow_whitespace() {
    while (this.index < this.template.length && regex_whitespace.test(this.template[this.index])) {
      this.index++;
    }
  }
  /**
   * Search for a regex starting at the current index and return the result if it matches
   * @param {RegExp} pattern  Should have a ^ anchor at the start so the regex doesn't search past the beginning, resulting in worse performance
   */
  read(pattern) {
    const result = this.match_regex(pattern);
    if (result) this.index += result.length;
    return result;
  }
  /** @param {any} allow_reserved */
  read_identifier(allow_reserved = false) {
    const start2 = this.index;
    let i = this.index;
    const code2 = (
      /** @type {number} */
      this.template.codePointAt(i)
    );
    if (!isIdentifierStart(code2, true)) return null;
    i += code2 <= 65535 ? 1 : 2;
    while (i < this.template.length) {
      const code3 = (
        /** @type {number} */
        this.template.codePointAt(i)
      );
      if (!isIdentifierChar(code3, true)) break;
      i += code3 <= 65535 ? 1 : 2;
    }
    const identifier = this.template.slice(this.index, this.index = i);
    if (!allow_reserved && is_reserved(identifier)) {
      unexpected_reserved_word(start2, identifier);
    }
    return identifier;
  }
  /** @param {RegExp} pattern */
  read_until(pattern) {
    if (this.index >= this.template.length) {
      if (this.loose) return "";
      unexpected_eof(this.template.length);
    }
    const start2 = this.index;
    const match = pattern.exec(this.template.slice(start2));
    if (match) {
      this.index = start2 + match.index;
      return this.template.slice(start2, this.index);
    }
    this.index = this.template.length;
    return this.template.slice(start2);
  }
  require_whitespace() {
    if (!regex_whitespace.test(this.template[this.index])) {
      expected_whitespace(this.index);
    }
    this.allow_whitespace();
  }
  pop() {
    this.fragments.pop();
    return this.stack.pop();
  }
  /**
   * @template {AST.Fragment['nodes'][number]} T
   * @param {T} node
   * @returns {T}
   */
  append(node) {
    this.fragments.at(-1)?.nodes.push(node);
    return node;
  }
};
function parse5(template2, loose = false) {
  set_source(template2);
  const parser2 = new Parser3(template2, loose);
  return parser2.root;
}

// node_modules/.deno/svelte@5.43.8/node_modules/svelte/src/compiler/phases/scope.js
var UNKNOWN = Symbol("unknown");
var NUMBER = Symbol("number");
var STRING = Symbol("string");
var FUNCTION = Symbol("string");
var globals = {
  BigInt: [NUMBER],
  "Math.min": [NUMBER, Math.min],
  "Math.max": [NUMBER, Math.max],
  "Math.random": [NUMBER],
  "Math.floor": [NUMBER, Math.floor],
  // @ts-ignore
  "Math.f16round": [NUMBER, Math.f16round],
  "Math.round": [NUMBER, Math.round],
  "Math.abs": [NUMBER, Math.abs],
  "Math.acos": [NUMBER, Math.acos],
  "Math.asin": [NUMBER, Math.asin],
  "Math.atan": [NUMBER, Math.atan],
  "Math.atan2": [NUMBER, Math.atan2],
  "Math.ceil": [NUMBER, Math.ceil],
  "Math.cos": [NUMBER, Math.cos],
  "Math.sin": [NUMBER, Math.sin],
  "Math.tan": [NUMBER, Math.tan],
  "Math.exp": [NUMBER, Math.exp],
  "Math.log": [NUMBER, Math.log],
  "Math.pow": [NUMBER, Math.pow],
  "Math.sqrt": [NUMBER, Math.sqrt],
  "Math.clz32": [NUMBER, Math.clz32],
  "Math.imul": [NUMBER, Math.imul],
  "Math.sign": [NUMBER, Math.sign],
  "Math.log10": [NUMBER, Math.log10],
  "Math.log2": [NUMBER, Math.log2],
  "Math.log1p": [NUMBER, Math.log1p],
  "Math.expm1": [NUMBER, Math.expm1],
  "Math.cosh": [NUMBER, Math.cosh],
  "Math.sinh": [NUMBER, Math.sinh],
  "Math.tanh": [NUMBER, Math.tanh],
  "Math.acosh": [NUMBER, Math.acosh],
  "Math.asinh": [NUMBER, Math.asinh],
  "Math.atanh": [NUMBER, Math.atanh],
  "Math.trunc": [NUMBER, Math.trunc],
  "Math.fround": [NUMBER, Math.fround],
  "Math.cbrt": [NUMBER, Math.cbrt],
  Number: [NUMBER, Number],
  "Number.isInteger": [NUMBER, Number.isInteger],
  "Number.isFinite": [NUMBER, Number.isFinite],
  "Number.isNaN": [NUMBER, Number.isNaN],
  "Number.isSafeInteger": [NUMBER, Number.isSafeInteger],
  "Number.parseFloat": [NUMBER, Number.parseFloat],
  "Number.parseInt": [NUMBER, Number.parseInt],
  String: [STRING, String],
  "String.fromCharCode": [STRING, String.fromCharCode],
  "String.fromCodePoint": [STRING, String.fromCodePoint]
};

// node_modules/.deno/svelte@5.43.8/node_modules/svelte/src/compiler/phases/2-analyze/visitors/shared/a11y/constants.js
var import_aria_query = __toESM(require_lib(), 1);
var import_axobject_query = __toESM(require_lib2(), 1);
var aria_attributes = "activedescendant atomic autocomplete busy checked colcount colindex colspan controls current describedby description details disabled dropeffect errormessage expanded flowto grabbed haspopup hidden invalid keyshortcuts label labelledby level live modal multiline multiselectable orientation owns placeholder posinset pressed readonly relevant required roledescription rowcount rowindex rowspan selected setsize sort valuemax valuemin valuenow valuetext".split(
  " "
);
var aria_roles = import_aria_query.roles.keys();
var abstract_roles = aria_roles.filter((role) => import_aria_query.roles.get(role)?.abstract);
var non_abstract_roles = aria_roles.filter((name2) => !abstract_roles.includes(name2));
var non_interactive_roles = non_abstract_roles.filter((name2) => {
  const role = import_aria_query.roles.get(name2);
  return (
    // 'toolbar' does not descend from widget, but it does support
    // aria-activedescendant, thus in practice we treat it as a widget.
    // focusable tabpanel elements are recommended if any panels in a set contain content where the first element in the panel is not focusable.
    // 'generic' is meant to have no semantic meaning.
    // 'cell' is treated as CellRole by the AXObject which is interactive, so we treat 'cell' it as interactive as well.
    !["toolbar", "tabpanel", "generic", "cell"].includes(name2) && !role?.superClass.some((classes) => classes.includes("widget") || classes.includes("window"))
  );
}).concat(
  // The `progressbar` is descended from `widget`, but in practice, its
  // value is always `readonly`, so we treat it as a non-interactive role.
  "progressbar"
);
var interactive_roles = non_abstract_roles.filter(
  (name2) => !non_interactive_roles.includes(name2) && // 'generic' is meant to have no semantic meaning.
  name2 !== "generic"
);
var non_interactive_element_role_schemas = [];
var interactive_element_role_schemas = [];
for (const [schema2, roles] of import_aria_query.elementRoles.entries()) {
  if ([...roles].every((role) => role !== "generic" && non_interactive_roles.includes(role))) {
    non_interactive_element_role_schemas.push(schema2);
  }
  if ([...roles].every((role) => interactive_roles.includes(role))) {
    interactive_element_role_schemas.push(schema2);
  }
}
var interactive_ax_objects = [...import_axobject_query.AXObjects.keys()].filter(
  (name2) => import_axobject_query.AXObjects.get(name2).type === "widget"
);
var interactive_element_ax_object_schemas = [];
var non_interactive_element_ax_object_schemas = [];
var non_interactive_ax_objects = [...import_axobject_query.AXObjects.keys()].filter(
  (name2) => ["windows", "structure"].includes(import_axobject_query.AXObjects.get(name2).type)
);
for (const [schema2, ax_object] of import_axobject_query.elementAXObjects.entries()) {
  if ([...ax_object].every((role) => interactive_ax_objects.includes(role))) {
    interactive_element_ax_object_schemas.push(schema2);
  }
  if ([...ax_object].every((role) => non_interactive_ax_objects.includes(role))) {
    non_interactive_element_ax_object_schemas.push(schema2);
  }
}

// node_modules/.deno/svelte@5.43.8/node_modules/svelte/src/compiler/phases/2-analyze/visitors/shared/a11y/index.js
var import_aria_query2 = __toESM(require_lib(), 1);
var import_axobject_query2 = __toESM(require_lib2(), 1);

// node_modules/.deno/@jridgewell+sourcemap-codec@1.5.5/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs
var comma = ",".charCodeAt(0);
var semicolon = ";".charCodeAt(0);
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var intToChar = new Uint8Array(64);
var charToInt = new Uint8Array(128);
for (let i = 0; i < chars.length; i++) {
  const c = chars.charCodeAt(i);
  intToChar[i] = c;
  charToInt[c] = i;
}
var bufLength = 1024 * 16;
var td = typeof TextDecoder !== "undefined" ? new TextDecoder() : typeof Buffer !== "undefined" ? {
  decode(buf) {
    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
    return out.toString();
  }
} : {
  decode(buf) {
    let out = "";
    for (let i = 0; i < buf.length; i++) {
      out += String.fromCharCode(buf[i]);
    }
    return out;
  }
};

// node_modules/.deno/esrap@2.1.3/node_modules/esrap/src/index.js
var btoa2 = () => {
  throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
};
if (typeof window !== "undefined" && typeof window.btoa === "function") {
  btoa2 = (str2) => window.btoa(unescape(encodeURIComponent(str2)));
} else if (typeof Buffer === "function") {
  btoa2 = (str2) => Buffer.from(str2, "utf-8").toString("base64");
}

// node_modules/.deno/magic-string@0.30.21/node_modules/magic-string/dist/magic-string.es.mjs
function getBtoa() {
  if (typeof globalThis !== "undefined" && typeof globalThis.btoa === "function") {
    return (str2) => globalThis.btoa(unescape(encodeURIComponent(str2)));
  } else if (typeof Buffer === "function") {
    return (str2) => Buffer.from(str2, "utf-8").toString("base64");
  } else {
    return () => {
      throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
    };
  }
}
var btoa3 = getBtoa();

// node_modules/.deno/@jridgewell+trace-mapping@0.3.31/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.mjs
var import_resolve_uri = __toESM(require_resolve_uri_umd(), 1);

// node_modules/.deno/@jridgewell+remapping@2.3.5/node_modules/@jridgewell/remapping/dist/remapping.mjs
var SOURCELESS_MAPPING = SegmentObject("", -1, -1, "", null, false);
function SegmentObject(source2, line, column, name2, content, ignore2) {
  return { source: source2, line, column, name: name2, content, ignore: ignore2 };
}

// node_modules/.deno/svelte@5.43.8/node_modules/svelte/src/internal/server/hydration.js
var BLOCK_OPEN = `<!--${HYDRATION_START}-->`;
var BLOCK_OPEN_ELSE = `<!--${HYDRATION_START_ELSE}-->`;
var BLOCK_CLOSE = `<!--${HYDRATION_END}-->`;
var EMPTY_COMMENT = `<!---->`;

// node_modules/.deno/svelte@5.43.8/node_modules/svelte/src/compiler/phases/3-transform/server/visitors/shared/utils.js
var block_open = literal2(BLOCK_OPEN);
var block_open_else = literal2(BLOCK_OPEN_ELSE);
var block_close = literal2(BLOCK_CLOSE);
var empty_comment = literal2(EMPTY_COMMENT);

// node_modules/.deno/svelte@5.43.8/node_modules/svelte/src/compiler/phases/3-transform/client/transform-template/fix-attribute-casing.js
var svg_attributes = "accent-height accumulate additive alignment-baseline allowReorder alphabetic amplitude arabic-form ascent attributeName attributeType autoReverse azimuth baseFrequency baseline-shift baseProfile bbox begin bias by calcMode cap-height class clip clipPathUnits clip-path clip-rule color color-interpolation color-interpolation-filters color-profile color-rendering contentScriptType contentStyleType cursor cx cy d decelerate descent diffuseConstant direction display divisor dominant-baseline dur dx dy edgeMode elevation enable-background end exponent externalResourcesRequired fill fill-opacity fill-rule filter filterRes filterUnits flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight format from fr fx fy g1 g2 glyph-name glyph-orientation-horizontal glyph-orientation-vertical glyphRef gradientTransform gradientUnits hanging height href horiz-adv-x horiz-origin-x id ideographic image-rendering in in2 intercept k k1 k2 k3 k4 kernelMatrix kernelUnitLength kerning keyPoints keySplines keyTimes lang lengthAdjust letter-spacing lighting-color limitingConeAngle local marker-end marker-mid marker-start markerHeight markerUnits markerWidth mask maskContentUnits maskUnits mathematical max media method min mode name numOctaves offset onabort onactivate onbegin onclick onend onerror onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup onrepeat onresize onscroll onunload opacity operator order orient orientation origin overflow overline-position overline-thickness panose-1 paint-order pathLength patternContentUnits patternTransform patternUnits pointer-events points pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits r radius refX refY rendering-intent repeatCount repeatDur requiredExtensions requiredFeatures restart result rotate rx ry scale seed shape-rendering slope spacing specularConstant specularExponent speed spreadMethod startOffset stdDeviation stemh stemv stitchTiles stop-color stop-opacity strikethrough-position strikethrough-thickness string stroke stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width style surfaceScale systemLanguage tabindex tableValues target targetX targetY text-anchor text-decoration text-rendering textLength to transform type u1 u2 underline-position underline-thickness unicode unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical values version vert-adv-y vert-origin-x vert-origin-y viewBox viewTarget visibility width widths word-spacing writing-mode x x-height x1 x2 xChannelSelector xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space y y1 y2 yChannelSelector z zoomAndPan".split(
  " "
);
var svg_attribute_lookup = /* @__PURE__ */ new Map();
svg_attributes.forEach((name2) => {
  svg_attribute_lookup.set(name2.toLowerCase(), name2);
});

// node_modules/.deno/svelte@5.43.8/node_modules/svelte/src/compiler/validate-options.js
var common_options = {
  filename: string("(unknown)"),
  // default to process.cwd() where it exists to replicate svelte4 behavior (and make Deno work with this as well)
  // see https://github.com/sveltejs/svelte/blob/b62fc8c8fd2640c9b99168f01b9d958cb2f7574f/packages/svelte/src/compiler/compile/Component.js#L211
  /* eslint-disable */
  rootDir: string(
    typeof process !== "undefined" ? process.cwd?.() : (
      // @ts-expect-error
      typeof Deno !== "undefined" ? (
        // @ts-expect-error
        Deno.cwd()
      ) : void 0
    )
  ),
  /* eslint-enable */
  dev: boolean(false),
  generate: validator("client", (input, keypath) => {
    if (input === "dom" || input === "ssr") {
      warn_once(options_renamed_ssr_dom);
      return input === "dom" ? "client" : "server";
    }
    if (input !== "client" && input !== "server" && input !== false) {
      throw_error2(`${keypath} must be "client", "server" or false`);
    }
    return input;
  }),
  warningFilter: fun(() => true),
  experimental: object3({
    async: boolean(false)
  })
};
var component_options = {
  accessors: deprecate(options_deprecated_accessors, boolean(false)),
  css: validator("external", (input) => {
    if (input === true || input === false) {
      throw_error2(
        'The boolean options have been removed from the css option. Use "external" instead of false and "injected" instead of true'
      );
    }
    if (input === "none") {
      throw_error2(
        'css: "none" is no longer a valid option. If this was crucial for you, please open an issue on GitHub with your use case.'
      );
    }
    if (input !== "external" && input !== "injected") {
      throw_error2(`css should be either "external" (default, recommended) or "injected"`);
    }
    return input;
  }),
  cssHash: fun(({ css, filename: filename2, hash: hash2 }) => {
    return `svelte-${hash2(filename2 === "(unknown)" ? css : filename2 ?? css)}`;
  }),
  // TODO this is a sourcemap option, would be good to put under a sourcemap namespace
  cssOutputFilename: string(void 0),
  customElement: boolean(false),
  discloseVersion: boolean(true),
  immutable: deprecate(options_deprecated_immutable, boolean(false)),
  legacy: removed(
    "The legacy option has been removed. If you are using this because of legacy.componentApi, use compatibility.componentApi instead"
  ),
  compatibility: object3({
    componentApi: list2([4, 5], 5)
  }),
  loopGuardTimeout: warn_removed(options_removed_loop_guard_timeout),
  name: string(void 0),
  namespace: list2(["html", "mathml", "svg"]),
  modernAst: boolean(false),
  outputFilename: string(void 0),
  preserveComments: boolean(false),
  fragments: list2(["html", "tree"]),
  preserveWhitespace: boolean(false),
  runes: boolean(void 0),
  hmr: boolean(false),
  sourcemap: validator(void 0, (input) => {
    return input;
  }),
  enableSourcemap: warn_removed(options_removed_enable_sourcemap),
  hydratable: warn_removed(options_removed_hydratable),
  format: removed(
    'The format option has been removed in Svelte 4, the compiler only outputs ESM now. Remove "format" from your compiler options. If you did not set this yourself, bump the version of your bundler plugin (vite-plugin-svelte/rollup-plugin-svelte/svelte-loader)'
  ),
  tag: removed(
    'The tag option has been removed in Svelte 5. Use `<svelte:options customElement="tag-name" />` inside the component instead. If that does not solve your use case, please open an issue on GitHub with details.'
  ),
  sveltePath: removed(
    "The sveltePath option has been removed in Svelte 5. If this option was crucial for you, please open an issue on GitHub with your use case."
  ),
  // These two were primarily created for svelte-preprocess (https://github.com/sveltejs/svelte/pull/6194),
  // but with new TypeScript compilation modes strictly separating types it's not necessary anymore
  errorMode: removed(
    "The errorMode option has been removed. If you are using this through svelte-preprocess with TypeScript, use the https://www.typescriptlang.org/tsconfig#verbatimModuleSyntax setting instead"
  ),
  varsReport: removed(
    "The vars option has been removed. If you are using this through svelte-preprocess with TypeScript, use the https://www.typescriptlang.org/tsconfig#verbatimModuleSyntax setting instead"
  )
};
var validate_module_options = (
  /** @type {Validator<ModuleCompileOptions, ValidatedModuleCompileOptions>} */
  object3({
    ...common_options,
    ...Object.fromEntries(Object.keys(component_options).map((key2) => [key2, () => {
    }]))
  })
);
var validate_component_options = (
  /** @type {Validator<CompileOptions, ValidatedCompileOptions>} */
  object3({
    ...common_options,
    ...component_options
  })
);
function removed(msg) {
  return (input) => {
    if (input !== void 0) {
      options_removed(null, msg);
    }
    return (
      /** @type {any} */
      void 0
    );
  };
}
var warned = /* @__PURE__ */ new Set();
function warn_once(fn) {
  if (!warned.has(fn)) {
    warned.add(fn);
    fn(null);
  }
}
function warn_removed(fn) {
  return (input) => {
    if (input !== void 0) warn_once(fn);
    return (
      /** @type {any} */
      void 0
    );
  };
}
function deprecate(fn, validator2) {
  return (input, keypath) => {
    if (input !== void 0) warn_once(fn);
    return validator2(input, keypath);
  };
}
function object3(children, allow_unknown = false) {
  return (input, keypath) => {
    const output = {};
    if (input && typeof input !== "object" || Array.isArray(input)) {
      throw_error2(`${keypath} should be an object`);
    }
    for (const key2 in input) {
      if (!(key2 in children)) {
        if (allow_unknown) {
          output[key2] = input[key2];
        } else {
          options_unrecognised(null, `${keypath ? `${keypath}.${key2}` : key2}`);
        }
      }
    }
    for (const key2 in children) {
      const validator2 = children[key2];
      output[key2] = validator2(input && input[key2], keypath ? `${keypath}.${key2}` : key2);
    }
    return output;
  };
}
function validator(fallback, fn) {
  return (input, keypath) => {
    return input === void 0 ? fallback : fn(input, keypath);
  };
}
function string(fallback, allow_empty = true) {
  return validator(fallback, (input, keypath) => {
    if (typeof input !== "string") {
      throw_error2(`${keypath} should be a string, if specified`);
    }
    if (!allow_empty && input === "") {
      throw_error2(`${keypath} cannot be empty`);
    }
    return input;
  });
}
function boolean(fallback) {
  return validator(fallback, (input, keypath) => {
    if (typeof input !== "boolean") {
      throw_error2(`${keypath} should be true or false, if specified`);
    }
    return input;
  });
}
function list2(options2, fallback = options2[0]) {
  return validator(fallback, (input, keypath) => {
    if (!options2.includes(input)) {
      const msg = options2.length > 2 ? `${keypath} should be one of ${options2.slice(0, -1).map((input2) => `"${input2}"`).join(", ")} or "${options2[options2.length - 1]}"` : `${keypath} should be either "${options2[0]}" or "${options2[1]}"`;
      throw_error2(msg);
    }
    return input;
  });
}
function fun(fallback) {
  return validator(fallback, (input, keypath) => {
    if (typeof input !== "function") {
      throw_error2(`${keypath} should be a function, if specified`);
    }
    return input;
  });
}
function throw_error2(msg) {
  options_invalid_value(null, msg);
}

// node_modules/.deno/svelte@5.43.8/node_modules/svelte/src/compiler/index.js
function parse6(source2, { modern, loose } = {}) {
  source2 = remove_bom(source2);
  reset({ warning: () => false, filename: void 0 });
  const ast2 = parse5(source2, loose);
  return to_public_ast(source2, ast2, modern);
}
function to_public_ast(source2, ast2, modern) {
  if (modern) {
    const clean = (node) => {
      delete node.metadata;
    };
    ast2.options?.attributes.forEach((attribute2) => {
      clean(attribute2);
      clean(attribute2.value);
      if (Array.isArray(attribute2.value)) {
        attribute2.value.forEach(clean);
      }
    });
    return walk(ast2, null, {
      _(node, { next: next2 }) {
        clean(node);
        next2();
      }
    });
  }
  return convert(source2, ast2);
}
function remove_bom(source2) {
  if (source2.charCodeAt(0) === 65279) {
    return source2.slice(1);
  }
  return source2;
}

// node_modules/.deno/mdsvex@0.12.6/node_modules/mdsvex/dist/main-hjyl9aFB.js
var import_path = __toESM(require_path(), 1);
var defineConfig = (config) => config;
function make_process() {
  const process2 = {
    title: "browser",
    argv: [],
    version: "",
    // empty string to avoid regexp issues
    versions: {
      http_parser: "",
      node: "",
      v8: "",
      ares: "",
      uv: "",
      zlib: "",
      brotli: "",
      modules: "",
      nghttp2: "",
      napi: "",
      llhttp: "",
      openssl: "",
      icu: "",
      tz: "",
      unicode: ""
    },
    env: {
      NODE_ENV: "production"
    },
    stdout: {
      isTTY: false
    },
    binding() {
      return;
    },
    cwd() {
      return "/";
    },
    chdir() {
      return;
    },
    umask() {
      return 0;
    },
    on: noop2,
    addListener: noop2,
    once: noop2,
    off: noop2,
    removeListener: noop2,
    removeAllListeners: noop2,
    emit: noop2
  };
  function noop2() {
  }
  return process2;
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var bail_1 = bail$2;
function bail$2(err) {
  if (err) {
    throw err;
  }
}
var isBuffer = function isBuffer2(obj) {
  return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
};
var hasOwn2 = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var defineProperty = Object.defineProperty;
var gOPD = Object.getOwnPropertyDescriptor;
var isArray2 = function isArray3(arr) {
  if (typeof Array.isArray === "function") {
    return Array.isArray(arr);
  }
  return toStr.call(arr) === "[object Array]";
};
var isPlainObject = function isPlainObject2(obj) {
  if (!obj || toStr.call(obj) !== "[object Object]") {
    return false;
  }
  var hasOwnConstructor = hasOwn2.call(obj, "constructor");
  var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn2.call(obj.constructor.prototype, "isPrototypeOf");
  if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
    return false;
  }
  var key2;
  for (key2 in obj) {
  }
  return typeof key2 === "undefined" || hasOwn2.call(obj, key2);
};
var setProperty = function setProperty2(target2, options2) {
  if (defineProperty && options2.name === "__proto__") {
    defineProperty(target2, options2.name, {
      enumerable: true,
      configurable: true,
      value: options2.newValue,
      writable: true
    });
  } else {
    target2[options2.name] = options2.newValue;
  }
};
var getProperty = function getProperty2(obj, name2) {
  if (name2 === "__proto__") {
    if (!hasOwn2.call(obj, name2)) {
      return void 0;
    } else if (gOPD) {
      return gOPD(obj, name2).value;
    }
  }
  return obj[name2];
};
var extend$5 = function extend2() {
  var options2, name2, src, copy2, copyIsArray, clone;
  var target2 = arguments[0];
  var i = 1;
  var length = arguments.length;
  var deep = false;
  if (typeof target2 === "boolean") {
    deep = target2;
    target2 = arguments[1] || {};
    i = 2;
  }
  if (target2 == null || typeof target2 !== "object" && typeof target2 !== "function") {
    target2 = {};
  }
  for (; i < length; ++i) {
    options2 = arguments[i];
    if (options2 != null) {
      for (name2 in options2) {
        src = getProperty(target2, name2);
        copy2 = getProperty(options2, name2);
        if (target2 !== copy2) {
          if (deep && copy2 && (isPlainObject(copy2) || (copyIsArray = isArray2(copy2)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && isArray2(src) ? src : [];
            } else {
              clone = src && isPlainObject(src) ? src : {};
            }
            setProperty(target2, { name: name2, newValue: extend2(deep, clone, copy2) });
          } else if (typeof copy2 !== "undefined") {
            setProperty(target2, { name: name2, newValue: copy2 });
          }
        }
      }
    }
  }
  return target2;
};
var isPlainObj = (value) => {
  if (Object.prototype.toString.call(value) !== "[object Object]") {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return prototype === null || prototype === Object.prototype;
};
var slice$3 = [].slice;
var wrap_1$1 = wrap$8;
function wrap$8(fn, callback) {
  var invoked;
  return wrapped;
  function wrapped() {
    var params = slice$3.call(arguments, 0);
    var callback2 = fn.length > params.length;
    var result;
    if (callback2) {
      params.push(done);
    }
    try {
      result = fn.apply(null, params);
    } catch (error) {
      if (callback2 && invoked) {
        throw error;
      }
      return done(error);
    }
    if (!callback2) {
      if (result && typeof result.then === "function") {
        result.then(then, done);
      } else if (result instanceof Error) {
        done(result);
      } else {
        then(result);
      }
    }
  }
  function done() {
    if (!invoked) {
      invoked = true;
      callback.apply(null, arguments);
    }
  }
  function then(value) {
    done(null, value);
  }
}
var wrap$7 = wrap_1$1;
var trough_1 = trough$2;
trough$2.wrap = wrap$7;
var slice$2 = [].slice;
function trough$2() {
  var fns = [];
  var middleware = {};
  middleware.run = run2;
  middleware.use = use;
  return middleware;
  function run2() {
    var index2 = -1;
    var input = slice$2.call(arguments, 0, -1);
    var done = arguments[arguments.length - 1];
    if (typeof done !== "function") {
      throw new Error("Expected function as last argument, not " + done);
    }
    next2.apply(null, [null].concat(input));
    function next2(err) {
      var fn = fns[++index2];
      var params = slice$2.call(arguments, 0);
      var values = params.slice(1);
      var length = input.length;
      var pos = -1;
      if (err) {
        done(err);
        return;
      }
      while (++pos < length) {
        if (values[pos] === null || values[pos] === void 0) {
          values[pos] = input[pos];
        }
      }
      input = values;
      if (fn) {
        wrap$7(fn, next2).apply(null, input);
      } else {
        done.apply(null, [null].concat(input));
      }
    }
  }
  function use(fn) {
    if (typeof fn !== "function") {
      throw new Error("Expected `fn` to be a function, not " + fn);
    }
    fns.push(fn);
    return middleware;
  }
}
var own$c = {}.hasOwnProperty;
var unistUtilStringifyPosition = stringify$6;
function stringify$6(value) {
  if (!value || typeof value !== "object") {
    return "";
  }
  if (own$c.call(value, "position") || own$c.call(value, "type")) {
    return position$3(value.position);
  }
  if (own$c.call(value, "start") || own$c.call(value, "end")) {
    return position$3(value);
  }
  if (own$c.call(value, "line") || own$c.call(value, "column")) {
    return point(value);
  }
  return "";
}
function point(point2) {
  if (!point2 || typeof point2 !== "object") {
    point2 = {};
  }
  return index(point2.line) + ":" + index(point2.column);
}
function position$3(pos) {
  if (!pos || typeof pos !== "object") {
    pos = {};
  }
  return point(pos.start) + "-" + point(pos.end);
}
function index(value) {
  return value && typeof value === "number" ? value : 1;
}
var stringify$5 = unistUtilStringifyPosition;
var vfileMessage = VMessage$1;
function VMessagePrototype() {
}
VMessagePrototype.prototype = Error.prototype;
VMessage$1.prototype = new VMessagePrototype();
var proto$6 = VMessage$1.prototype;
proto$6.file = "";
proto$6.name = "";
proto$6.reason = "";
proto$6.message = "";
proto$6.stack = "";
proto$6.fatal = null;
proto$6.column = null;
proto$6.line = null;
function VMessage$1(reason, position2, origin) {
  var parts;
  var range2;
  var location;
  if (typeof position2 === "string") {
    origin = position2;
    position2 = null;
  }
  parts = parseOrigin(origin);
  range2 = stringify$5(position2) || "1:1";
  location = {
    start: { line: null, column: null },
    end: { line: null, column: null }
  };
  if (position2 && position2.position) {
    position2 = position2.position;
  }
  if (position2) {
    if (position2.start) {
      location = position2;
      position2 = position2.start;
    } else {
      location.start = position2;
    }
  }
  if (reason.stack) {
    this.stack = reason.stack;
    reason = reason.message;
  }
  this.message = reason;
  this.name = range2;
  this.reason = reason;
  this.line = position2 ? position2.line : null;
  this.column = position2 ? position2.column : null;
  this.location = location;
  this.source = parts[0];
  this.ruleId = parts[1];
}
function parseOrigin(origin) {
  var result = [null, null];
  var index2;
  if (typeof origin === "string") {
    index2 = origin.indexOf(":");
    if (index2 === -1) {
      result[1] = origin;
    } else {
      result[0] = origin.slice(0, index2);
      result[1] = origin.slice(index2 + 1);
    }
  }
  return result;
}
var Message = getDefaultExportFromCjs(vfileMessage);
var path$2 = import_path.default;
function replaceExt(npath, ext) {
  if (typeof npath !== "string") {
    return npath;
  }
  if (npath.length === 0) {
    return npath;
  }
  var nFileName = path$2.basename(npath, path$2.extname(npath)) + ext;
  return path$2.join(path$2.dirname(npath), nFileName);
}
var replaceExt_1 = replaceExt;
var path$1 = import_path.default;
var replace = replaceExt_1;
var buffer$1 = isBuffer;
var core$1 = VFile$1;
var own$b = {}.hasOwnProperty;
var proto$5 = VFile$1.prototype;
var order$1 = ["history", "path", "basename", "stem", "extname", "dirname"];
proto$5.toString = toString$3;
Object.defineProperty(proto$5, "path", { get: getPath, set: setPath });
Object.defineProperty(proto$5, "dirname", { get: getDirname, set: setDirname });
Object.defineProperty(proto$5, "basename", { get: getBasename, set: setBasename });
Object.defineProperty(proto$5, "extname", { get: getExtname, set: setExtname });
Object.defineProperty(proto$5, "stem", { get: getStem, set: setStem });
function VFile$1(options2) {
  var prop3;
  var index2;
  var length;
  if (!options2) {
    options2 = {};
  } else if (typeof options2 === "string" || buffer$1(options2)) {
    options2 = { contents: options2 };
  } else if ("message" in options2 && "messages" in options2) {
    return options2;
  }
  if (!(this instanceof VFile$1)) {
    return new VFile$1(options2);
  }
  this.data = {};
  this.messages = [];
  this.history = [];
  this.cwd = process.cwd();
  index2 = -1;
  length = order$1.length;
  while (++index2 < length) {
    prop3 = order$1[index2];
    if (own$b.call(options2, prop3)) {
      this[prop3] = options2[prop3];
    }
  }
  for (prop3 in options2) {
    if (order$1.indexOf(prop3) === -1) {
      this[prop3] = options2[prop3];
    }
  }
}
function getPath() {
  return this.history[this.history.length - 1];
}
function setPath(path2) {
  assertNonEmpty(path2, "path");
  if (path2 !== this.path) {
    this.history.push(path2);
  }
}
function getDirname() {
  return typeof this.path === "string" ? path$1.dirname(this.path) : void 0;
}
function setDirname(dirname) {
  assertPath(this.path, "dirname");
  this.path = path$1.join(dirname || "", this.basename);
}
function getBasename() {
  return typeof this.path === "string" ? path$1.basename(this.path) : void 0;
}
function setBasename(basename) {
  assertNonEmpty(basename, "basename");
  assertPart(basename, "basename");
  this.path = path$1.join(this.dirname || "", basename);
}
function getExtname() {
  return typeof this.path === "string" ? path$1.extname(this.path) : void 0;
}
function setExtname(extname) {
  var ext = extname || "";
  assertPart(ext, "extname");
  assertPath(this.path, "extname");
  if (ext) {
    if (ext.charAt(0) !== ".") {
      throw new Error("`extname` must start with `.`");
    }
    if (ext.indexOf(".", 1) !== -1) {
      throw new Error("`extname` cannot contain multiple dots");
    }
  }
  this.path = replace(this.path, ext);
}
function getStem() {
  return typeof this.path === "string" ? path$1.basename(this.path, this.extname) : void 0;
}
function setStem(stem) {
  assertNonEmpty(stem, "stem");
  assertPart(stem, "stem");
  this.path = path$1.join(this.dirname || "", stem + (this.extname || ""));
}
function toString$3(encoding) {
  var value = this.contents || "";
  return buffer$1(value) ? value.toString(encoding) : String(value);
}
function assertPart(part2, name2) {
  if (part2.indexOf(path$1.sep) !== -1) {
    throw new Error(
      "`" + name2 + "` cannot be a path: did not expect `" + path$1.sep + "`"
    );
  }
}
function assertNonEmpty(part2, name2) {
  if (!part2) {
    throw new Error("`" + name2 + "` cannot be empty");
  }
}
function assertPath(path2, name2) {
  if (!path2) {
    throw new Error("Setting `" + name2 + "` requires `path` to be set too");
  }
}
var VMessage = vfileMessage;
var VFile = core$1;
var vfile$2 = VFile;
var proto$4 = VFile.prototype;
proto$4.message = message;
proto$4.info = info$1;
proto$4.fail = fail;
function message(reason, position2, origin) {
  var filePath = this.path;
  var message2 = new VMessage(reason, position2, origin);
  if (filePath) {
    message2.name = filePath + ":" + message2.name;
    message2.file = filePath;
  }
  message2.fatal = false;
  this.messages.push(message2);
  return message2;
}
function fail() {
  var message2 = this.message.apply(this, arguments);
  message2.fatal = true;
  throw message2;
}
function info$1() {
  var message2 = this.message.apply(this, arguments);
  message2.fatal = null;
  return message2;
}
var bail$1 = bail_1;
var buffer = isBuffer;
var extend$4 = extend$5;
var plain$1 = isPlainObj;
var trough$1 = trough_1;
var vfile$1 = vfile$2;
var unified_1$1 = unified$2().freeze();
var slice$1 = [].slice;
var own$a = {}.hasOwnProperty;
var pipeline$1 = trough$1().use(pipelineParse$1).use(pipelineRun$1).use(pipelineStringify$1);
function pipelineParse$1(p2, ctx) {
  ctx.tree = p2.parse(ctx.file);
}
function pipelineRun$1(p2, ctx, next2) {
  p2.run(ctx.tree, ctx.file, done);
  function done(err, tree, file) {
    if (err) {
      next2(err);
    } else {
      ctx.tree = tree;
      ctx.file = file;
      next2();
    }
  }
}
function pipelineStringify$1(p2, ctx) {
  var result = p2.stringify(ctx.tree, ctx.file);
  var file = ctx.file;
  if (result === void 0 || result === null) ;
  else if (typeof result === "string" || buffer(result)) {
    file.contents = result;
  } else {
    file.result = result;
  }
}
function unified$2() {
  var attachers = [];
  var transformers = trough$1();
  var namespace = {};
  var frozen = false;
  var freezeIndex = -1;
  processor.data = data3;
  processor.freeze = freeze;
  processor.attachers = attachers;
  processor.use = use;
  processor.parse = parse8;
  processor.stringify = stringify2;
  processor.run = run2;
  processor.runSync = runSync;
  processor.process = process2;
  processor.processSync = processSync;
  return processor;
  function processor() {
    var destination = unified$2();
    var length = attachers.length;
    var index2 = -1;
    while (++index2 < length) {
      destination.use.apply(null, attachers[index2]);
    }
    destination.data(extend$4(true, {}, namespace));
    return destination;
  }
  function freeze() {
    var values;
    var plugin;
    var options2;
    var transformer;
    if (frozen) {
      return processor;
    }
    while (++freezeIndex < attachers.length) {
      values = attachers[freezeIndex];
      plugin = values[0];
      options2 = values[1];
      transformer = null;
      if (options2 === false) {
        continue;
      }
      if (options2 === true) {
        values[1] = void 0;
      }
      transformer = plugin.apply(processor, values.slice(1));
      if (typeof transformer === "function") {
        transformers.use(transformer);
      }
    }
    frozen = true;
    freezeIndex = Infinity;
    return processor;
  }
  function data3(key2, value) {
    if (typeof key2 === "string") {
      if (arguments.length === 2) {
        assertUnfrozen$1("data", frozen);
        namespace[key2] = value;
        return processor;
      }
      return own$a.call(namespace, key2) && namespace[key2] || null;
    }
    if (key2) {
      assertUnfrozen$1("data", frozen);
      namespace = key2;
      return processor;
    }
    return namespace;
  }
  function use(value) {
    var settings;
    assertUnfrozen$1("use", frozen);
    if (value === null || value === void 0) ;
    else if (typeof value === "function") {
      addPlugin.apply(null, arguments);
    } else if (typeof value === "object") {
      if ("length" in value) {
        addList(value);
      } else {
        addPreset(value);
      }
    } else {
      throw new Error("Expected usable value, not `" + value + "`");
    }
    if (settings) {
      namespace.settings = extend$4(namespace.settings || {}, settings);
    }
    return processor;
    function addPreset(result) {
      addList(result.plugins);
      if (result.settings) {
        settings = extend$4(settings || {}, result.settings);
      }
    }
    function add(value2) {
      if (typeof value2 === "function") {
        addPlugin(value2);
      } else if (typeof value2 === "object") {
        if ("length" in value2) {
          addPlugin.apply(null, value2);
        } else {
          addPreset(value2);
        }
      } else {
        throw new Error("Expected usable value, not `" + value2 + "`");
      }
    }
    function addList(plugins) {
      var length;
      var index2;
      if (plugins === null || plugins === void 0) ;
      else if (typeof plugins === "object" && "length" in plugins) {
        length = plugins.length;
        index2 = -1;
        while (++index2 < length) {
          add(plugins[index2]);
        }
      } else {
        throw new Error("Expected a list of plugins, not `" + plugins + "`");
      }
    }
    function addPlugin(plugin, value2) {
      var entry = find2(plugin);
      if (entry) {
        if (plain$1(entry[1]) && plain$1(value2)) {
          value2 = extend$4(entry[1], value2);
        }
        entry[1] = value2;
      } else {
        attachers.push(slice$1.call(arguments));
      }
    }
  }
  function find2(plugin) {
    var length = attachers.length;
    var index2 = -1;
    var entry;
    while (++index2 < length) {
      entry = attachers[index2];
      if (entry[0] === plugin) {
        return entry;
      }
    }
  }
  function parse8(doc) {
    var file = vfile$1(doc);
    var Parser5;
    freeze();
    Parser5 = processor.Parser;
    assertParser$1("parse", Parser5);
    if (newable$1(Parser5, "parse")) {
      return new Parser5(String(file), file).parse();
    }
    return Parser5(String(file), file);
  }
  function run2(node, file, cb) {
    assertNode$1(node);
    freeze();
    if (!cb && typeof file === "function") {
      cb = file;
      file = null;
    }
    if (!cb) {
      return new Promise(executor);
    }
    executor(null, cb);
    function executor(resolve, reject) {
      transformers.run(node, vfile$1(file), done);
      function done(err, tree, file2) {
        tree = tree || node;
        if (err) {
          reject(err);
        } else if (resolve) {
          resolve(tree);
        } else {
          cb(null, tree, file2);
        }
      }
    }
  }
  function runSync(node, file) {
    var complete = false;
    var result;
    run2(node, file, done);
    assertDone$1("runSync", "run", complete);
    return result;
    function done(err, tree) {
      complete = true;
      bail$1(err);
      result = tree;
    }
  }
  function stringify2(node, doc) {
    var file = vfile$1(doc);
    var Compiler;
    freeze();
    Compiler = processor.Compiler;
    assertCompiler$1("stringify", Compiler);
    assertNode$1(node);
    if (newable$1(Compiler, "compile")) {
      return new Compiler(node, file).compile();
    }
    return Compiler(node, file);
  }
  function process2(doc, cb) {
    freeze();
    assertParser$1("process", processor.Parser);
    assertCompiler$1("process", processor.Compiler);
    if (!cb) {
      return new Promise(executor);
    }
    executor(null, cb);
    function executor(resolve, reject) {
      var file = vfile$1(doc);
      pipeline$1.run(processor, { file }, done);
      function done(err) {
        if (err) {
          reject(err);
        } else if (resolve) {
          resolve(file);
        } else {
          cb(null, file);
        }
      }
    }
  }
  function processSync(doc) {
    var complete = false;
    var file;
    freeze();
    assertParser$1("processSync", processor.Parser);
    assertCompiler$1("processSync", processor.Compiler);
    file = vfile$1(doc);
    process2(file, done);
    assertDone$1("processSync", "process", complete);
    return file;
    function done(err) {
      complete = true;
      bail$1(err);
    }
  }
}
function newable$1(value, name2) {
  return typeof value === "function" && value.prototype && // A function with keys in its prototype is probably a constructor.
  // Classes prototype methods are not enumerable, so we check if some value
  // exists in the prototype.
  (keys$2(value.prototype) || name2 in value.prototype);
}
function keys$2(value) {
  var key2;
  for (key2 in value) {
    return true;
  }
  return false;
}
function assertParser$1(name2, Parser5) {
  if (typeof Parser5 !== "function") {
    throw new Error("Cannot `" + name2 + "` without `Parser`");
  }
}
function assertCompiler$1(name2, Compiler) {
  if (typeof Compiler !== "function") {
    throw new Error("Cannot `" + name2 + "` without `Compiler`");
  }
}
function assertUnfrozen$1(name2, frozen) {
  if (frozen) {
    throw new Error(
      "Cannot invoke `" + name2 + "` on a frozen processor.\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`."
    );
  }
}
function assertNode$1(node) {
  if (!node || typeof node.type !== "string") {
    throw new Error("Expected node, got `" + node + "`");
  }
}
function assertDone$1(name2, asyncName, complete) {
  if (!complete) {
    throw new Error(
      "`" + name2 + "` finished async. Use `" + asyncName + "` instead"
    );
  }
}
var unified$3 = getDefaultExportFromCjs(unified_1$1);
var immutable = extend$3;
var hasOwnProperty2 = Object.prototype.hasOwnProperty;
function extend$3() {
  var target2 = {};
  for (var i = 0; i < arguments.length; i++) {
    var source2 = arguments[i];
    for (var key2 in source2) {
      if (hasOwnProperty2.call(source2, key2)) {
        target2[key2] = source2[key2];
      }
    }
  }
  return target2;
}
var inherits$1 = { exports: {} };
var inherits_browser = { exports: {} };
var hasRequiredInherits_browser;
function requireInherits_browser() {
  if (hasRequiredInherits_browser) return inherits_browser.exports;
  hasRequiredInherits_browser = 1;
  if (typeof Object.create === "function") {
    inherits_browser.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    inherits_browser.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  return inherits_browser.exports;
}
try {
  util = require_util();
  if (typeof util.inherits !== "function") throw "";
  inherits$1.exports = util.inherits;
} catch (e2) {
  inherits$1.exports = requireInherits_browser();
}
var util;
var inheritsExports = inherits$1.exports;
var xtend$4 = immutable;
var inherits = inheritsExports;
var unherit_1 = unherit$2;
function unherit$2(Super) {
  var result;
  var key2;
  var value;
  inherits(Of, Super);
  inherits(From, Of);
  result = Of.prototype;
  for (key2 in result) {
    value = result[key2];
    if (value && typeof value === "object") {
      result[key2] = "concat" in value ? value.concat() : xtend$4(value);
    }
  }
  return Of;
  function From(parameters) {
    return Super.apply(this, parameters);
  }
  function Of() {
    if (!(this instanceof Of)) {
      return new From(arguments);
    }
    return Super.apply(this, arguments);
  }
}
var stateToggle = factory$6;
function factory$6(key2, state, ctx) {
  return enter;
  function enter() {
    var context2 = ctx || this;
    var current2 = context2[key2];
    context2[key2] = !state;
    return exit;
    function exit() {
      context2[key2] = current2;
    }
  }
}
var vfileLocation$1 = factory$5;
function factory$5(file) {
  var contents = indices(String(file));
  return {
    toPosition: offsetToPositionFactory(contents),
    toOffset: positionToOffsetFactory(contents)
  };
}
function offsetToPositionFactory(indices2) {
  return offsetToPosition;
  function offsetToPosition(offset2) {
    var index2 = -1;
    var length = indices2.length;
    if (offset2 < 0) {
      return {};
    }
    while (++index2 < length) {
      if (indices2[index2] > offset2) {
        return {
          line: index2 + 1,
          column: offset2 - (indices2[index2 - 1] || 0) + 1,
          offset: offset2
        };
      }
    }
    return {};
  }
}
function positionToOffsetFactory(indices2) {
  return positionToOffset;
  function positionToOffset(position2) {
    var line = position2 && position2.line;
    var column = position2 && position2.column;
    if (!isNaN(line) && !isNaN(column) && line - 1 in indices2) {
      return (indices2[line - 2] || 0) + column - 1 || 0;
    }
    return -1;
  }
}
function indices(value) {
  var result = [];
  var index2 = value.indexOf("\n");
  while (index2 !== -1) {
    result.push(index2 + 1);
    index2 = value.indexOf("\n", index2 + 1);
  }
  result.push(value.length + 1);
  return result;
}
var _unescape = factory$4;
var backslash = "\\";
function factory$4(ctx, key2) {
  return unescape3;
  function unescape3(value) {
    var previous = 0;
    var index2 = value.indexOf(backslash);
    var escape2 = ctx[key2];
    var queue = [];
    var character;
    while (index2 !== -1) {
      queue.push(value.slice(previous, index2));
      previous = index2 + 1;
      character = value.charAt(previous);
      if (!character || escape2.indexOf(character) === -1) {
        queue.push(backslash);
      }
      index2 = value.indexOf(backslash, previous + 1);
    }
    queue.push(value.slice(previous));
    return queue.join("");
  }
}
var AElig$2 = "";
var AMP$2 = "&";
var Aacute$2 = "";
var Acirc$2 = "";
var Agrave$2 = "";
var Aring$2 = "";
var Atilde$2 = "";
var Auml$2 = "";
var COPY$1 = "";
var Ccedil$2 = "";
var ETH$2 = "";
var Eacute$2 = "";
var Ecirc$2 = "";
var Egrave$2 = "";
var Euml$2 = "";
var GT$2 = ">";
var Iacute$2 = "";
var Icirc$2 = "";
var Igrave$2 = "";
var Iuml$2 = "";
var LT$2 = "<";
var Ntilde$2 = "";
var Oacute$2 = "";
var Ocirc$2 = "";
var Ograve$2 = "";
var Oslash$2 = "";
var Otilde$2 = "";
var Ouml$2 = "";
var QUOT$1 = '"';
var REG$1 = "";
var THORN$2 = "";
var Uacute$2 = "";
var Ucirc$2 = "";
var Ugrave$2 = "";
var Uuml$2 = "";
var Yacute$2 = "";
var aacute$2 = "";
var acirc$2 = "";
var acute$2 = "";
var aelig$2 = "";
var agrave$2 = "";
var amp$2 = "&";
var aring$2 = "";
var atilde$2 = "";
var auml$2 = "";
var brvbar$2 = "";
var ccedil$2 = "";
var cedil$2 = "";
var cent$2 = "";
var copy$2 = "";
var curren$2 = "";
var deg$2 = "";
var divide$2 = "";
var eacute$2 = "";
var ecirc$2 = "";
var egrave$2 = "";
var eth$2 = "";
var euml$2 = "";
var frac12$2 = "";
var frac14$2 = "";
var frac34$2 = "";
var gt$2 = ">";
var iacute$2 = "";
var icirc$2 = "";
var iexcl$2 = "";
var igrave$2 = "";
var iquest$2 = "";
var iuml$2 = "";
var laquo$2 = "";
var lt$2 = "<";
var macr$2 = "";
var micro$2 = "";
var middot$2 = "";
var nbsp$2 = "";
var not$2 = "";
var ntilde$2 = "";
var oacute$2 = "";
var ocirc$2 = "";
var ograve$2 = "";
var ordf$2 = "";
var ordm$2 = "";
var oslash$2 = "";
var otilde$2 = "";
var ouml$2 = "";
var para$2 = "";
var plusmn$2 = "";
var pound$2 = "";
var quot$2 = '"';
var raquo$2 = "";
var reg$2 = "";
var sect$2 = "";
var shy$2 = "";
var sup1$2 = "";
var sup2$2 = "";
var sup3$2 = "";
var szlig$2 = "";
var thorn$2 = "";
var times$2 = "";
var uacute$2 = "";
var ucirc$2 = "";
var ugrave$2 = "";
var uml$2 = "";
var uuml$2 = "";
var yacute$2 = "";
var yen$2 = "";
var yuml$2 = "";
var require$$1$2 = {
  AElig: AElig$2,
  AMP: AMP$2,
  Aacute: Aacute$2,
  Acirc: Acirc$2,
  Agrave: Agrave$2,
  Aring: Aring$2,
  Atilde: Atilde$2,
  Auml: Auml$2,
  COPY: COPY$1,
  Ccedil: Ccedil$2,
  ETH: ETH$2,
  Eacute: Eacute$2,
  Ecirc: Ecirc$2,
  Egrave: Egrave$2,
  Euml: Euml$2,
  GT: GT$2,
  Iacute: Iacute$2,
  Icirc: Icirc$2,
  Igrave: Igrave$2,
  Iuml: Iuml$2,
  LT: LT$2,
  Ntilde: Ntilde$2,
  Oacute: Oacute$2,
  Ocirc: Ocirc$2,
  Ograve: Ograve$2,
  Oslash: Oslash$2,
  Otilde: Otilde$2,
  Ouml: Ouml$2,
  QUOT: QUOT$1,
  REG: REG$1,
  THORN: THORN$2,
  Uacute: Uacute$2,
  Ucirc: Ucirc$2,
  Ugrave: Ugrave$2,
  Uuml: Uuml$2,
  Yacute: Yacute$2,
  aacute: aacute$2,
  acirc: acirc$2,
  acute: acute$2,
  aelig: aelig$2,
  agrave: agrave$2,
  amp: amp$2,
  aring: aring$2,
  atilde: atilde$2,
  auml: auml$2,
  brvbar: brvbar$2,
  ccedil: ccedil$2,
  cedil: cedil$2,
  cent: cent$2,
  copy: copy$2,
  curren: curren$2,
  deg: deg$2,
  divide: divide$2,
  eacute: eacute$2,
  ecirc: ecirc$2,
  egrave: egrave$2,
  eth: eth$2,
  euml: euml$2,
  frac12: frac12$2,
  frac14: frac14$2,
  frac34: frac34$2,
  gt: gt$2,
  iacute: iacute$2,
  icirc: icirc$2,
  iexcl: iexcl$2,
  igrave: igrave$2,
  iquest: iquest$2,
  iuml: iuml$2,
  laquo: laquo$2,
  lt: lt$2,
  macr: macr$2,
  micro: micro$2,
  middot: middot$2,
  nbsp: nbsp$2,
  not: not$2,
  ntilde: ntilde$2,
  oacute: oacute$2,
  ocirc: ocirc$2,
  ograve: ograve$2,
  ordf: ordf$2,
  ordm: ordm$2,
  oslash: oslash$2,
  otilde: otilde$2,
  ouml: ouml$2,
  para: para$2,
  plusmn: plusmn$2,
  pound: pound$2,
  quot: quot$2,
  raquo: raquo$2,
  reg: reg$2,
  sect: sect$2,
  shy: shy$2,
  sup1: sup1$2,
  sup2: sup2$2,
  sup3: sup3$2,
  szlig: szlig$2,
  thorn: thorn$2,
  times: times$2,
  uacute: uacute$2,
  ucirc: ucirc$2,
  ugrave: ugrave$2,
  uml: uml$2,
  uuml: uuml$2,
  yacute: yacute$2,
  yen: yen$2,
  yuml: yuml$2
};
var require$$1$1 = {
  "0": "",
  "128": "",
  "130": "",
  "131": "",
  "132": "",
  "133": "",
  "134": "",
  "135": "",
  "136": "",
  "137": "",
  "138": "",
  "139": "",
  "140": "",
  "142": "",
  "145": "",
  "146": "",
  "147": "",
  "148": "",
  "149": "",
  "150": "",
  "151": "",
  "152": "",
  "153": "",
  "154": "",
  "155": "",
  "156": "",
  "158": "",
  "159": ""
};
var isDecimal;
var hasRequiredIsDecimal;
function requireIsDecimal() {
  if (hasRequiredIsDecimal) return isDecimal;
  hasRequiredIsDecimal = 1;
  isDecimal = decimal2;
  function decimal2(character) {
    var code2 = typeof character === "string" ? character.charCodeAt(0) : character;
    return code2 >= 48 && code2 <= 57;
  }
  return isDecimal;
}
var isHexadecimal = hexadecimal$2;
function hexadecimal$2(character) {
  var code2 = typeof character === "string" ? character.charCodeAt(0) : character;
  return code2 >= 97 && code2 <= 102 || code2 >= 65 && code2 <= 70 || code2 >= 48 && code2 <= 57;
}
var isAlphabetical;
var hasRequiredIsAlphabetical;
function requireIsAlphabetical() {
  if (hasRequiredIsAlphabetical) return isAlphabetical;
  hasRequiredIsAlphabetical = 1;
  isAlphabetical = alphabetical2;
  function alphabetical2(character) {
    var code2 = typeof character === "string" ? character.charCodeAt(0) : character;
    return code2 >= 97 && code2 <= 122 || code2 >= 65 && code2 <= 90;
  }
  return isAlphabetical;
}
var alphabetical = requireIsAlphabetical();
var decimal$2 = requireIsDecimal();
var isAlphanumerical = alphanumerical$2;
function alphanumerical$2(character) {
  return alphabetical(character) || decimal$2(character);
}
var AEli = "";
var AElig$1 = "";
var AM = "&";
var AMP$1 = "&";
var Aacut = "";
var Aacute$1 = "";
var Abreve = "";
var Acir = "";
var Acirc$1 = "";
var Acy = "";
var Afr = "";
var Agrav = "";
var Agrave$1 = "";
var Alpha$1 = "";
var Amacr = "";
var And = "";
var Aogon = "";
var Aopf = "";
var ApplyFunction = "";
var Arin = "";
var Aring$1 = "";
var Ascr = "";
var Assign = "";
var Atild = "";
var Atilde$1 = "";
var Aum = "";
var Auml$1 = "";
var Backslash = "";
var Barv = "";
var Barwed = "";
var Bcy = "";
var Because = "";
var Bernoullis = "";
var Beta$1 = "";
var Bfr = "";
var Bopf = "";
var Breve = "";
var Bscr = "";
var Bumpeq = "";
var CHcy = "";
var COP = "";
var COPY = "";
var Cacute = "";
var Cap = "";
var CapitalDifferentialD = "";
var Cayleys = "";
var Ccaron = "";
var Ccedi = "";
var Ccedil$1 = "";
var Ccirc = "";
var Cconint = "";
var Cdot = "";
var Cedilla = "";
var CenterDot = "";
var Cfr = "";
var Chi$1 = "";
var CircleDot = "";
var CircleMinus = "";
var CirclePlus = "";
var CircleTimes = "";
var ClockwiseContourIntegral = "";
var CloseCurlyDoubleQuote = "";
var CloseCurlyQuote = "";
var Colon = "";
var Colone = "";
var Congruent = "";
var Conint = "";
var ContourIntegral = "";
var Copf = "";
var Coproduct = "";
var CounterClockwiseContourIntegral = "";
var Cross = "";
var Cscr = "";
var Cup = "";
var CupCap = "";
var DD = "";
var DDotrahd = "";
var DJcy = "";
var DScy = "";
var DZcy = "";
var Dagger$1 = "";
var Darr = "";
var Dashv = "";
var Dcaron = "";
var Dcy = "";
var Del = "";
var Delta$1 = "";
var Dfr = "";
var DiacriticalAcute = "";
var DiacriticalDot = "";
var DiacriticalDoubleAcute = "";
var DiacriticalGrave = "`";
var DiacriticalTilde = "";
var Diamond = "";
var DifferentialD = "";
var Dopf = "";
var Dot = "";
var DotDot = "";
var DotEqual = "";
var DoubleContourIntegral = "";
var DoubleDot = "";
var DoubleDownArrow = "";
var DoubleLeftArrow = "";
var DoubleLeftRightArrow = "";
var DoubleLeftTee = "";
var DoubleLongLeftArrow = "";
var DoubleLongLeftRightArrow = "";
var DoubleLongRightArrow = "";
var DoubleRightArrow = "";
var DoubleRightTee = "";
var DoubleUpArrow = "";
var DoubleUpDownArrow = "";
var DoubleVerticalBar = "";
var DownArrow = "";
var DownArrowBar = "";
var DownArrowUpArrow = "";
var DownBreve = "";
var DownLeftRightVector = "";
var DownLeftTeeVector = "";
var DownLeftVector = "";
var DownLeftVectorBar = "";
var DownRightTeeVector = "";
var DownRightVector = "";
var DownRightVectorBar = "";
var DownTee = "";
var DownTeeArrow = "";
var Downarrow = "";
var Dscr = "";
var Dstrok = "";
var ENG = "";
var ET = "";
var ETH$1 = "";
var Eacut = "";
var Eacute$1 = "";
var Ecaron = "";
var Ecir = "";
var Ecirc$1 = "";
var Ecy = "";
var Edot = "";
var Efr = "";
var Egrav = "";
var Egrave$1 = "";
var Element = "";
var Emacr = "";
var EmptySmallSquare = "";
var EmptyVerySmallSquare = "";
var Eogon = "";
var Eopf = "";
var Epsilon$1 = "";
var Equal = "";
var EqualTilde = "";
var Equilibrium = "";
var Escr = "";
var Esim = "";
var Eta$1 = "";
var Eum = "";
var Euml$1 = "";
var Exists = "";
var ExponentialE = "";
var Fcy = "";
var Ffr = "";
var FilledSmallSquare = "";
var FilledVerySmallSquare = "";
var Fopf = "";
var ForAll = "";
var Fouriertrf = "";
var Fscr = "";
var GJcy = "";
var G = ">";
var GT$1 = ">";
var Gamma$1 = "";
var Gammad = "";
var Gbreve = "";
var Gcedil = "";
var Gcirc = "";
var Gcy = "";
var Gdot = "";
var Gfr = "";
var Gg = "";
var Gopf = "";
var GreaterEqual = "";
var GreaterEqualLess = "";
var GreaterFullEqual = "";
var GreaterGreater = "";
var GreaterLess = "";
var GreaterSlantEqual = "";
var GreaterTilde = "";
var Gscr = "";
var Gt = "";
var HARDcy = "";
var Hacek = "";
var Hat = "^";
var Hcirc = "";
var Hfr = "";
var HilbertSpace = "";
var Hopf = "";
var HorizontalLine = "";
var Hscr = "";
var Hstrok = "";
var HumpDownHump = "";
var HumpEqual = "";
var IEcy = "";
var IJlig = "";
var IOcy = "";
var Iacut = "";
var Iacute$1 = "";
var Icir = "";
var Icirc$1 = "";
var Icy = "";
var Idot = "";
var Ifr = "";
var Igrav = "";
var Igrave$1 = "";
var Im = "";
var Imacr = "";
var ImaginaryI = "";
var Implies = "";
var Int = "";
var Integral = "";
var Intersection = "";
var InvisibleComma = "";
var InvisibleTimes = "";
var Iogon = "";
var Iopf = "";
var Iota$1 = "";
var Iscr = "";
var Itilde = "";
var Iukcy = "";
var Ium = "";
var Iuml$1 = "";
var Jcirc = "";
var Jcy = "";
var Jfr = "";
var Jopf = "";
var Jscr = "";
var Jsercy = "";
var Jukcy = "";
var KHcy = "";
var KJcy = "";
var Kappa$1 = "";
var Kcedil = "";
var Kcy = "";
var Kfr = "";
var Kopf = "";
var Kscr = "";
var LJcy = "";
var L = "<";
var LT$1 = "<";
var Lacute = "";
var Lambda$1 = "";
var Lang = "";
var Laplacetrf = "";
var Larr = "";
var Lcaron = "";
var Lcedil = "";
var Lcy = "";
var LeftAngleBracket = "";
var LeftArrow = "";
var LeftArrowBar = "";
var LeftArrowRightArrow = "";
var LeftCeiling = "";
var LeftDoubleBracket = "";
var LeftDownTeeVector = "";
var LeftDownVector = "";
var LeftDownVectorBar = "";
var LeftFloor = "";
var LeftRightArrow = "";
var LeftRightVector = "";
var LeftTee = "";
var LeftTeeArrow = "";
var LeftTeeVector = "";
var LeftTriangle = "";
var LeftTriangleBar = "";
var LeftTriangleEqual = "";
var LeftUpDownVector = "";
var LeftUpTeeVector = "";
var LeftUpVector = "";
var LeftUpVectorBar = "";
var LeftVector = "";
var LeftVectorBar = "";
var Leftarrow = "";
var Leftrightarrow = "";
var LessEqualGreater = "";
var LessFullEqual = "";
var LessGreater = "";
var LessLess = "";
var LessSlantEqual = "";
var LessTilde = "";
var Lfr = "";
var Ll = "";
var Lleftarrow = "";
var Lmidot = "";
var LongLeftArrow = "";
var LongLeftRightArrow = "";
var LongRightArrow = "";
var Longleftarrow = "";
var Longleftrightarrow = "";
var Longrightarrow = "";
var Lopf = "";
var LowerLeftArrow = "";
var LowerRightArrow = "";
var Lscr = "";
var Lsh = "";
var Lstrok = "";
var Lt = "";
var Mcy = "";
var MediumSpace = "";
var Mellintrf = "";
var Mfr = "";
var MinusPlus = "";
var Mopf = "";
var Mscr = "";
var Mu$1 = "";
var NJcy = "";
var Nacute = "";
var Ncaron = "";
var Ncedil = "";
var Ncy = "";
var NegativeMediumSpace = "";
var NegativeThickSpace = "";
var NegativeThinSpace = "";
var NegativeVeryThinSpace = "";
var NestedGreaterGreater = "";
var NestedLessLess = "";
var NewLine = "\n";
var Nfr = "";
var NoBreak = "";
var NonBreakingSpace = "";
var Nopf = "";
var Not = "";
var NotCongruent = "";
var NotCupCap = "";
var NotDoubleVerticalBar = "";
var NotElement = "";
var NotEqual = "";
var NotEqualTilde = "";
var NotExists = "";
var NotGreater = "";
var NotGreaterEqual = "";
var NotGreaterFullEqual = "";
var NotGreaterGreater = "";
var NotGreaterLess = "";
var NotGreaterSlantEqual = "";
var NotGreaterTilde = "";
var NotHumpDownHump = "";
var NotHumpEqual = "";
var NotLeftTriangle = "";
var NotLeftTriangleBar = "";
var NotLeftTriangleEqual = "";
var NotLess = "";
var NotLessEqual = "";
var NotLessGreater = "";
var NotLessLess = "";
var NotLessSlantEqual = "";
var NotLessTilde = "";
var NotNestedGreaterGreater = "";
var NotNestedLessLess = "";
var NotPrecedes = "";
var NotPrecedesEqual = "";
var NotPrecedesSlantEqual = "";
var NotReverseElement = "";
var NotRightTriangle = "";
var NotRightTriangleBar = "";
var NotRightTriangleEqual = "";
var NotSquareSubset = "";
var NotSquareSubsetEqual = "";
var NotSquareSuperset = "";
var NotSquareSupersetEqual = "";
var NotSubset = "";
var NotSubsetEqual = "";
var NotSucceeds = "";
var NotSucceedsEqual = "";
var NotSucceedsSlantEqual = "";
var NotSucceedsTilde = "";
var NotSuperset = "";
var NotSupersetEqual = "";
var NotTilde = "";
var NotTildeEqual = "";
var NotTildeFullEqual = "";
var NotTildeTilde = "";
var NotVerticalBar = "";
var Nscr = "";
var Ntild = "";
var Ntilde$1 = "";
var Nu$1 = "";
var OElig$1 = "";
var Oacut = "";
var Oacute$1 = "";
var Ocir = "";
var Ocirc$1 = "";
var Ocy = "";
var Odblac = "";
var Ofr = "";
var Ograv = "";
var Ograve$1 = "";
var Omacr = "";
var Omega$1 = "";
var Omicron$1 = "";
var Oopf = "";
var OpenCurlyDoubleQuote = "";
var OpenCurlyQuote = "";
var Or = "";
var Oscr = "";
var Oslas = "";
var Oslash$1 = "";
var Otild = "";
var Otilde$1 = "";
var Otimes = "";
var Oum = "";
var Ouml$1 = "";
var OverBar = "";
var OverBrace = "";
var OverBracket = "";
var OverParenthesis = "";
var PartialD = "";
var Pcy = "";
var Pfr = "";
var Phi$1 = "";
var Pi$1 = "";
var PlusMinus = "";
var Poincareplane = "";
var Popf = "";
var Pr = "";
var Precedes = "";
var PrecedesEqual = "";
var PrecedesSlantEqual = "";
var PrecedesTilde = "";
var Prime$1 = "";
var Product = "";
var Proportion = "";
var Proportional = "";
var Pscr = "";
var Psi$1 = "";
var QUO = '"';
var QUOT = '"';
var Qfr = "";
var Qopf = "";
var Qscr = "";
var RBarr = "";
var RE = "";
var REG = "";
var Racute = "";
var Rang = "";
var Rarr = "";
var Rarrtl = "";
var Rcaron = "";
var Rcedil = "";
var Rcy = "";
var Re = "";
var ReverseElement = "";
var ReverseEquilibrium = "";
var ReverseUpEquilibrium = "";
var Rfr = "";
var Rho$1 = "";
var RightAngleBracket = "";
var RightArrow = "";
var RightArrowBar = "";
var RightArrowLeftArrow = "";
var RightCeiling = "";
var RightDoubleBracket = "";
var RightDownTeeVector = "";
var RightDownVector = "";
var RightDownVectorBar = "";
var RightFloor = "";
var RightTee = "";
var RightTeeArrow = "";
var RightTeeVector = "";
var RightTriangle = "";
var RightTriangleBar = "";
var RightTriangleEqual = "";
var RightUpDownVector = "";
var RightUpTeeVector = "";
var RightUpVector = "";
var RightUpVectorBar = "";
var RightVector = "";
var RightVectorBar = "";
var Rightarrow = "";
var Ropf = "";
var RoundImplies = "";
var Rrightarrow = "";
var Rscr = "";
var Rsh = "";
var RuleDelayed = "";
var SHCHcy = "";
var SHcy = "";
var SOFTcy = "";
var Sacute = "";
var Sc = "";
var Scaron$1 = "";
var Scedil = "";
var Scirc = "";
var Scy = "";
var Sfr = "";
var ShortDownArrow = "";
var ShortLeftArrow = "";
var ShortRightArrow = "";
var ShortUpArrow = "";
var Sigma$1 = "";
var SmallCircle = "";
var Sopf = "";
var Sqrt = "";
var Square = "";
var SquareIntersection = "";
var SquareSubset = "";
var SquareSubsetEqual = "";
var SquareSuperset = "";
var SquareSupersetEqual = "";
var SquareUnion = "";
var Sscr = "";
var Star = "";
var Sub = "";
var Subset = "";
var SubsetEqual = "";
var Succeeds = "";
var SucceedsEqual = "";
var SucceedsSlantEqual = "";
var SucceedsTilde = "";
var SuchThat = "";
var Sum = "";
var Sup = "";
var Superset = "";
var SupersetEqual = "";
var Supset = "";
var THOR = "";
var THORN$1 = "";
var TRADE = "";
var TSHcy = "";
var TScy = "";
var Tab = "	";
var Tau$1 = "";
var Tcaron = "";
var Tcedil = "";
var Tcy = "";
var Tfr = "";
var Therefore = "";
var Theta$1 = "";
var ThickSpace = "";
var ThinSpace = "";
var Tilde = "";
var TildeEqual = "";
var TildeFullEqual = "";
var TildeTilde = "";
var Topf = "";
var TripleDot = "";
var Tscr = "";
var Tstrok = "";
var Uacut = "";
var Uacute$1 = "";
var Uarr = "";
var Uarrocir = "";
var Ubrcy = "";
var Ubreve = "";
var Ucir = "";
var Ucirc$1 = "";
var Ucy = "";
var Udblac = "";
var Ufr = "";
var Ugrav = "";
var Ugrave$1 = "";
var Umacr = "";
var UnderBar = "_";
var UnderBrace = "";
var UnderBracket = "";
var UnderParenthesis = "";
var Union = "";
var UnionPlus = "";
var Uogon = "";
var Uopf = "";
var UpArrow = "";
var UpArrowBar = "";
var UpArrowDownArrow = "";
var UpDownArrow = "";
var UpEquilibrium = "";
var UpTee = "";
var UpTeeArrow = "";
var Uparrow = "";
var Updownarrow = "";
var UpperLeftArrow = "";
var UpperRightArrow = "";
var Upsi = "";
var Upsilon$1 = "";
var Uring = "";
var Uscr = "";
var Utilde = "";
var Uum = "";
var Uuml$1 = "";
var VDash = "";
var Vbar = "";
var Vcy = "";
var Vdash = "";
var Vdashl = "";
var Vee = "";
var Verbar = "";
var Vert = "";
var VerticalBar = "";
var VerticalLine = "|";
var VerticalSeparator = "";
var VerticalTilde = "";
var VeryThinSpace = "";
var Vfr = "";
var Vopf = "";
var Vscr = "";
var Vvdash = "";
var Wcirc = "";
var Wedge = "";
var Wfr = "";
var Wopf = "";
var Wscr = "";
var Xfr = "";
var Xi$1 = "";
var Xopf = "";
var Xscr = "";
var YAcy = "";
var YIcy = "";
var YUcy = "";
var Yacut = "";
var Yacute$1 = "";
var Ycirc = "";
var Ycy = "";
var Yfr = "";
var Yopf = "";
var Yscr = "";
var Yuml$1 = "";
var ZHcy = "";
var Zacute = "";
var Zcaron = "";
var Zcy = "";
var Zdot = "";
var ZeroWidthSpace = "";
var Zeta$1 = "";
var Zfr = "";
var Zopf = "";
var Zscr = "";
var aacut = "";
var aacute$1 = "";
var abreve = "";
var ac = "";
var acE = "";
var acd = "";
var acir = "";
var acirc$1 = "";
var acut = "";
var acute$1 = "";
var acy = "";
var aeli = "";
var aelig$1 = "";
var af = "";
var afr = "";
var agrav = "";
var agrave$1 = "";
var alefsym$1 = "";
var aleph = "";
var alpha$1 = "";
var amacr = "";
var amalg = "";
var am = "&";
var amp$1 = "&";
var and$1 = "";
var andand = "";
var andd = "";
var andslope = "";
var andv = "";
var ang$1 = "";
var ange = "";
var angle = "";
var angmsd = "";
var angmsdaa = "";
var angmsdab = "";
var angmsdac = "";
var angmsdad = "";
var angmsdae = "";
var angmsdaf = "";
var angmsdag = "";
var angmsdah = "";
var angrt = "";
var angrtvb = "";
var angrtvbd = "";
var angsph = "";
var angst = "";
var angzarr = "";
var aogon = "";
var aopf = "";
var ap = "";
var apE = "";
var apacir = "";
var ape = "";
var apid = "";
var apos = "'";
var approx = "";
var approxeq = "";
var arin = "";
var aring$1 = "";
var ascr = "";
var ast = "*";
var asymp$1 = "";
var asympeq = "";
var atild = "";
var atilde$1 = "";
var aum = "";
var auml$1 = "";
var awconint = "";
var awint = "";
var bNot = "";
var backcong = "";
var backepsilon = "";
var backprime = "";
var backsim = "";
var backsimeq = "";
var barvee = "";
var barwed = "";
var barwedge = "";
var bbrk = "";
var bbrktbrk = "";
var bcong = "";
var bcy = "";
var bdquo$1 = "";
var becaus = "";
var because = "";
var bemptyv = "";
var bepsi = "";
var bernou = "";
var beta$1 = "";
var beth = "";
var between = "";
var bfr = "";
var bigcap = "";
var bigcirc = "";
var bigcup = "";
var bigodot = "";
var bigoplus = "";
var bigotimes = "";
var bigsqcup = "";
var bigstar = "";
var bigtriangledown = "";
var bigtriangleup = "";
var biguplus = "";
var bigvee = "";
var bigwedge = "";
var bkarow = "";
var blacklozenge = "";
var blacksquare = "";
var blacktriangle = "";
var blacktriangledown = "";
var blacktriangleleft = "";
var blacktriangleright = "";
var blank = "";
var blk12 = "";
var blk14 = "";
var blk34 = "";
var block2 = "";
var bne = "=";
var bnequiv = "";
var bnot = "";
var bopf = "";
var bot = "";
var bottom = "";
var bowtie = "";
var boxDL = "";
var boxDR = "";
var boxDl = "";
var boxDr = "";
var boxH = "";
var boxHD = "";
var boxHU = "";
var boxHd = "";
var boxHu = "";
var boxUL = "";
var boxUR = "";
var boxUl = "";
var boxUr = "";
var boxV = "";
var boxVH = "";
var boxVL = "";
var boxVR = "";
var boxVh = "";
var boxVl = "";
var boxVr = "";
var boxbox = "";
var boxdL = "";
var boxdR = "";
var boxdl = "";
var boxdr = "";
var boxh = "";
var boxhD = "";
var boxhU = "";
var boxhd = "";
var boxhu = "";
var boxminus = "";
var boxplus = "";
var boxtimes = "";
var boxuL = "";
var boxuR = "";
var boxul = "";
var boxur = "";
var boxv = "";
var boxvH = "";
var boxvL = "";
var boxvR = "";
var boxvh = "";
var boxvl = "";
var boxvr = "";
var bprime = "";
var breve = "";
var brvba = "";
var brvbar$1 = "";
var bscr = "";
var bsemi = "";
var bsim = "";
var bsime = "";
var bsol = "\\";
var bsolb = "";
var bsolhsub = "";
var bull$1 = "";
var bullet = "";
var bump = "";
var bumpE = "";
var bumpe = "";
var bumpeq = "";
var cacute = "";
var cap$2 = "";
var capand = "";
var capbrcup = "";
var capcap = "";
var capcup = "";
var capdot = "";
var caps = "";
var caret = "";
var caron = "";
var ccaps = "";
var ccaron = "";
var ccedi = "";
var ccedil$1 = "";
var ccirc = "";
var ccups = "";
var ccupssm = "";
var cdot = "";
var cedi = "";
var cedil$1 = "";
var cemptyv = "";
var cen = "";
var cent$1 = "";
var centerdot = "";
var cfr = "";
var chcy = "";
var check = "";
var checkmark = "";
var chi$1 = "";
var cir = "";
var cirE = "";
var circ$1 = "";
var circeq = "";
var circlearrowleft = "";
var circlearrowright = "";
var circledR = "";
var circledS = "";
var circledast = "";
var circledcirc = "";
var circleddash = "";
var cire = "";
var cirfnint = "";
var cirmid = "";
var cirscir = "";
var clubs$1 = "";
var clubsuit = "";
var colon = ":";
var colone = "";
var coloneq = "";
var comma$1 = ",";
var commat = "@";
var comp = "";
var compfn = "";
var complement = "";
var complexes = "";
var cong$1 = "";
var congdot = "";
var conint = "";
var copf = "";
var coprod = "";
var cop = "";
var copy$1 = "";
var copysr = "";
var crarr$1 = "";
var cross = "";
var cscr = "";
var csub = "";
var csube = "";
var csup = "";
var csupe = "";
var ctdot = "";
var cudarrl = "";
var cudarrr = "";
var cuepr = "";
var cuesc = "";
var cularr = "";
var cularrp = "";
var cup$1 = "";
var cupbrcap = "";
var cupcap = "";
var cupcup = "";
var cupdot = "";
var cupor = "";
var cups = "";
var curarr = "";
var curarrm = "";
var curlyeqprec = "";
var curlyeqsucc = "";
var curlyvee = "";
var curlywedge = "";
var curre = "";
var curren$1 = "";
var curvearrowleft = "";
var curvearrowright = "";
var cuvee = "";
var cuwed = "";
var cwconint = "";
var cwint = "";
var cylcty = "";
var dArr$1 = "";
var dHar = "";
var dagger$1 = "";
var daleth = "";
var darr$1 = "";
var dash$1 = "";
var dashv = "";
var dbkarow = "";
var dblac = "";
var dcaron = "";
var dcy = "";
var dd$1 = "";
var ddagger = "";
var ddarr = "";
var ddotseq = "";
var de = "";
var deg$1 = "";
var delta$1 = "";
var demptyv = "";
var dfisht = "";
var dfr = "";
var dharl = "";
var dharr = "";
var diam = "";
var diamond = "";
var diamondsuit = "";
var diams$1 = "";
var die = "";
var digamma = "";
var disin = "";
var div = "";
var divid = "";
var divide$1 = "";
var divideontimes = "";
var divonx = "";
var djcy = "";
var dlcorn = "";
var dlcrop = "";
var dollar = "$";
var dopf = "";
var dot = "";
var doteq = "";
var doteqdot = "";
var dotminus = "";
var dotplus = "";
var dotsquare = "";
var doublebarwedge = "";
var downarrow = "";
var downdownarrows = "";
var downharpoonleft = "";
var downharpoonright = "";
var drbkarow = "";
var drcorn = "";
var drcrop = "";
var dscr = "";
var dscy = "";
var dsol = "";
var dstrok = "";
var dtdot = "";
var dtri = "";
var dtrif = "";
var duarr = "";
var duhar = "";
var dwangle = "";
var dzcy = "";
var dzigrarr = "";
var eDDot = "";
var eDot = "";
var eacut = "";
var eacute$1 = "";
var easter = "";
var ecaron = "";
var ecir = "";
var ecirc$1 = "";
var ecolon = "";
var ecy = "";
var edot = "";
var ee = "";
var efDot = "";
var efr = "";
var eg = "";
var egrav = "";
var egrave$1 = "";
var egs = "";
var egsdot = "";
var el = "";
var elinters = "";
var ell = "";
var els = "";
var elsdot = "";
var emacr = "";
var empty$3 = "";
var emptyset = "";
var emptyv = "";
var emsp13 = "";
var emsp14 = "";
var emsp$1 = "";
var eng = "";
var ensp$1 = "";
var eogon = "";
var eopf = "";
var epar = "";
var eparsl = "";
var eplus = "";
var epsi = "";
var epsilon$1 = "";
var epsiv = "";
var eqcirc = "";
var eqcolon = "";
var eqsim = "";
var eqslantgtr = "";
var eqslantless = "";
var equals = "=";
var equest = "";
var equiv$1 = "";
var equivDD = "";
var eqvparsl = "";
var erDot = "";
var erarr = "";
var escr = "";
var esdot = "";
var esim = "";
var eta$1 = "";
var et = "";
var eth$1 = "";
var eum = "";
var euml$1 = "";
var euro$1 = "";
var excl = "!";
var exist$1 = "";
var expectation = "";
var exponentiale = "";
var fallingdotseq = "";
var fcy = "";
var female = "";
var ffilig = "";
var fflig = "";
var ffllig = "";
var ffr = "";
var filig = "";
var fjlig = "fj";
var flat = "";
var fllig = "";
var fltns = "";
var fnof$1 = "";
var fopf = "";
var forall$1 = "";
var fork = "";
var forkv = "";
var fpartint = "";
var frac1 = "";
var frac12$1 = "";
var frac13 = "";
var frac14$1 = "";
var frac15 = "";
var frac16 = "";
var frac18 = "";
var frac23 = "";
var frac25 = "";
var frac3 = "";
var frac34$1 = "";
var frac35 = "";
var frac38 = "";
var frac45 = "";
var frac56 = "";
var frac58 = "";
var frac78 = "";
var frasl$1 = "";
var frown = "";
var fscr = "";
var gE = "";
var gEl = "";
var gacute = "";
var gamma$1 = "";
var gammad = "";
var gap = "";
var gbreve = "";
var gcirc = "";
var gcy = "";
var gdot = "";
var ge$1 = "";
var gel = "";
var geq = "";
var geqq = "";
var geqslant = "";
var ges = "";
var gescc = "";
var gesdot = "";
var gesdoto = "";
var gesdotol = "";
var gesl = "";
var gesles = "";
var gfr = "";
var gg = "";
var ggg = "";
var gimel = "";
var gjcy = "";
var gl = "";
var glE = "";
var gla = "";
var glj = "";
var gnE = "";
var gnap = "";
var gnapprox = "";
var gne = "";
var gneq = "";
var gneqq = "";
var gnsim = "";
var gopf = "";
var grave = "`";
var gscr = "";
var gsim = "";
var gsime = "";
var gsiml = "";
var g = ">";
var gt$1 = ">";
var gtcc = "";
var gtcir = "";
var gtdot = "";
var gtlPar = "";
var gtquest = "";
var gtrapprox = "";
var gtrarr = "";
var gtrdot = "";
var gtreqless = "";
var gtreqqless = "";
var gtrless = "";
var gtrsim = "";
var gvertneqq = "";
var gvnE = "";
var hArr$1 = "";
var hairsp = "";
var half = "";
var hamilt = "";
var hardcy = "";
var harr$1 = "";
var harrcir = "";
var harrw = "";
var hbar = "";
var hcirc = "";
var hearts$1 = "";
var heartsuit = "";
var hellip$1 = "";
var hercon = "";
var hfr = "";
var hksearow = "";
var hkswarow = "";
var hoarr = "";
var homtht = "";
var hookleftarrow = "";
var hookrightarrow = "";
var hopf = "";
var horbar = "";
var hscr = "";
var hslash = "";
var hstrok = "";
var hybull = "";
var hyphen = "";
var iacut = "";
var iacute$1 = "";
var ic = "";
var icir = "";
var icirc$1 = "";
var icy = "";
var iecy = "";
var iexc = "";
var iexcl$1 = "";
var iff = "";
var ifr = "";
var igrav = "";
var igrave$1 = "";
var ii = "";
var iiiint = "";
var iiint = "";
var iinfin = "";
var iiota = "";
var ijlig = "";
var imacr = "";
var image$2 = "";
var imagline = "";
var imagpart = "";
var imath = "";
var imof = "";
var imped = "";
var incare = "";
var infin$1 = "";
var infintie = "";
var inodot = "";
var int$2 = "";
var intcal = "";
var integers = "";
var intercal = "";
var intlarhk = "";
var intprod = "";
var iocy = "";
var iogon = "";
var iopf = "";
var iota$1 = "";
var iprod = "";
var iques = "";
var iquest$1 = "";
var iscr = "";
var isin$1 = "";
var isinE = "";
var isindot = "";
var isins = "";
var isinsv = "";
var isinv = "";
var it = "";
var itilde = "";
var iukcy = "";
var ium = "";
var iuml$1 = "";
var jcirc = "";
var jcy = "";
var jfr = "";
var jmath = "";
var jopf = "";
var jscr = "";
var jsercy = "";
var jukcy = "";
var kappa$1 = "";
var kappav = "";
var kcedil = "";
var kcy = "";
var kfr = "";
var kgreen = "";
var khcy = "";
var kjcy = "";
var kopf = "";
var kscr = "";
var lAarr = "";
var lArr$1 = "";
var lAtail = "";
var lBarr = "";
var lE = "";
var lEg = "";
var lHar = "";
var lacute = "";
var laemptyv = "";
var lagran = "";
var lambda$1 = "";
var lang$1 = "";
var langd = "";
var langle = "";
var lap = "";
var laqu = "";
var laquo$1 = "";
var larr$1 = "";
var larrb = "";
var larrbfs = "";
var larrfs = "";
var larrhk = "";
var larrlp = "";
var larrpl = "";
var larrsim = "";
var larrtl = "";
var lat = "";
var latail = "";
var late = "";
var lates = "";
var lbarr = "";
var lbbrk = "";
var lbrace = "{";
var lbrack = "[";
var lbrke = "";
var lbrksld = "";
var lbrkslu = "";
var lcaron = "";
var lcedil = "";
var lceil$1 = "";
var lcub = "{";
var lcy = "";
var ldca = "";
var ldquo$1 = "";
var ldquor = "";
var ldrdhar = "";
var ldrushar = "";
var ldsh = "";
var le$1 = "";
var leftarrow = "";
var leftarrowtail = "";
var leftharpoondown = "";
var leftharpoonup = "";
var leftleftarrows = "";
var leftrightarrow = "";
var leftrightarrows = "";
var leftrightharpoons = "";
var leftrightsquigarrow = "";
var leftthreetimes = "";
var leg = "";
var leq = "";
var leqq = "";
var leqslant = "";
var les = "";
var lescc = "";
var lesdot = "";
var lesdoto = "";
var lesdotor = "";
var lesg = "";
var lesges = "";
var lessapprox = "";
var lessdot = "";
var lesseqgtr = "";
var lesseqqgtr = "";
var lessgtr = "";
var lesssim = "";
var lfisht = "";
var lfloor$1 = "";
var lfr = "";
var lg = "";
var lgE = "";
var lhard = "";
var lharu = "";
var lharul = "";
var lhblk = "";
var ljcy = "";
var ll = "";
var llarr = "";
var llcorner = "";
var llhard = "";
var lltri = "";
var lmidot = "";
var lmoust = "";
var lmoustache = "";
var lnE = "";
var lnap = "";
var lnapprox = "";
var lne = "";
var lneq = "";
var lneqq = "";
var lnsim = "";
var loang = "";
var loarr = "";
var lobrk = "";
var longleftarrow = "";
var longleftrightarrow = "";
var longmapsto = "";
var longrightarrow = "";
var looparrowleft = "";
var looparrowright = "";
var lopar = "";
var lopf = "";
var loplus = "";
var lotimes = "";
var lowast$1 = "";
var lowbar = "_";
var loz$1 = "";
var lozenge = "";
var lozf = "";
var lpar = "(";
var lparlt = "";
var lrarr = "";
var lrcorner = "";
var lrhar = "";
var lrhard = "";
var lrm$1 = "";
var lrtri = "";
var lsaquo$1 = "";
var lscr = "";
var lsh = "";
var lsim = "";
var lsime = "";
var lsimg = "";
var lsqb = "[";
var lsquo$1 = "";
var lsquor = "";
var lstrok = "";
var l = "<";
var lt$1 = "<";
var ltcc = "";
var ltcir = "";
var ltdot = "";
var lthree = "";
var ltimes = "";
var ltlarr = "";
var ltquest = "";
var ltrPar = "";
var ltri = "";
var ltrie = "";
var ltrif = "";
var lurdshar = "";
var luruhar = "";
var lvertneqq = "";
var lvnE = "";
var mDDot = "";
var mac = "";
var macr$1 = "";
var male = "";
var malt = "";
var maltese = "";
var map$1 = "";
var mapsto = "";
var mapstodown = "";
var mapstoleft = "";
var mapstoup = "";
var marker = "";
var mcomma = "";
var mcy = "";
var mdash$1 = "";
var measuredangle = "";
var mfr = "";
var mho = "";
var micr = "";
var micro$1 = "";
var mid = "";
var midast = "*";
var midcir = "";
var middo = "";
var middot$1 = "";
var minus$1 = "";
var minusb = "";
var minusd = "";
var minusdu = "";
var mlcp = "";
var mldr = "";
var mnplus = "";
var models = "";
var mopf = "";
var mp = "";
var mscr = "";
var mstpos = "";
var mu$1 = "";
var multimap = "";
var mumap = "";
var nGg = "";
var nGt = "";
var nGtv = "";
var nLeftarrow = "";
var nLeftrightarrow = "";
var nLl = "";
var nLt = "";
var nLtv = "";
var nRightarrow = "";
var nVDash = "";
var nVdash = "";
var nabla$1 = "";
var nacute = "";
var nang = "";
var nap = "";
var napE = "";
var napid = "";
var napos = "";
var napprox = "";
var natur = "";
var natural = "";
var naturals = "";
var nbs = "";
var nbsp$1 = "";
var nbump = "";
var nbumpe = "";
var ncap = "";
var ncaron = "";
var ncedil = "";
var ncong = "";
var ncongdot = "";
var ncup = "";
var ncy = "";
var ndash$1 = "";
var ne$1 = "";
var neArr = "";
var nearhk = "";
var nearr = "";
var nearrow = "";
var nedot = "";
var nequiv = "";
var nesear = "";
var nesim = "";
var nexist = "";
var nexists = "";
var nfr = "";
var ngE = "";
var nge = "";
var ngeq = "";
var ngeqq = "";
var ngeqslant = "";
var nges = "";
var ngsim = "";
var ngt = "";
var ngtr = "";
var nhArr = "";
var nharr = "";
var nhpar = "";
var ni$1 = "";
var nis = "";
var nisd = "";
var niv = "";
var njcy = "";
var nlArr = "";
var nlE = "";
var nlarr = "";
var nldr = "";
var nle = "";
var nleftarrow = "";
var nleftrightarrow = "";
var nleq = "";
var nleqq = "";
var nleqslant = "";
var nles = "";
var nless = "";
var nlsim = "";
var nlt = "";
var nltri = "";
var nltrie = "";
var nmid = "";
var nopf = "";
var no = "";
var not$1 = "";
var notin$1 = "";
var notinE = "";
var notindot = "";
var notinva = "";
var notinvb = "";
var notinvc = "";
var notni = "";
var notniva = "";
var notnivb = "";
var notnivc = "";
var npar = "";
var nparallel = "";
var nparsl = "";
var npart = "";
var npolint = "";
var npr = "";
var nprcue = "";
var npre = "";
var nprec = "";
var npreceq = "";
var nrArr = "";
var nrarr = "";
var nrarrc = "";
var nrarrw = "";
var nrightarrow = "";
var nrtri = "";
var nrtrie = "";
var nsc = "";
var nsccue = "";
var nsce = "";
var nscr = "";
var nshortmid = "";
var nshortparallel = "";
var nsim = "";
var nsime = "";
var nsimeq = "";
var nsmid = "";
var nspar = "";
var nsqsube = "";
var nsqsupe = "";
var nsub$1 = "";
var nsubE = "";
var nsube = "";
var nsubset = "";
var nsubseteq = "";
var nsubseteqq = "";
var nsucc = "";
var nsucceq = "";
var nsup = "";
var nsupE = "";
var nsupe = "";
var nsupset = "";
var nsupseteq = "";
var nsupseteqq = "";
var ntgl = "";
var ntild = "";
var ntilde$1 = "";
var ntlg = "";
var ntriangleleft = "";
var ntrianglelefteq = "";
var ntriangleright = "";
var ntrianglerighteq = "";
var nu$1 = "";
var num = "#";
var numero = "";
var numsp = "";
var nvDash = "";
var nvHarr = "";
var nvap = "";
var nvdash = "";
var nvge = "";
var nvgt = ">";
var nvinfin = "";
var nvlArr = "";
var nvle = "";
var nvlt = "<";
var nvltrie = "";
var nvrArr = "";
var nvrtrie = "";
var nvsim = "";
var nwArr = "";
var nwarhk = "";
var nwarr = "";
var nwarrow = "";
var nwnear = "";
var oS = "";
var oacut = "";
var oacute$1 = "";
var oast = "";
var ocir = "";
var ocirc$1 = "";
var ocy = "";
var odash = "";
var odblac = "";
var odiv = "";
var odot = "";
var odsold = "";
var oelig$1 = "";
var ofcir = "";
var ofr = "";
var ogon = "";
var ograv = "";
var ograve$1 = "";
var ogt = "";
var ohbar = "";
var ohm = "";
var oint = "";
var olarr = "";
var olcir = "";
var olcross = "";
var oline$1 = "";
var olt = "";
var omacr = "";
var omega$1 = "";
var omicron$1 = "";
var omid = "";
var ominus = "";
var oopf = "";
var opar = "";
var operp = "";
var oplus$1 = "";
var or$1 = "";
var orarr = "";
var ord = "";
var order = "";
var orderof = "";
var ordf$1 = "";
var ordm$1 = "";
var origof = "";
var oror = "";
var orslope = "";
var orv = "";
var oscr = "";
var oslas = "";
var oslash$1 = "";
var osol = "";
var otild = "";
var otilde$1 = "";
var otimes$1 = "";
var otimesas = "";
var oum = "";
var ouml$1 = "";
var ovbar = "";
var par = "";
var para$1 = "";
var parallel = "";
var parsim = "";
var parsl = "";
var part$1 = "";
var pcy = "";
var percnt = "%";
var period = ".";
var permil$1 = "";
var perp$1 = "";
var pertenk = "";
var pfr = "";
var phi$1 = "";
var phiv = "";
var phmmat = "";
var phone = "";
var pi$1 = "";
var pitchfork = "";
var piv$1 = "";
var planck = "";
var planckh = "";
var plankv = "";
var plus = "+";
var plusacir = "";
var plusb = "";
var pluscir = "";
var plusdo = "";
var plusdu = "";
var pluse = "";
var plusm = "";
var plusmn$1 = "";
var plussim = "";
var plustwo = "";
var pm = "";
var pointint = "";
var popf = "";
var poun = "";
var pound$1 = "";
var pr = "";
var prE = "";
var prap = "";
var prcue = "";
var pre = "";
var prec = "";
var precapprox = "";
var preccurlyeq = "";
var preceq = "";
var precnapprox = "";
var precneqq = "";
var precnsim = "";
var precsim = "";
var prime$1 = "";
var primes = "";
var prnE = "";
var prnap = "";
var prnsim = "";
var prod$1 = "";
var profalar = "";
var profline = "";
var profsurf = "";
var prop$1 = "";
var propto = "";
var prsim = "";
var prurel = "";
var pscr = "";
var psi$1 = "";
var puncsp = "";
var qfr = "";
var qint = "";
var qopf = "";
var qprime = "";
var qscr = "";
var quaternions = "";
var quatint = "";
var quest = "?";
var questeq = "";
var quo = '"';
var quot$1 = '"';
var rAarr = "";
var rArr$1 = "";
var rAtail = "";
var rBarr = "";
var rHar = "";
var race = "";
var racute = "";
var radic$1 = "";
var raemptyv = "";
var rang$1 = "";
var rangd = "";
var range = "";
var rangle = "";
var raqu = "";
var raquo$1 = "";
var rarr$1 = "";
var rarrap = "";
var rarrb = "";
var rarrbfs = "";
var rarrc = "";
var rarrfs = "";
var rarrhk = "";
var rarrlp = "";
var rarrpl = "";
var rarrsim = "";
var rarrtl = "";
var rarrw = "";
var ratail = "";
var ratio = "";
var rationals = "";
var rbarr = "";
var rbbrk = "";
var rbrace = "}";
var rbrack = "]";
var rbrke = "";
var rbrksld = "";
var rbrkslu = "";
var rcaron = "";
var rcedil = "";
var rceil$1 = "";
var rcub = "}";
var rcy = "";
var rdca = "";
var rdldhar = "";
var rdquo$1 = "";
var rdquor = "";
var rdsh = "";
var real$1 = "";
var realine = "";
var realpart = "";
var reals = "";
var rect = "";
var re$1 = "";
var reg$1 = "";
var rfisht = "";
var rfloor$1 = "";
var rfr = "";
var rhard = "";
var rharu = "";
var rharul = "";
var rho$1 = "";
var rhov = "";
var rightarrow = "";
var rightarrowtail = "";
var rightharpoondown = "";
var rightharpoonup = "";
var rightleftarrows = "";
var rightleftharpoons = "";
var rightrightarrows = "";
var rightsquigarrow = "";
var rightthreetimes = "";
var ring = "";
var risingdotseq = "";
var rlarr = "";
var rlhar = "";
var rlm$1 = "";
var rmoust = "";
var rmoustache = "";
var rnmid = "";
var roang = "";
var roarr = "";
var robrk = "";
var ropar = "";
var ropf = "";
var roplus = "";
var rotimes = "";
var rpar = ")";
var rpargt = "";
var rppolint = "";
var rrarr = "";
var rsaquo$1 = "";
var rscr = "";
var rsh = "";
var rsqb = "]";
var rsquo$1 = "";
var rsquor = "";
var rthree = "";
var rtimes = "";
var rtri = "";
var rtrie = "";
var rtrif = "";
var rtriltri = "";
var ruluhar = "";
var rx = "";
var sacute = "";
var sbquo$1 = "";
var sc = "";
var scE = "";
var scap = "";
var scaron$1 = "";
var sccue = "";
var sce = "";
var scedil = "";
var scirc = "";
var scnE = "";
var scnap = "";
var scnsim = "";
var scpolint = "";
var scsim = "";
var scy = "";
var sdot$1 = "";
var sdotb = "";
var sdote = "";
var seArr = "";
var searhk = "";
var searr = "";
var searrow = "";
var sec = "";
var sect$1 = "";
var semi = ";";
var seswar = "";
var setminus = "";
var setmn = "";
var sext = "";
var sfr = "";
var sfrown = "";
var sharp = "";
var shchcy = "";
var shcy = "";
var shortmid = "";
var shortparallel = "";
var sh = "";
var shy$1 = "";
var sigma$1 = "";
var sigmaf$1 = "";
var sigmav = "";
var sim$1 = "";
var simdot = "";
var sime = "";
var simeq = "";
var simg = "";
var simgE = "";
var siml = "";
var simlE = "";
var simne = "";
var simplus = "";
var simrarr = "";
var slarr = "";
var smallsetminus = "";
var smashp = "";
var smeparsl = "";
var smid = "";
var smile = "";
var smt = "";
var smte = "";
var smtes = "";
var softcy = "";
var sol = "/";
var solb = "";
var solbar = "";
var sopf = "";
var spades$1 = "";
var spadesuit = "";
var spar = "";
var sqcap = "";
var sqcaps = "";
var sqcup = "";
var sqcups = "";
var sqsub = "";
var sqsube = "";
var sqsubset = "";
var sqsubseteq = "";
var sqsup = "";
var sqsupe = "";
var sqsupset = "";
var sqsupseteq = "";
var squ = "";
var square = "";
var squarf = "";
var squf = "";
var srarr = "";
var sscr = "";
var ssetmn = "";
var ssmile = "";
var sstarf = "";
var star = "";
var starf = "";
var straightepsilon = "";
var straightphi = "";
var strns = "";
var sub$1 = "";
var subE = "";
var subdot = "";
var sube$1 = "";
var subedot = "";
var submult = "";
var subnE = "";
var subne = "";
var subplus = "";
var subrarr = "";
var subset = "";
var subseteq = "";
var subseteqq = "";
var subsetneq = "";
var subsetneqq = "";
var subsim = "";
var subsub = "";
var subsup = "";
var succ = "";
var succapprox = "";
var succcurlyeq = "";
var succeq = "";
var succnapprox = "";
var succneqq = "";
var succnsim = "";
var succsim = "";
var sum$1 = "";
var sung = "";
var sup$1 = "";
var sup1$1 = "";
var sup2$1 = "";
var sup3$1 = "";
var supE = "";
var supdot = "";
var supdsub = "";
var supe$1 = "";
var supedot = "";
var suphsol = "";
var suphsub = "";
var suplarr = "";
var supmult = "";
var supnE = "";
var supne = "";
var supplus = "";
var supset = "";
var supseteq = "";
var supseteqq = "";
var supsetneq = "";
var supsetneqq = "";
var supsim = "";
var supsub = "";
var supsup = "";
var swArr = "";
var swarhk = "";
var swarr = "";
var swarrow = "";
var swnwar = "";
var szli = "";
var szlig$1 = "";
var target = "";
var tau$1 = "";
var tbrk = "";
var tcaron = "";
var tcedil = "";
var tcy = "";
var tdot = "";
var telrec = "";
var tfr = "";
var there4$1 = "";
var therefore = "";
var theta$1 = "";
var thetasym$1 = "";
var thetav = "";
var thickapprox = "";
var thicksim = "";
var thinsp$1 = "";
var thkap = "";
var thksim = "";
var thor = "";
var thorn$1 = "";
var tilde$1 = "";
var time = "";
var times$1 = "";
var timesb = "";
var timesbar = "";
var timesd = "";
var tint = "";
var toea = "";
var top = "";
var topbot = "";
var topcir = "";
var topf = "";
var topfork = "";
var tosa = "";
var tprime = "";
var trade$1 = "";
var triangle = "";
var triangledown = "";
var triangleleft = "";
var trianglelefteq = "";
var triangleq = "";
var triangleright = "";
var trianglerighteq = "";
var tridot = "";
var trie = "";
var triminus = "";
var triplus = "";
var trisb = "";
var tritime = "";
var trpezium = "";
var tscr = "";
var tscy = "";
var tshcy = "";
var tstrok = "";
var twixt = "";
var twoheadleftarrow = "";
var twoheadrightarrow = "";
var uArr$1 = "";
var uHar = "";
var uacut = "";
var uacute$1 = "";
var uarr$1 = "";
var ubrcy = "";
var ubreve = "";
var ucir = "";
var ucirc$1 = "";
var ucy = "";
var udarr = "";
var udblac = "";
var udhar = "";
var ufisht = "";
var ufr = "";
var ugrav = "";
var ugrave$1 = "";
var uharl = "";
var uharr = "";
var uhblk = "";
var ulcorn = "";
var ulcorner = "";
var ulcrop = "";
var ultri = "";
var umacr = "";
var um = "";
var uml$1 = "";
var uogon = "";
var uopf = "";
var uparrow = "";
var updownarrow = "";
var upharpoonleft = "";
var upharpoonright = "";
var uplus = "";
var upsi = "";
var upsih$1 = "";
var upsilon$1 = "";
var upuparrows = "";
var urcorn = "";
var urcorner = "";
var urcrop = "";
var uring = "";
var urtri = "";
var uscr = "";
var utdot = "";
var utilde = "";
var utri = "";
var utrif = "";
var uuarr = "";
var uum = "";
var uuml$1 = "";
var uwangle = "";
var vArr = "";
var vBar = "";
var vBarv = "";
var vDash = "";
var vangrt = "";
var varepsilon = "";
var varkappa = "";
var varnothing = "";
var varphi = "";
var varpi = "";
var varpropto = "";
var varr = "";
var varrho = "";
var varsigma = "";
var varsubsetneq = "";
var varsubsetneqq = "";
var varsupsetneq = "";
var varsupsetneqq = "";
var vartheta = "";
var vartriangleleft = "";
var vartriangleright = "";
var vcy = "";
var vdash = "";
var vee = "";
var veebar = "";
var veeeq = "";
var vellip = "";
var verbar = "|";
var vert = "|";
var vfr = "";
var vltri = "";
var vnsub = "";
var vnsup = "";
var vopf = "";
var vprop = "";
var vrtri = "";
var vscr = "";
var vsubnE = "";
var vsubne = "";
var vsupnE = "";
var vsupne = "";
var vzigzag = "";
var wcirc = "";
var wedbar = "";
var wedge = "";
var wedgeq = "";
var weierp$1 = "";
var wfr = "";
var wopf = "";
var wp = "";
var wr = "";
var wreath = "";
var wscr = "";
var xcap = "";
var xcirc = "";
var xcup = "";
var xdtri = "";
var xfr = "";
var xhArr = "";
var xharr = "";
var xi$1 = "";
var xlArr = "";
var xlarr = "";
var xmap = "";
var xnis = "";
var xodot = "";
var xopf = "";
var xoplus = "";
var xotime = "";
var xrArr = "";
var xrarr = "";
var xscr = "";
var xsqcup = "";
var xuplus = "";
var xutri = "";
var xvee = "";
var xwedge = "";
var yacut = "";
var yacute$1 = "";
var yacy = "";
var ycirc = "";
var ycy = "";
var ye = "";
var yen$1 = "";
var yfr = "";
var yicy = "";
var yopf = "";
var yscr = "";
var yucy = "";
var yum = "";
var yuml$1 = "";
var zacute = "";
var zcaron = "";
var zcy = "";
var zdot = "";
var zeetrf = "";
var zeta$1 = "";
var zfr = "";
var zhcy = "";
var zigrarr = "";
var zopf = "";
var zscr = "";
var zwj$1 = "";
var zwnj$1 = "";
var require$$0$1 = {
  AEli,
  AElig: AElig$1,
  AM,
  AMP: AMP$1,
  Aacut,
  Aacute: Aacute$1,
  Abreve,
  Acir,
  Acirc: Acirc$1,
  Acy,
  Afr,
  Agrav,
  Agrave: Agrave$1,
  Alpha: Alpha$1,
  Amacr,
  And,
  Aogon,
  Aopf,
  ApplyFunction,
  Arin,
  Aring: Aring$1,
  Ascr,
  Assign,
  Atild,
  Atilde: Atilde$1,
  Aum,
  Auml: Auml$1,
  Backslash,
  Barv,
  Barwed,
  Bcy,
  Because,
  Bernoullis,
  Beta: Beta$1,
  Bfr,
  Bopf,
  Breve,
  Bscr,
  Bumpeq,
  CHcy,
  COP,
  COPY,
  Cacute,
  Cap,
  CapitalDifferentialD,
  Cayleys,
  Ccaron,
  Ccedi,
  Ccedil: Ccedil$1,
  Ccirc,
  Cconint,
  Cdot,
  Cedilla,
  CenterDot,
  Cfr,
  Chi: Chi$1,
  CircleDot,
  CircleMinus,
  CirclePlus,
  CircleTimes,
  ClockwiseContourIntegral,
  CloseCurlyDoubleQuote,
  CloseCurlyQuote,
  Colon,
  Colone,
  Congruent,
  Conint,
  ContourIntegral,
  Copf,
  Coproduct,
  CounterClockwiseContourIntegral,
  Cross,
  Cscr,
  Cup,
  CupCap,
  DD,
  DDotrahd,
  DJcy,
  DScy,
  DZcy,
  Dagger: Dagger$1,
  Darr,
  Dashv,
  Dcaron,
  Dcy,
  Del,
  Delta: Delta$1,
  Dfr,
  DiacriticalAcute,
  DiacriticalDot,
  DiacriticalDoubleAcute,
  DiacriticalGrave,
  DiacriticalTilde,
  Diamond,
  DifferentialD,
  Dopf,
  Dot,
  DotDot,
  DotEqual,
  DoubleContourIntegral,
  DoubleDot,
  DoubleDownArrow,
  DoubleLeftArrow,
  DoubleLeftRightArrow,
  DoubleLeftTee,
  DoubleLongLeftArrow,
  DoubleLongLeftRightArrow,
  DoubleLongRightArrow,
  DoubleRightArrow,
  DoubleRightTee,
  DoubleUpArrow,
  DoubleUpDownArrow,
  DoubleVerticalBar,
  DownArrow,
  DownArrowBar,
  DownArrowUpArrow,
  DownBreve,
  DownLeftRightVector,
  DownLeftTeeVector,
  DownLeftVector,
  DownLeftVectorBar,
  DownRightTeeVector,
  DownRightVector,
  DownRightVectorBar,
  DownTee,
  DownTeeArrow,
  Downarrow,
  Dscr,
  Dstrok,
  ENG,
  ET,
  ETH: ETH$1,
  Eacut,
  Eacute: Eacute$1,
  Ecaron,
  Ecir,
  Ecirc: Ecirc$1,
  Ecy,
  Edot,
  Efr,
  Egrav,
  Egrave: Egrave$1,
  Element,
  Emacr,
  EmptySmallSquare,
  EmptyVerySmallSquare,
  Eogon,
  Eopf,
  Epsilon: Epsilon$1,
  Equal,
  EqualTilde,
  Equilibrium,
  Escr,
  Esim,
  Eta: Eta$1,
  Eum,
  Euml: Euml$1,
  Exists,
  ExponentialE,
  Fcy,
  Ffr,
  FilledSmallSquare,
  FilledVerySmallSquare,
  Fopf,
  ForAll,
  Fouriertrf,
  Fscr,
  GJcy,
  G,
  GT: GT$1,
  Gamma: Gamma$1,
  Gammad,
  Gbreve,
  Gcedil,
  Gcirc,
  Gcy,
  Gdot,
  Gfr,
  Gg,
  Gopf,
  GreaterEqual,
  GreaterEqualLess,
  GreaterFullEqual,
  GreaterGreater,
  GreaterLess,
  GreaterSlantEqual,
  GreaterTilde,
  Gscr,
  Gt,
  HARDcy,
  Hacek,
  Hat,
  Hcirc,
  Hfr,
  HilbertSpace,
  Hopf,
  HorizontalLine,
  Hscr,
  Hstrok,
  HumpDownHump,
  HumpEqual,
  IEcy,
  IJlig,
  IOcy,
  Iacut,
  Iacute: Iacute$1,
  Icir,
  Icirc: Icirc$1,
  Icy,
  Idot,
  Ifr,
  Igrav,
  Igrave: Igrave$1,
  Im,
  Imacr,
  ImaginaryI,
  Implies,
  Int,
  Integral,
  Intersection,
  InvisibleComma,
  InvisibleTimes,
  Iogon,
  Iopf,
  Iota: Iota$1,
  Iscr,
  Itilde,
  Iukcy,
  Ium,
  Iuml: Iuml$1,
  Jcirc,
  Jcy,
  Jfr,
  Jopf,
  Jscr,
  Jsercy,
  Jukcy,
  KHcy,
  KJcy,
  Kappa: Kappa$1,
  Kcedil,
  Kcy,
  Kfr,
  Kopf,
  Kscr,
  LJcy,
  L,
  LT: LT$1,
  Lacute,
  Lambda: Lambda$1,
  Lang,
  Laplacetrf,
  Larr,
  Lcaron,
  Lcedil,
  Lcy,
  LeftAngleBracket,
  LeftArrow,
  LeftArrowBar,
  LeftArrowRightArrow,
  LeftCeiling,
  LeftDoubleBracket,
  LeftDownTeeVector,
  LeftDownVector,
  LeftDownVectorBar,
  LeftFloor,
  LeftRightArrow,
  LeftRightVector,
  LeftTee,
  LeftTeeArrow,
  LeftTeeVector,
  LeftTriangle,
  LeftTriangleBar,
  LeftTriangleEqual,
  LeftUpDownVector,
  LeftUpTeeVector,
  LeftUpVector,
  LeftUpVectorBar,
  LeftVector,
  LeftVectorBar,
  Leftarrow,
  Leftrightarrow,
  LessEqualGreater,
  LessFullEqual,
  LessGreater,
  LessLess,
  LessSlantEqual,
  LessTilde,
  Lfr,
  Ll,
  Lleftarrow,
  Lmidot,
  LongLeftArrow,
  LongLeftRightArrow,
  LongRightArrow,
  Longleftarrow,
  Longleftrightarrow,
  Longrightarrow,
  Lopf,
  LowerLeftArrow,
  LowerRightArrow,
  Lscr,
  Lsh,
  Lstrok,
  Lt,
  "Map": "",
  Mcy,
  MediumSpace,
  Mellintrf,
  Mfr,
  MinusPlus,
  Mopf,
  Mscr,
  Mu: Mu$1,
  NJcy,
  Nacute,
  Ncaron,
  Ncedil,
  Ncy,
  NegativeMediumSpace,
  NegativeThickSpace,
  NegativeThinSpace,
  NegativeVeryThinSpace,
  NestedGreaterGreater,
  NestedLessLess,
  NewLine,
  Nfr,
  NoBreak,
  NonBreakingSpace,
  Nopf,
  Not,
  NotCongruent,
  NotCupCap,
  NotDoubleVerticalBar,
  NotElement,
  NotEqual,
  NotEqualTilde,
  NotExists,
  NotGreater,
  NotGreaterEqual,
  NotGreaterFullEqual,
  NotGreaterGreater,
  NotGreaterLess,
  NotGreaterSlantEqual,
  NotGreaterTilde,
  NotHumpDownHump,
  NotHumpEqual,
  NotLeftTriangle,
  NotLeftTriangleBar,
  NotLeftTriangleEqual,
  NotLess,
  NotLessEqual,
  NotLessGreater,
  NotLessLess,
  NotLessSlantEqual,
  NotLessTilde,
  NotNestedGreaterGreater,
  NotNestedLessLess,
  NotPrecedes,
  NotPrecedesEqual,
  NotPrecedesSlantEqual,
  NotReverseElement,
  NotRightTriangle,
  NotRightTriangleBar,
  NotRightTriangleEqual,
  NotSquareSubset,
  NotSquareSubsetEqual,
  NotSquareSuperset,
  NotSquareSupersetEqual,
  NotSubset,
  NotSubsetEqual,
  NotSucceeds,
  NotSucceedsEqual,
  NotSucceedsSlantEqual,
  NotSucceedsTilde,
  NotSuperset,
  NotSupersetEqual,
  NotTilde,
  NotTildeEqual,
  NotTildeFullEqual,
  NotTildeTilde,
  NotVerticalBar,
  Nscr,
  Ntild,
  Ntilde: Ntilde$1,
  Nu: Nu$1,
  OElig: OElig$1,
  Oacut,
  Oacute: Oacute$1,
  Ocir,
  Ocirc: Ocirc$1,
  Ocy,
  Odblac,
  Ofr,
  Ograv,
  Ograve: Ograve$1,
  Omacr,
  Omega: Omega$1,
  Omicron: Omicron$1,
  Oopf,
  OpenCurlyDoubleQuote,
  OpenCurlyQuote,
  Or,
  Oscr,
  Oslas,
  Oslash: Oslash$1,
  Otild,
  Otilde: Otilde$1,
  Otimes,
  Oum,
  Ouml: Ouml$1,
  OverBar,
  OverBrace,
  OverBracket,
  OverParenthesis,
  PartialD,
  Pcy,
  Pfr,
  Phi: Phi$1,
  Pi: Pi$1,
  PlusMinus,
  Poincareplane,
  Popf,
  Pr,
  Precedes,
  PrecedesEqual,
  PrecedesSlantEqual,
  PrecedesTilde,
  Prime: Prime$1,
  Product,
  Proportion,
  Proportional,
  Pscr,
  Psi: Psi$1,
  QUO,
  QUOT,
  Qfr,
  Qopf,
  Qscr,
  RBarr,
  RE,
  REG,
  Racute,
  Rang,
  Rarr,
  Rarrtl,
  Rcaron,
  Rcedil,
  Rcy,
  Re,
  ReverseElement,
  ReverseEquilibrium,
  ReverseUpEquilibrium,
  Rfr,
  Rho: Rho$1,
  RightAngleBracket,
  RightArrow,
  RightArrowBar,
  RightArrowLeftArrow,
  RightCeiling,
  RightDoubleBracket,
  RightDownTeeVector,
  RightDownVector,
  RightDownVectorBar,
  RightFloor,
  RightTee,
  RightTeeArrow,
  RightTeeVector,
  RightTriangle,
  RightTriangleBar,
  RightTriangleEqual,
  RightUpDownVector,
  RightUpTeeVector,
  RightUpVector,
  RightUpVectorBar,
  RightVector,
  RightVectorBar,
  Rightarrow,
  Ropf,
  RoundImplies,
  Rrightarrow,
  Rscr,
  Rsh,
  RuleDelayed,
  SHCHcy,
  SHcy,
  SOFTcy,
  Sacute,
  Sc,
  Scaron: Scaron$1,
  Scedil,
  Scirc,
  Scy,
  Sfr,
  ShortDownArrow,
  ShortLeftArrow,
  ShortRightArrow,
  ShortUpArrow,
  Sigma: Sigma$1,
  SmallCircle,
  Sopf,
  Sqrt,
  Square,
  SquareIntersection,
  SquareSubset,
  SquareSubsetEqual,
  SquareSuperset,
  SquareSupersetEqual,
  SquareUnion,
  Sscr,
  Star,
  Sub,
  Subset,
  SubsetEqual,
  Succeeds,
  SucceedsEqual,
  SucceedsSlantEqual,
  SucceedsTilde,
  SuchThat,
  Sum,
  Sup,
  Superset,
  SupersetEqual,
  Supset,
  THOR,
  THORN: THORN$1,
  TRADE,
  TSHcy,
  TScy,
  Tab,
  Tau: Tau$1,
  Tcaron,
  Tcedil,
  Tcy,
  Tfr,
  Therefore,
  Theta: Theta$1,
  ThickSpace,
  ThinSpace,
  Tilde,
  TildeEqual,
  TildeFullEqual,
  TildeTilde,
  Topf,
  TripleDot,
  Tscr,
  Tstrok,
  Uacut,
  Uacute: Uacute$1,
  Uarr,
  Uarrocir,
  Ubrcy,
  Ubreve,
  Ucir,
  Ucirc: Ucirc$1,
  Ucy,
  Udblac,
  Ufr,
  Ugrav,
  Ugrave: Ugrave$1,
  Umacr,
  UnderBar,
  UnderBrace,
  UnderBracket,
  UnderParenthesis,
  Union,
  UnionPlus,
  Uogon,
  Uopf,
  UpArrow,
  UpArrowBar,
  UpArrowDownArrow,
  UpDownArrow,
  UpEquilibrium,
  UpTee,
  UpTeeArrow,
  Uparrow,
  Updownarrow,
  UpperLeftArrow,
  UpperRightArrow,
  Upsi,
  Upsilon: Upsilon$1,
  Uring,
  Uscr,
  Utilde,
  Uum,
  Uuml: Uuml$1,
  VDash,
  Vbar,
  Vcy,
  Vdash,
  Vdashl,
  Vee,
  Verbar,
  Vert,
  VerticalBar,
  VerticalLine,
  VerticalSeparator,
  VerticalTilde,
  VeryThinSpace,
  Vfr,
  Vopf,
  Vscr,
  Vvdash,
  Wcirc,
  Wedge,
  Wfr,
  Wopf,
  Wscr,
  Xfr,
  Xi: Xi$1,
  Xopf,
  Xscr,
  YAcy,
  YIcy,
  YUcy,
  Yacut,
  Yacute: Yacute$1,
  Ycirc,
  Ycy,
  Yfr,
  Yopf,
  Yscr,
  Yuml: Yuml$1,
  ZHcy,
  Zacute,
  Zcaron,
  Zcy,
  Zdot,
  ZeroWidthSpace,
  Zeta: Zeta$1,
  Zfr,
  Zopf,
  Zscr,
  aacut,
  aacute: aacute$1,
  abreve,
  ac,
  acE,
  acd,
  acir,
  acirc: acirc$1,
  acut,
  acute: acute$1,
  acy,
  aeli,
  aelig: aelig$1,
  af,
  afr,
  agrav,
  agrave: agrave$1,
  alefsym: alefsym$1,
  aleph,
  alpha: alpha$1,
  amacr,
  amalg,
  am,
  amp: amp$1,
  and: and$1,
  andand,
  andd,
  andslope,
  andv,
  ang: ang$1,
  ange,
  angle,
  angmsd,
  angmsdaa,
  angmsdab,
  angmsdac,
  angmsdad,
  angmsdae,
  angmsdaf,
  angmsdag,
  angmsdah,
  angrt,
  angrtvb,
  angrtvbd,
  angsph,
  angst,
  angzarr,
  aogon,
  aopf,
  ap,
  apE,
  apacir,
  ape,
  apid,
  apos,
  approx,
  approxeq,
  arin,
  aring: aring$1,
  ascr,
  ast,
  asymp: asymp$1,
  asympeq,
  atild,
  atilde: atilde$1,
  aum,
  auml: auml$1,
  awconint,
  awint,
  bNot,
  backcong,
  backepsilon,
  backprime,
  backsim,
  backsimeq,
  barvee,
  barwed,
  barwedge,
  bbrk,
  bbrktbrk,
  bcong,
  bcy,
  bdquo: bdquo$1,
  becaus,
  because,
  bemptyv,
  bepsi,
  bernou,
  beta: beta$1,
  beth,
  between,
  bfr,
  bigcap,
  bigcirc,
  bigcup,
  bigodot,
  bigoplus,
  bigotimes,
  bigsqcup,
  bigstar,
  bigtriangledown,
  bigtriangleup,
  biguplus,
  bigvee,
  bigwedge,
  bkarow,
  blacklozenge,
  blacksquare,
  blacktriangle,
  blacktriangledown,
  blacktriangleleft,
  blacktriangleright,
  blank,
  blk12,
  blk14,
  blk34,
  block: block2,
  bne,
  bnequiv,
  bnot,
  bopf,
  bot,
  bottom,
  bowtie,
  boxDL,
  boxDR,
  boxDl,
  boxDr,
  boxH,
  boxHD,
  boxHU,
  boxHd,
  boxHu,
  boxUL,
  boxUR,
  boxUl,
  boxUr,
  boxV,
  boxVH,
  boxVL,
  boxVR,
  boxVh,
  boxVl,
  boxVr,
  boxbox,
  boxdL,
  boxdR,
  boxdl,
  boxdr,
  boxh,
  boxhD,
  boxhU,
  boxhd,
  boxhu,
  boxminus,
  boxplus,
  boxtimes,
  boxuL,
  boxuR,
  boxul,
  boxur,
  boxv,
  boxvH,
  boxvL,
  boxvR,
  boxvh,
  boxvl,
  boxvr,
  bprime,
  breve,
  brvba,
  brvbar: brvbar$1,
  bscr,
  bsemi,
  bsim,
  bsime,
  bsol,
  bsolb,
  bsolhsub,
  bull: bull$1,
  bullet,
  bump,
  bumpE,
  bumpe,
  bumpeq,
  cacute,
  cap: cap$2,
  capand,
  capbrcup,
  capcap,
  capcup,
  capdot,
  caps,
  caret,
  caron,
  ccaps,
  ccaron,
  ccedi,
  ccedil: ccedil$1,
  ccirc,
  ccups,
  ccupssm,
  cdot,
  cedi,
  cedil: cedil$1,
  cemptyv,
  cen,
  cent: cent$1,
  centerdot,
  cfr,
  chcy,
  check,
  checkmark,
  chi: chi$1,
  cir,
  cirE,
  circ: circ$1,
  circeq,
  circlearrowleft,
  circlearrowright,
  circledR,
  circledS,
  circledast,
  circledcirc,
  circleddash,
  cire,
  cirfnint,
  cirmid,
  cirscir,
  clubs: clubs$1,
  clubsuit,
  colon,
  colone,
  coloneq,
  comma: comma$1,
  commat,
  comp,
  compfn,
  complement,
  complexes,
  cong: cong$1,
  congdot,
  conint,
  copf,
  coprod,
  cop,
  copy: copy$1,
  copysr,
  crarr: crarr$1,
  cross,
  cscr,
  csub,
  csube,
  csup,
  csupe,
  ctdot,
  cudarrl,
  cudarrr,
  cuepr,
  cuesc,
  cularr,
  cularrp,
  cup: cup$1,
  cupbrcap,
  cupcap,
  cupcup,
  cupdot,
  cupor,
  cups,
  curarr,
  curarrm,
  curlyeqprec,
  curlyeqsucc,
  curlyvee,
  curlywedge,
  curre,
  curren: curren$1,
  curvearrowleft,
  curvearrowright,
  cuvee,
  cuwed,
  cwconint,
  cwint,
  cylcty,
  dArr: dArr$1,
  dHar,
  dagger: dagger$1,
  daleth,
  darr: darr$1,
  dash: dash$1,
  dashv,
  dbkarow,
  dblac,
  dcaron,
  dcy,
  dd: dd$1,
  ddagger,
  ddarr,
  ddotseq,
  de,
  deg: deg$1,
  delta: delta$1,
  demptyv,
  dfisht,
  dfr,
  dharl,
  dharr,
  diam,
  diamond,
  diamondsuit,
  diams: diams$1,
  die,
  digamma,
  disin,
  div,
  divid,
  divide: divide$1,
  divideontimes,
  divonx,
  djcy,
  dlcorn,
  dlcrop,
  dollar,
  dopf,
  dot,
  doteq,
  doteqdot,
  dotminus,
  dotplus,
  dotsquare,
  doublebarwedge,
  downarrow,
  downdownarrows,
  downharpoonleft,
  downharpoonright,
  drbkarow,
  drcorn,
  drcrop,
  dscr,
  dscy,
  dsol,
  dstrok,
  dtdot,
  dtri,
  dtrif,
  duarr,
  duhar,
  dwangle,
  dzcy,
  dzigrarr,
  eDDot,
  eDot,
  eacut,
  eacute: eacute$1,
  easter,
  ecaron,
  ecir,
  ecirc: ecirc$1,
  ecolon,
  ecy,
  edot,
  ee,
  efDot,
  efr,
  eg,
  egrav,
  egrave: egrave$1,
  egs,
  egsdot,
  el,
  elinters,
  ell,
  els,
  elsdot,
  emacr,
  empty: empty$3,
  emptyset,
  emptyv,
  emsp13,
  emsp14,
  emsp: emsp$1,
  eng,
  ensp: ensp$1,
  eogon,
  eopf,
  epar,
  eparsl,
  eplus,
  epsi,
  epsilon: epsilon$1,
  epsiv,
  eqcirc,
  eqcolon,
  eqsim,
  eqslantgtr,
  eqslantless,
  equals,
  equest,
  equiv: equiv$1,
  equivDD,
  eqvparsl,
  erDot,
  erarr,
  escr,
  esdot,
  esim,
  eta: eta$1,
  et,
  eth: eth$1,
  eum,
  euml: euml$1,
  euro: euro$1,
  excl,
  exist: exist$1,
  expectation,
  exponentiale,
  fallingdotseq,
  fcy,
  female,
  ffilig,
  fflig,
  ffllig,
  ffr,
  filig,
  fjlig,
  flat,
  fllig,
  fltns,
  fnof: fnof$1,
  fopf,
  forall: forall$1,
  fork,
  forkv,
  fpartint,
  frac1,
  frac12: frac12$1,
  frac13,
  frac14: frac14$1,
  frac15,
  frac16,
  frac18,
  frac23,
  frac25,
  frac3,
  frac34: frac34$1,
  frac35,
  frac38,
  frac45,
  frac56,
  frac58,
  frac78,
  frasl: frasl$1,
  frown,
  fscr,
  gE,
  gEl,
  gacute,
  gamma: gamma$1,
  gammad,
  gap,
  gbreve,
  gcirc,
  gcy,
  gdot,
  ge: ge$1,
  gel,
  geq,
  geqq,
  geqslant,
  ges,
  gescc,
  gesdot,
  gesdoto,
  gesdotol,
  gesl,
  gesles,
  gfr,
  gg,
  ggg,
  gimel,
  gjcy,
  gl,
  glE,
  gla,
  glj,
  gnE,
  gnap,
  gnapprox,
  gne,
  gneq,
  gneqq,
  gnsim,
  gopf,
  grave,
  gscr,
  gsim,
  gsime,
  gsiml,
  g,
  gt: gt$1,
  gtcc,
  gtcir,
  gtdot,
  gtlPar,
  gtquest,
  gtrapprox,
  gtrarr,
  gtrdot,
  gtreqless,
  gtreqqless,
  gtrless,
  gtrsim,
  gvertneqq,
  gvnE,
  hArr: hArr$1,
  hairsp,
  half,
  hamilt,
  hardcy,
  harr: harr$1,
  harrcir,
  harrw,
  hbar,
  hcirc,
  hearts: hearts$1,
  heartsuit,
  hellip: hellip$1,
  hercon,
  hfr,
  hksearow,
  hkswarow,
  hoarr,
  homtht,
  hookleftarrow,
  hookrightarrow,
  hopf,
  horbar,
  hscr,
  hslash,
  hstrok,
  hybull,
  hyphen,
  iacut,
  iacute: iacute$1,
  ic,
  icir,
  icirc: icirc$1,
  icy,
  iecy,
  iexc,
  iexcl: iexcl$1,
  iff,
  ifr,
  igrav,
  igrave: igrave$1,
  ii,
  iiiint,
  iiint,
  iinfin,
  iiota,
  ijlig,
  imacr,
  image: image$2,
  imagline,
  imagpart,
  imath,
  imof,
  imped,
  "in": "",
  incare,
  infin: infin$1,
  infintie,
  inodot,
  int: int$2,
  intcal,
  integers,
  intercal,
  intlarhk,
  intprod,
  iocy,
  iogon,
  iopf,
  iota: iota$1,
  iprod,
  iques,
  iquest: iquest$1,
  iscr,
  isin: isin$1,
  isinE,
  isindot,
  isins,
  isinsv,
  isinv,
  it,
  itilde,
  iukcy,
  ium,
  iuml: iuml$1,
  jcirc,
  jcy,
  jfr,
  jmath,
  jopf,
  jscr,
  jsercy,
  jukcy,
  kappa: kappa$1,
  kappav,
  kcedil,
  kcy,
  kfr,
  kgreen,
  khcy,
  kjcy,
  kopf,
  kscr,
  lAarr,
  lArr: lArr$1,
  lAtail,
  lBarr,
  lE,
  lEg,
  lHar,
  lacute,
  laemptyv,
  lagran,
  lambda: lambda$1,
  lang: lang$1,
  langd,
  langle,
  lap,
  laqu,
  laquo: laquo$1,
  larr: larr$1,
  larrb,
  larrbfs,
  larrfs,
  larrhk,
  larrlp,
  larrpl,
  larrsim,
  larrtl,
  lat,
  latail,
  late,
  lates,
  lbarr,
  lbbrk,
  lbrace,
  lbrack,
  lbrke,
  lbrksld,
  lbrkslu,
  lcaron,
  lcedil,
  lceil: lceil$1,
  lcub,
  lcy,
  ldca,
  ldquo: ldquo$1,
  ldquor,
  ldrdhar,
  ldrushar,
  ldsh,
  le: le$1,
  leftarrow,
  leftarrowtail,
  leftharpoondown,
  leftharpoonup,
  leftleftarrows,
  leftrightarrow,
  leftrightarrows,
  leftrightharpoons,
  leftrightsquigarrow,
  leftthreetimes,
  leg,
  leq,
  leqq,
  leqslant,
  les,
  lescc,
  lesdot,
  lesdoto,
  lesdotor,
  lesg,
  lesges,
  lessapprox,
  lessdot,
  lesseqgtr,
  lesseqqgtr,
  lessgtr,
  lesssim,
  lfisht,
  lfloor: lfloor$1,
  lfr,
  lg,
  lgE,
  lhard,
  lharu,
  lharul,
  lhblk,
  ljcy,
  ll,
  llarr,
  llcorner,
  llhard,
  lltri,
  lmidot,
  lmoust,
  lmoustache,
  lnE,
  lnap,
  lnapprox,
  lne,
  lneq,
  lneqq,
  lnsim,
  loang,
  loarr,
  lobrk,
  longleftarrow,
  longleftrightarrow,
  longmapsto,
  longrightarrow,
  looparrowleft,
  looparrowright,
  lopar,
  lopf,
  loplus,
  lotimes,
  lowast: lowast$1,
  lowbar,
  loz: loz$1,
  lozenge,
  lozf,
  lpar,
  lparlt,
  lrarr,
  lrcorner,
  lrhar,
  lrhard,
  lrm: lrm$1,
  lrtri,
  lsaquo: lsaquo$1,
  lscr,
  lsh,
  lsim,
  lsime,
  lsimg,
  lsqb,
  lsquo: lsquo$1,
  lsquor,
  lstrok,
  l,
  lt: lt$1,
  ltcc,
  ltcir,
  ltdot,
  lthree,
  ltimes,
  ltlarr,
  ltquest,
  ltrPar,
  ltri,
  ltrie,
  ltrif,
  lurdshar,
  luruhar,
  lvertneqq,
  lvnE,
  mDDot,
  mac,
  macr: macr$1,
  male,
  malt,
  maltese,
  map: map$1,
  mapsto,
  mapstodown,
  mapstoleft,
  mapstoup,
  marker,
  mcomma,
  mcy,
  mdash: mdash$1,
  measuredangle,
  mfr,
  mho,
  micr,
  micro: micro$1,
  mid,
  midast,
  midcir,
  middo,
  middot: middot$1,
  minus: minus$1,
  minusb,
  minusd,
  minusdu,
  mlcp,
  mldr,
  mnplus,
  models,
  mopf,
  mp,
  mscr,
  mstpos,
  mu: mu$1,
  multimap,
  mumap,
  nGg,
  nGt,
  nGtv,
  nLeftarrow,
  nLeftrightarrow,
  nLl,
  nLt,
  nLtv,
  nRightarrow,
  nVDash,
  nVdash,
  nabla: nabla$1,
  nacute,
  nang,
  nap,
  napE,
  napid,
  napos,
  napprox,
  natur,
  natural,
  naturals,
  nbs,
  nbsp: nbsp$1,
  nbump,
  nbumpe,
  ncap,
  ncaron,
  ncedil,
  ncong,
  ncongdot,
  ncup,
  ncy,
  ndash: ndash$1,
  ne: ne$1,
  neArr,
  nearhk,
  nearr,
  nearrow,
  nedot,
  nequiv,
  nesear,
  nesim,
  nexist,
  nexists,
  nfr,
  ngE,
  nge,
  ngeq,
  ngeqq,
  ngeqslant,
  nges,
  ngsim,
  ngt,
  ngtr,
  nhArr,
  nharr,
  nhpar,
  ni: ni$1,
  nis,
  nisd,
  niv,
  njcy,
  nlArr,
  nlE,
  nlarr,
  nldr,
  nle,
  nleftarrow,
  nleftrightarrow,
  nleq,
  nleqq,
  nleqslant,
  nles,
  nless,
  nlsim,
  nlt,
  nltri,
  nltrie,
  nmid,
  nopf,
  no,
  not: not$1,
  notin: notin$1,
  notinE,
  notindot,
  notinva,
  notinvb,
  notinvc,
  notni,
  notniva,
  notnivb,
  notnivc,
  npar,
  nparallel,
  nparsl,
  npart,
  npolint,
  npr,
  nprcue,
  npre,
  nprec,
  npreceq,
  nrArr,
  nrarr,
  nrarrc,
  nrarrw,
  nrightarrow,
  nrtri,
  nrtrie,
  nsc,
  nsccue,
  nsce,
  nscr,
  nshortmid,
  nshortparallel,
  nsim,
  nsime,
  nsimeq,
  nsmid,
  nspar,
  nsqsube,
  nsqsupe,
  nsub: nsub$1,
  nsubE,
  nsube,
  nsubset,
  nsubseteq,
  nsubseteqq,
  nsucc,
  nsucceq,
  nsup,
  nsupE,
  nsupe,
  nsupset,
  nsupseteq,
  nsupseteqq,
  ntgl,
  ntild,
  ntilde: ntilde$1,
  ntlg,
  ntriangleleft,
  ntrianglelefteq,
  ntriangleright,
  ntrianglerighteq,
  nu: nu$1,
  num,
  numero,
  numsp,
  nvDash,
  nvHarr,
  nvap,
  nvdash,
  nvge,
  nvgt,
  nvinfin,
  nvlArr,
  nvle,
  nvlt,
  nvltrie,
  nvrArr,
  nvrtrie,
  nvsim,
  nwArr,
  nwarhk,
  nwarr,
  nwarrow,
  nwnear,
  oS,
  oacut,
  oacute: oacute$1,
  oast,
  ocir,
  ocirc: ocirc$1,
  ocy,
  odash,
  odblac,
  odiv,
  odot,
  odsold,
  oelig: oelig$1,
  ofcir,
  ofr,
  ogon,
  ograv,
  ograve: ograve$1,
  ogt,
  ohbar,
  ohm,
  oint,
  olarr,
  olcir,
  olcross,
  oline: oline$1,
  olt,
  omacr,
  omega: omega$1,
  omicron: omicron$1,
  omid,
  ominus,
  oopf,
  opar,
  operp,
  oplus: oplus$1,
  or: or$1,
  orarr,
  ord,
  order,
  orderof,
  ordf: ordf$1,
  ordm: ordm$1,
  origof,
  oror,
  orslope,
  orv,
  oscr,
  oslas,
  oslash: oslash$1,
  osol,
  otild,
  otilde: otilde$1,
  otimes: otimes$1,
  otimesas,
  oum,
  ouml: ouml$1,
  ovbar,
  par,
  para: para$1,
  parallel,
  parsim,
  parsl,
  part: part$1,
  pcy,
  percnt,
  period,
  permil: permil$1,
  perp: perp$1,
  pertenk,
  pfr,
  phi: phi$1,
  phiv,
  phmmat,
  phone,
  pi: pi$1,
  pitchfork,
  piv: piv$1,
  planck,
  planckh,
  plankv,
  plus,
  plusacir,
  plusb,
  pluscir,
  plusdo,
  plusdu,
  pluse,
  plusm,
  plusmn: plusmn$1,
  plussim,
  plustwo,
  pm,
  pointint,
  popf,
  poun,
  pound: pound$1,
  pr,
  prE,
  prap,
  prcue,
  pre,
  prec,
  precapprox,
  preccurlyeq,
  preceq,
  precnapprox,
  precneqq,
  precnsim,
  precsim,
  prime: prime$1,
  primes,
  prnE,
  prnap,
  prnsim,
  prod: prod$1,
  profalar,
  profline,
  profsurf,
  prop: prop$1,
  propto,
  prsim,
  prurel,
  pscr,
  psi: psi$1,
  puncsp,
  qfr,
  qint,
  qopf,
  qprime,
  qscr,
  quaternions,
  quatint,
  quest,
  questeq,
  quo,
  quot: quot$1,
  rAarr,
  rArr: rArr$1,
  rAtail,
  rBarr,
  rHar,
  race,
  racute,
  radic: radic$1,
  raemptyv,
  rang: rang$1,
  rangd,
  range,
  rangle,
  raqu,
  raquo: raquo$1,
  rarr: rarr$1,
  rarrap,
  rarrb,
  rarrbfs,
  rarrc,
  rarrfs,
  rarrhk,
  rarrlp,
  rarrpl,
  rarrsim,
  rarrtl,
  rarrw,
  ratail,
  ratio,
  rationals,
  rbarr,
  rbbrk,
  rbrace,
  rbrack,
  rbrke,
  rbrksld,
  rbrkslu,
  rcaron,
  rcedil,
  rceil: rceil$1,
  rcub,
  rcy,
  rdca,
  rdldhar,
  rdquo: rdquo$1,
  rdquor,
  rdsh,
  real: real$1,
  realine,
  realpart,
  reals,
  rect,
  re: re$1,
  reg: reg$1,
  rfisht,
  rfloor: rfloor$1,
  rfr,
  rhard,
  rharu,
  rharul,
  rho: rho$1,
  rhov,
  rightarrow,
  rightarrowtail,
  rightharpoondown,
  rightharpoonup,
  rightleftarrows,
  rightleftharpoons,
  rightrightarrows,
  rightsquigarrow,
  rightthreetimes,
  ring,
  risingdotseq,
  rlarr,
  rlhar,
  rlm: rlm$1,
  rmoust,
  rmoustache,
  rnmid,
  roang,
  roarr,
  robrk,
  ropar,
  ropf,
  roplus,
  rotimes,
  rpar,
  rpargt,
  rppolint,
  rrarr,
  rsaquo: rsaquo$1,
  rscr,
  rsh,
  rsqb,
  rsquo: rsquo$1,
  rsquor,
  rthree,
  rtimes,
  rtri,
  rtrie,
  rtrif,
  rtriltri,
  ruluhar,
  rx,
  sacute,
  sbquo: sbquo$1,
  sc,
  scE,
  scap,
  scaron: scaron$1,
  sccue,
  sce,
  scedil,
  scirc,
  scnE,
  scnap,
  scnsim,
  scpolint,
  scsim,
  scy,
  sdot: sdot$1,
  sdotb,
  sdote,
  seArr,
  searhk,
  searr,
  searrow,
  sec,
  sect: sect$1,
  semi,
  seswar,
  setminus,
  setmn,
  sext,
  sfr,
  sfrown,
  sharp,
  shchcy,
  shcy,
  shortmid,
  shortparallel,
  sh,
  shy: shy$1,
  sigma: sigma$1,
  sigmaf: sigmaf$1,
  sigmav,
  sim: sim$1,
  simdot,
  sime,
  simeq,
  simg,
  simgE,
  siml,
  simlE,
  simne,
  simplus,
  simrarr,
  slarr,
  smallsetminus,
  smashp,
  smeparsl,
  smid,
  smile,
  smt,
  smte,
  smtes,
  softcy,
  sol,
  solb,
  solbar,
  sopf,
  spades: spades$1,
  spadesuit,
  spar,
  sqcap,
  sqcaps,
  sqcup,
  sqcups,
  sqsub,
  sqsube,
  sqsubset,
  sqsubseteq,
  sqsup,
  sqsupe,
  sqsupset,
  sqsupseteq,
  squ,
  square,
  squarf,
  squf,
  srarr,
  sscr,
  ssetmn,
  ssmile,
  sstarf,
  star,
  starf,
  straightepsilon,
  straightphi,
  strns,
  sub: sub$1,
  subE,
  subdot,
  sube: sube$1,
  subedot,
  submult,
  subnE,
  subne,
  subplus,
  subrarr,
  subset,
  subseteq,
  subseteqq,
  subsetneq,
  subsetneqq,
  subsim,
  subsub,
  subsup,
  succ,
  succapprox,
  succcurlyeq,
  succeq,
  succnapprox,
  succneqq,
  succnsim,
  succsim,
  sum: sum$1,
  sung,
  sup: sup$1,
  sup1: sup1$1,
  sup2: sup2$1,
  sup3: sup3$1,
  supE,
  supdot,
  supdsub,
  supe: supe$1,
  supedot,
  suphsol,
  suphsub,
  suplarr,
  supmult,
  supnE,
  supne,
  supplus,
  supset,
  supseteq,
  supseteqq,
  supsetneq,
  supsetneqq,
  supsim,
  supsub,
  supsup,
  swArr,
  swarhk,
  swarr,
  swarrow,
  swnwar,
  szli,
  szlig: szlig$1,
  target,
  tau: tau$1,
  tbrk,
  tcaron,
  tcedil,
  tcy,
  tdot,
  telrec,
  tfr,
  there4: there4$1,
  therefore,
  theta: theta$1,
  thetasym: thetasym$1,
  thetav,
  thickapprox,
  thicksim,
  thinsp: thinsp$1,
  thkap,
  thksim,
  thor,
  thorn: thorn$1,
  tilde: tilde$1,
  time,
  times: times$1,
  timesb,
  timesbar,
  timesd,
  tint,
  toea,
  top,
  topbot,
  topcir,
  topf,
  topfork,
  tosa,
  tprime,
  trade: trade$1,
  triangle,
  triangledown,
  triangleleft,
  trianglelefteq,
  triangleq,
  triangleright,
  trianglerighteq,
  tridot,
  trie,
  triminus,
  triplus,
  trisb,
  tritime,
  trpezium,
  tscr,
  tscy,
  tshcy,
  tstrok,
  twixt,
  twoheadleftarrow,
  twoheadrightarrow,
  uArr: uArr$1,
  uHar,
  uacut,
  uacute: uacute$1,
  uarr: uarr$1,
  ubrcy,
  ubreve,
  ucir,
  ucirc: ucirc$1,
  ucy,
  udarr,
  udblac,
  udhar,
  ufisht,
  ufr,
  ugrav,
  ugrave: ugrave$1,
  uharl,
  uharr,
  uhblk,
  ulcorn,
  ulcorner,
  ulcrop,
  ultri,
  umacr,
  um,
  uml: uml$1,
  uogon,
  uopf,
  uparrow,
  updownarrow,
  upharpoonleft,
  upharpoonright,
  uplus,
  upsi,
  upsih: upsih$1,
  upsilon: upsilon$1,
  upuparrows,
  urcorn,
  urcorner,
  urcrop,
  uring,
  urtri,
  uscr,
  utdot,
  utilde,
  utri,
  utrif,
  uuarr,
  uum,
  uuml: uuml$1,
  uwangle,
  vArr,
  vBar,
  vBarv,
  vDash,
  vangrt,
  varepsilon,
  varkappa,
  varnothing,
  varphi,
  varpi,
  varpropto,
  varr,
  varrho,
  varsigma,
  varsubsetneq,
  varsubsetneqq,
  varsupsetneq,
  varsupsetneqq,
  vartheta,
  vartriangleleft,
  vartriangleright,
  vcy,
  vdash,
  vee,
  veebar,
  veeeq,
  vellip,
  verbar,
  vert,
  vfr,
  vltri,
  vnsub,
  vnsup,
  vopf,
  vprop,
  vrtri,
  vscr,
  vsubnE,
  vsubne,
  vsupnE,
  vsupne,
  vzigzag,
  wcirc,
  wedbar,
  wedge,
  wedgeq,
  weierp: weierp$1,
  wfr,
  wopf,
  wp,
  wr,
  wreath,
  wscr,
  xcap,
  xcirc,
  xcup,
  xdtri,
  xfr,
  xhArr,
  xharr,
  xi: xi$1,
  xlArr,
  xlarr,
  xmap,
  xnis,
  xodot,
  xopf,
  xoplus,
  xotime,
  xrArr,
  xrarr,
  xscr,
  xsqcup,
  xuplus,
  xutri,
  xvee,
  xwedge,
  yacut,
  yacute: yacute$1,
  yacy,
  ycirc,
  ycy,
  ye,
  yen: yen$1,
  yfr,
  yicy,
  yopf,
  yscr,
  yucy,
  yum,
  yuml: yuml$1,
  zacute,
  zcaron,
  zcy,
  zdot,
  zeetrf,
  zeta: zeta$1,
  zfr,
  zhcy,
  zigrarr,
  zopf,
  zscr,
  zwj: zwj$1,
  zwnj: zwnj$1
};
var characterEntities = require$$0$1;
var decodeEntity_1 = decodeEntity$1;
var own$9 = {}.hasOwnProperty;
function decodeEntity$1(characters2) {
  return own$9.call(characterEntities, characters2) ? characterEntities[characters2] : false;
}
var legacy$1 = require$$1$2;
var invalid = require$$1$1;
var decimal$1 = requireIsDecimal();
var hexadecimal$1 = isHexadecimal;
var alphanumerical$1 = isAlphanumerical;
var decodeEntity = decodeEntity_1;
var parseEntities_1 = parseEntities;
var own$8 = {}.hasOwnProperty;
var fromCharCode = String.fromCharCode;
var noop = Function.prototype;
var defaults$2 = {
  warning: null,
  reference: null,
  text: null,
  warningContext: null,
  referenceContext: null,
  textContext: null,
  position: {},
  additional: null,
  attribute: false,
  nonTerminated: true
};
var tab$1 = 9;
var lineFeed$1 = 10;
var formFeed = 12;
var space$3 = 32;
var ampersand = 38;
var semicolon2 = 59;
var lessThan$1 = 60;
var equalsTo = 61;
var numberSign = 35;
var uppercaseX = 88;
var lowercaseX = 120;
var replacementCharacter = 65533;
var name$1 = "named";
var hexa = "hexadecimal";
var deci = "decimal";
var bases = {};
bases[hexa] = 16;
bases[deci] = 10;
var tests = {};
tests[name$1] = alphanumerical$1;
tests[deci] = decimal$1;
tests[hexa] = hexadecimal$1;
var namedNotTerminated = 1;
var numericNotTerminated = 2;
var namedEmpty = 3;
var numericEmpty = 4;
var namedUnknown = 5;
var numericDisallowed = 6;
var numericProhibited = 7;
var messages = {};
messages[namedNotTerminated] = "Named character references must be terminated by a semicolon";
messages[numericNotTerminated] = "Numeric character references must be terminated by a semicolon";
messages[namedEmpty] = "Named character references cannot be empty";
messages[numericEmpty] = "Numeric character references cannot be empty";
messages[namedUnknown] = "Named character references must be known";
messages[numericDisallowed] = "Numeric character references cannot be disallowed";
messages[numericProhibited] = "Numeric character references cannot be outside the permissible Unicode range";
function parseEntities(value, options2) {
  var settings = {};
  var option2;
  var key2;
  if (!options2) {
    options2 = {};
  }
  for (key2 in defaults$2) {
    option2 = options2[key2];
    settings[key2] = option2 === null || option2 === void 0 ? defaults$2[key2] : option2;
  }
  if (settings.position.indent || settings.position.start) {
    settings.indent = settings.position.indent || [];
    settings.position = settings.position.start;
  }
  return parse$6(value, settings);
}
function parse$6(value, settings) {
  var additional = settings.additional;
  var nonTerminated = settings.nonTerminated;
  var handleText = settings.text;
  var handleReference = settings.reference;
  var handleWarning = settings.warning;
  var textContext = settings.textContext;
  var referenceContext = settings.referenceContext;
  var warningContext = settings.warningContext;
  var pos = settings.position;
  var indent2 = settings.indent || [];
  var length = value.length;
  var index2 = 0;
  var lines = -1;
  var column = pos.column || 1;
  var line = pos.line || 1;
  var queue = "";
  var result = [];
  var entityCharacters;
  var namedEntity;
  var terminated;
  var characters2;
  var character;
  var reference;
  var following;
  var warning;
  var reason;
  var output;
  var entity;
  var begin;
  var start2;
  var type2;
  var test;
  var prev;
  var next2;
  var diff;
  var end2;
  if (typeof additional === "string") {
    additional = additional.charCodeAt(0);
  }
  prev = now();
  warning = handleWarning ? parseError : noop;
  index2--;
  length++;
  while (++index2 < length) {
    if (character === lineFeed$1) {
      column = indent2[lines] || 1;
    }
    character = value.charCodeAt(index2);
    if (character === ampersand) {
      following = value.charCodeAt(index2 + 1);
      if (following === tab$1 || following === lineFeed$1 || following === formFeed || following === space$3 || following === ampersand || following === lessThan$1 || following !== following || additional && following === additional) {
        queue += fromCharCode(character);
        column++;
        continue;
      }
      start2 = index2 + 1;
      begin = start2;
      end2 = start2;
      if (following === numberSign) {
        end2 = ++begin;
        following = value.charCodeAt(end2);
        if (following === uppercaseX || following === lowercaseX) {
          type2 = hexa;
          end2 = ++begin;
        } else {
          type2 = deci;
        }
      } else {
        type2 = name$1;
      }
      entityCharacters = "";
      entity = "";
      characters2 = "";
      test = tests[type2];
      end2--;
      while (++end2 < length) {
        following = value.charCodeAt(end2);
        if (!test(following)) {
          break;
        }
        characters2 += fromCharCode(following);
        if (type2 === name$1 && own$8.call(legacy$1, characters2)) {
          entityCharacters = characters2;
          entity = legacy$1[characters2];
        }
      }
      terminated = value.charCodeAt(end2) === semicolon2;
      if (terminated) {
        end2++;
        namedEntity = type2 === name$1 ? decodeEntity(characters2) : false;
        if (namedEntity) {
          entityCharacters = characters2;
          entity = namedEntity;
        }
      }
      diff = 1 + end2 - start2;
      if (!terminated && !nonTerminated) ;
      else if (!characters2) {
        if (type2 !== name$1) {
          warning(numericEmpty, diff);
        }
      } else if (type2 === name$1) {
        if (terminated && !entity) {
          warning(namedUnknown, 1);
        } else {
          if (entityCharacters !== characters2) {
            end2 = begin + entityCharacters.length;
            diff = 1 + end2 - begin;
            terminated = false;
          }
          if (!terminated) {
            reason = entityCharacters ? namedNotTerminated : namedEmpty;
            if (settings.attribute) {
              following = value.charCodeAt(end2);
              if (following === equalsTo) {
                warning(reason, diff);
                entity = null;
              } else if (alphanumerical$1(following)) {
                entity = null;
              } else {
                warning(reason, diff);
              }
            } else {
              warning(reason, diff);
            }
          }
        }
        reference = entity;
      } else {
        if (!terminated) {
          warning(numericNotTerminated, diff);
        }
        reference = parseInt(characters2, bases[type2]);
        if (prohibited(reference)) {
          warning(numericProhibited, diff);
          reference = fromCharCode(replacementCharacter);
        } else if (reference in invalid) {
          warning(numericDisallowed, diff);
          reference = invalid[reference];
        } else {
          output = "";
          if (disallowed(reference)) {
            warning(numericDisallowed, diff);
          }
          if (reference > 65535) {
            reference -= 65536;
            output += fromCharCode(reference >>> (10 & 1023) | 55296);
            reference = 56320 | reference & 1023;
          }
          reference = output + fromCharCode(reference);
        }
      }
      if (reference) {
        flush();
        prev = now();
        index2 = end2 - 1;
        column += end2 - start2 + 1;
        result.push(reference);
        next2 = now();
        next2.offset++;
        if (handleReference) {
          handleReference.call(
            referenceContext,
            reference,
            { start: prev, end: next2 },
            value.slice(start2 - 1, end2)
          );
        }
        prev = next2;
      } else {
        characters2 = value.slice(start2 - 1, end2);
        queue += characters2;
        column += characters2.length;
        index2 = end2 - 1;
      }
    } else {
      if (character === 10) {
        line++;
        lines++;
        column = 0;
      }
      if (character === character) {
        queue += fromCharCode(character);
        column++;
      } else {
        flush();
      }
    }
  }
  return result.join("");
  function now() {
    return {
      line,
      column,
      offset: index2 + (pos.offset || 0)
    };
  }
  function parseError(code2, offset2) {
    var position2 = now();
    position2.column += offset2;
    position2.offset += offset2;
    handleWarning.call(warningContext, messages[code2], position2, code2);
  }
  function flush() {
    if (queue) {
      result.push(queue);
      if (handleText) {
        handleText.call(textContext, queue, { start: prev, end: now() });
      }
      queue = "";
    }
  }
}
function prohibited(code2) {
  return code2 >= 55296 && code2 <= 57343 || code2 > 1114111;
}
function disallowed(code2) {
  return code2 >= 1 && code2 <= 8 || code2 === 11 || code2 >= 13 && code2 <= 31 || code2 >= 127 && code2 <= 159 || code2 >= 64976 && code2 <= 65007 || (code2 & 65535) === 65535 || (code2 & 65535) === 65534;
}
var xtend$3 = immutable;
var entities$1 = parseEntities_1;
var decode$1 = factory$3;
function factory$3(ctx) {
  decoder.raw = decodeRaw;
  return decoder;
  function normalize2(position2) {
    var offsets = ctx.offset;
    var line = position2.line;
    var result = [];
    while (++line) {
      if (!(line in offsets)) {
        break;
      }
      result.push((offsets[line] || 0) + 1);
    }
    return { start: position2, indent: result };
  }
  function decoder(value, position2, handler) {
    entities$1(value, {
      position: normalize2(position2),
      warning: handleWarning,
      text: handler,
      reference: handler,
      textContext: ctx,
      referenceContext: ctx
    });
  }
  function decodeRaw(value, position2, options2) {
    return entities$1(
      value,
      xtend$3(options2, { position: normalize2(position2), warning: handleWarning })
    );
  }
  function handleWarning(reason, position2, code2) {
    if (code2 !== 3) {
      ctx.file.message(reason, position2);
    }
  }
}
var tokenizer$3 = factory$2;
function factory$2(type2) {
  return tokenize2;
  function tokenize2(value, location) {
    var self2 = this;
    var offset2 = self2.offset;
    var tokens = [];
    var methods = self2[type2 + "Methods"];
    var tokenizers = self2[type2 + "Tokenizers"];
    var line = location.line;
    var column = location.column;
    var index2;
    var length;
    var method2;
    var name2;
    var matched;
    var valueLength;
    if (!value) {
      return tokens;
    }
    eat2.now = now;
    eat2.file = self2.file;
    updatePosition("");
    while (value) {
      index2 = -1;
      length = methods.length;
      matched = false;
      while (++index2 < length) {
        name2 = methods[index2];
        method2 = tokenizers[name2];
        if (method2 && /* istanbul ignore next */
        (!method2.onlyAtStart || self2.atStart) && /* istanbul ignore next */
        (!method2.notInList || !self2.inList) && /* istanbul ignore next */
        (!method2.notInBlock || !self2.inBlock) && (!method2.notInLink || !self2.inLink)) {
          valueLength = value.length;
          method2.apply(self2, [eat2, value]);
          matched = valueLength !== value.length;
          if (matched) {
            break;
          }
        }
      }
      if (!matched) {
        self2.file.fail(new Error("Infinite loop"), eat2.now());
      }
    }
    self2.eof = now();
    return tokens;
    function updatePosition(subvalue) {
      var lastIndex = -1;
      var index3 = subvalue.indexOf("\n");
      while (index3 !== -1) {
        line++;
        lastIndex = index3;
        index3 = subvalue.indexOf("\n", index3 + 1);
      }
      if (lastIndex === -1) {
        column += subvalue.length;
      } else {
        column = subvalue.length - lastIndex;
      }
      if (line in offset2) {
        if (lastIndex !== -1) {
          column += offset2[line];
        } else if (column <= offset2[line]) {
          column = offset2[line] + 1;
        }
      }
    }
    function getOffset() {
      var indentation = [];
      var pos = line + 1;
      return function() {
        var last = line + 1;
        while (pos < last) {
          indentation.push((offset2[pos] || 0) + 1);
          pos++;
        }
        return indentation;
      };
    }
    function now() {
      var pos = { line, column };
      pos.offset = self2.toOffset(pos);
      return pos;
    }
    function Position3(start2) {
      this.start = start2;
      this.end = now();
    }
    function validateEat(subvalue) {
      if (value.slice(0, subvalue.length) !== subvalue) {
        self2.file.fail(
          new Error(
            "Incorrectly eaten value: please report this warning on https://git.io/vg5Ft"
          ),
          now()
        );
      }
    }
    function position2() {
      var before2 = now();
      return update2;
      function update2(node, indent2) {
        var previous = node.position;
        var start2 = previous ? previous.start : before2;
        var combined = [];
        var n = previous && previous.end.line;
        var l2 = before2.line;
        node.position = new Position3(start2);
        if (previous && indent2 && previous.indent) {
          combined = previous.indent;
          if (n < l2) {
            while (++n < l2) {
              combined.push((offset2[n] || 0) + 1);
            }
            combined.push(before2.column);
          }
          indent2 = combined.concat(indent2);
        }
        node.position.indent = indent2 || [];
        return node;
      }
    }
    function add(node, parent) {
      var children = parent ? parent.children : tokens;
      var previous = children[children.length - 1];
      var fn;
      if (previous && node.type === previous.type && (node.type === "text" || node.type === "blockquote") && mergeable(previous) && mergeable(node)) {
        fn = node.type === "text" ? mergeText : mergeBlockquote;
        node = fn.call(self2, previous, node);
      }
      if (node !== previous) {
        children.push(node);
      }
      if (self2.atStart && tokens.length !== 0) {
        self2.exitStart();
      }
      return node;
    }
    function eat2(subvalue) {
      var indent2 = getOffset();
      var pos = position2();
      var current2 = now();
      validateEat(subvalue);
      apply.reset = reset3;
      reset3.test = test;
      apply.test = test;
      value = value.slice(subvalue.length);
      updatePosition(subvalue);
      indent2 = indent2();
      return apply;
      function apply(node, parent) {
        return pos(add(pos(node), parent), indent2);
      }
      function reset3() {
        var node = apply.apply(null, arguments);
        line = current2.line;
        column = current2.column;
        value = subvalue + value;
        return node;
      }
      function test() {
        var result = pos({});
        line = current2.line;
        column = current2.column;
        value = subvalue + value;
        return result.position;
      }
    }
  }
}
function mergeable(node) {
  var start2;
  var end2;
  if (node.type !== "text" || !node.position) {
    return true;
  }
  start2 = node.position.start;
  end2 = node.position.end;
  return start2.line !== end2.line || end2.column - start2.column === node.value.length;
}
function mergeText(previous, node) {
  previous.value += node.value;
  return previous;
}
function mergeBlockquote(previous, node) {
  if (this.options.commonmark || this.options.gfm) {
    return node;
  }
  previous.children = previous.children.concat(node.children);
  return previous;
}
var markdownEscapes;
var hasRequiredMarkdownEscapes;
function requireMarkdownEscapes() {
  if (hasRequiredMarkdownEscapes) return markdownEscapes;
  hasRequiredMarkdownEscapes = 1;
  markdownEscapes = escapes2;
  var defaults2 = [
    "\\",
    "`",
    "*",
    "{",
    "}",
    "[",
    "]",
    "(",
    ")",
    "#",
    "+",
    "-",
    ".",
    "!",
    "_",
    ">"
  ];
  var gfm = defaults2.concat(["~", "|"]);
  var commonmark = gfm.concat([
    "\n",
    '"',
    "$",
    "%",
    "&",
    "'",
    ",",
    "/",
    ":",
    ";",
    "<",
    "=",
    "?",
    "@",
    "^"
  ]);
  escapes2.default = defaults2;
  escapes2.gfm = gfm;
  escapes2.commonmark = commonmark;
  function escapes2(options2) {
    var settings = options2 || {};
    if (settings.commonmark) {
      return commonmark;
    }
    return settings.gfm ? gfm : defaults2;
  }
  return markdownEscapes;
}
var blockElements;
var hasRequiredBlockElements;
function requireBlockElements() {
  if (hasRequiredBlockElements) return blockElements;
  hasRequiredBlockElements = 1;
  blockElements = [
    "address",
    "article",
    "aside",
    "base",
    "basefont",
    "blockquote",
    "body",
    "caption",
    "center",
    "col",
    "colgroup",
    "dd",
    "details",
    "dialog",
    "dir",
    "div",
    "dl",
    "dt",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "frame",
    "frameset",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "iframe",
    "legend",
    "li",
    "link",
    "main",
    "menu",
    "menuitem",
    "meta",
    "nav",
    "noframes",
    "ol",
    "optgroup",
    "option",
    "p",
    "param",
    "pre",
    "section",
    "source",
    "title",
    "summary",
    "table",
    "tbody",
    "td",
    "tfoot",
    "th",
    "thead",
    "title",
    "tr",
    "track",
    "ul"
  ];
  return blockElements;
}
var defaults$1;
var hasRequiredDefaults;
function requireDefaults() {
  if (hasRequiredDefaults) return defaults$1;
  hasRequiredDefaults = 1;
  defaults$1 = {
    position: true,
    gfm: true,
    commonmark: false,
    pedantic: false,
    blocks: requireBlockElements()
  };
  return defaults$1;
}
var setOptions_1;
var hasRequiredSetOptions;
function requireSetOptions() {
  if (hasRequiredSetOptions) return setOptions_1;
  hasRequiredSetOptions = 1;
  var xtend2 = immutable;
  var escapes2 = requireMarkdownEscapes();
  var defaults2 = requireDefaults();
  setOptions_1 = setOptions;
  function setOptions(options2) {
    var self2 = this;
    var current2 = self2.options;
    var key2;
    var value;
    if (options2 == null) {
      options2 = {};
    } else if (typeof options2 === "object") {
      options2 = xtend2(options2);
    } else {
      throw new Error("Invalid value `" + options2 + "` for setting `options`");
    }
    for (key2 in defaults2) {
      value = options2[key2];
      if (value == null) {
        value = current2[key2];
      }
      if (key2 !== "blocks" && typeof value !== "boolean" || key2 === "blocks" && typeof value !== "object") {
        throw new Error(
          "Invalid value `" + value + "` for setting `options." + key2 + "`"
        );
      }
      options2[key2] = value;
    }
    self2.options = options2;
    self2.escape = escapes2(options2);
    return self2;
  }
  return setOptions_1;
}
var convert_1 = convert$2;
function convert$2(test) {
  if (test == null) {
    return ok$1;
  }
  if (typeof test === "string") {
    return typeFactory$1(test);
  }
  if (typeof test === "object") {
    return "length" in test ? anyFactory$1(test) : allFactory(test);
  }
  if (typeof test === "function") {
    return test;
  }
  throw new Error("Expected function, string, or object as test");
}
function allFactory(test) {
  return all2;
  function all2(node) {
    var key2;
    for (key2 in test) {
      if (node[key2] !== test[key2]) return false;
    }
    return true;
  }
}
function anyFactory$1(tests2) {
  var checks2 = [];
  var index2 = -1;
  while (++index2 < tests2.length) {
    checks2[index2] = convert$2(tests2[index2]);
  }
  return any;
  function any() {
    var index3 = -1;
    while (++index3 < checks2.length) {
      if (checks2[index3].apply(this, arguments)) {
        return true;
      }
    }
    return false;
  }
}
function typeFactory$1(test) {
  return type2;
  function type2(node) {
    return Boolean(node && node.type === test);
  }
}
function ok$1() {
  return true;
}
var color_1 = color$1;
function color$1(d) {
  return "\x1B[33m" + d + "\x1B[39m";
}
var unistUtilVisitParents = visitParents$1;
var convert$1 = convert_1;
var color = color_1;
var CONTINUE$1 = true;
var SKIP$1 = "skip";
var EXIT$1 = false;
visitParents$1.CONTINUE = CONTINUE$1;
visitParents$1.SKIP = SKIP$1;
visitParents$1.EXIT = EXIT$1;
function visitParents$1(tree, test, visitor, reverse) {
  var step;
  var is2;
  if (typeof test === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test;
    test = null;
  }
  is2 = convert$1(test);
  step = reverse ? -1 : 1;
  factory2(tree, null, [])();
  function factory2(node, index2, parents) {
    var value = typeof node === "object" && node !== null ? node : {};
    var name2;
    if (typeof value.type === "string") {
      name2 = typeof value.tagName === "string" ? value.tagName : typeof value.name === "string" ? value.name : void 0;
      visit2.displayName = "node (" + color(value.type + (name2 ? "<" + name2 + ">" : "")) + ")";
    }
    return visit2;
    function visit2() {
      var grandparents = parents.concat(node);
      var result = [];
      var subresult;
      var offset2;
      if (!test || is2(node, index2, parents[parents.length - 1] || null)) {
        result = toResult(visitor(node, parents));
        if (result[0] === EXIT$1) {
          return result;
        }
      }
      if (node.children && result[0] !== SKIP$1) {
        offset2 = (reverse ? node.children.length : -1) + step;
        while (offset2 > -1 && offset2 < node.children.length) {
          subresult = factory2(node.children[offset2], offset2, grandparents)();
          if (subresult[0] === EXIT$1) {
            return subresult;
          }
          offset2 = typeof subresult[1] === "number" ? subresult[1] : offset2 + step;
        }
      }
      return result;
    }
  }
}
function toResult(value) {
  if (value !== null && typeof value === "object" && "length" in value) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE$1, value];
  }
  return [value];
}
var unistUtilVisit = visit$5;
var visitParents = unistUtilVisitParents;
var CONTINUE = visitParents.CONTINUE;
var SKIP = visitParents.SKIP;
var EXIT = visitParents.EXIT;
visit$5.CONTINUE = CONTINUE;
visit$5.SKIP = SKIP;
visit$5.EXIT = EXIT;
function visit$5(tree, test, visitor, reverse) {
  if (typeof test === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test;
    test = null;
  }
  visitParents(tree, test, overload, reverse);
  function overload(node, parents) {
    var parent = parents[parents.length - 1];
    var index2 = parent ? parent.children.indexOf(node) : null;
    return visitor(node, index2, parent);
  }
}
var visit$6 = getDefaultExportFromCjs(unistUtilVisit);
var unistUtilRemovePosition;
var hasRequiredUnistUtilRemovePosition;
function requireUnistUtilRemovePosition() {
  if (hasRequiredUnistUtilRemovePosition) return unistUtilRemovePosition;
  hasRequiredUnistUtilRemovePosition = 1;
  var visit2 = unistUtilVisit;
  unistUtilRemovePosition = removePosition;
  function removePosition(node, force) {
    visit2(node, force ? hard : soft);
    return node;
  }
  function hard(node) {
    delete node.position;
  }
  function soft(node) {
    node.position = void 0;
  }
  return unistUtilRemovePosition;
}
var parse_1;
var hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse_1;
  hasRequiredParse = 1;
  var xtend2 = immutable;
  var removePosition = requireUnistUtilRemovePosition();
  parse_1 = parse8;
  var lineFeed2 = "\n";
  var lineBreaksExpression = /\r\n|\r/g;
  function parse8() {
    var self2 = this;
    var value = String(self2.file);
    var start2 = { line: 1, column: 1, offset: 0 };
    var content = xtend2(start2);
    var node;
    value = value.replace(lineBreaksExpression, lineFeed2);
    if (value.charCodeAt(0) === 65279) {
      value = value.slice(1);
      content.column++;
      content.offset++;
    }
    node = {
      type: "root",
      children: self2.tokenizeBlock(value, content),
      position: { start: start2, end: self2.eof || xtend2(start2) }
    };
    if (!self2.options.position) {
      removePosition(node, true);
    }
    return node;
  }
  return parse_1;
}
var blankLine_1;
var hasRequiredBlankLine;
function requireBlankLine() {
  if (hasRequiredBlankLine) return blankLine_1;
  hasRequiredBlankLine = 1;
  var reBlankLine = /^[ \t]*(\n|$)/;
  blankLine_1 = blankLine;
  function blankLine(eat2, value, silent) {
    var match;
    var subvalue = "";
    var index2 = 0;
    var length = value.length;
    while (index2 < length) {
      match = reBlankLine.exec(value.slice(index2));
      if (match == null) {
        break;
      }
      index2 += match[0].length;
      subvalue += match[0];
    }
    if (subvalue === "") {
      return;
    }
    if (silent) {
      return true;
    }
    eat2(subvalue);
  }
  return blankLine_1;
}
var res = "";
var cache;
var repeatString = repeat$2;
function repeat$2(str2, num2) {
  if (typeof str2 !== "string") {
    throw new TypeError("expected a string");
  }
  if (num2 === 1) return str2;
  if (num2 === 2) return str2 + str2;
  var max = str2.length * num2;
  if (cache !== str2 || typeof cache === "undefined") {
    cache = str2;
    res = "";
  } else if (res.length >= max) {
    return res.substr(0, max);
  }
  while (max > res.length && num2 > 1) {
    if (num2 & 1) {
      res += str2;
    }
    num2 >>= 1;
    str2 += str2;
  }
  res += str2;
  res = res.substr(0, max);
  return res;
}
var trimTrailingLines_1;
var hasRequiredTrimTrailingLines;
function requireTrimTrailingLines() {
  if (hasRequiredTrimTrailingLines) return trimTrailingLines_1;
  hasRequiredTrimTrailingLines = 1;
  trimTrailingLines_1 = trimTrailingLines;
  var line = "\n";
  function trimTrailingLines(value) {
    var val = String(value);
    var index2 = val.length;
    while (val.charAt(--index2) === line) {
    }
    return val.slice(0, index2 + 1);
  }
  return trimTrailingLines_1;
}
var codeIndented;
var hasRequiredCodeIndented;
function requireCodeIndented() {
  if (hasRequiredCodeIndented) return codeIndented;
  hasRequiredCodeIndented = 1;
  var repeat2 = repeatString;
  var trim2 = requireTrimTrailingLines();
  codeIndented = indentedCode2;
  var lineFeed2 = "\n";
  var tab2 = "	";
  var space3 = " ";
  var tabSize = 4;
  var codeIndent = repeat2(space3, tabSize);
  function indentedCode2(eat2, value, silent) {
    var index2 = -1;
    var length = value.length;
    var subvalue = "";
    var content = "";
    var subvalueQueue = "";
    var contentQueue = "";
    var character;
    var blankQueue;
    var indent2;
    while (++index2 < length) {
      character = value.charAt(index2);
      if (indent2) {
        indent2 = false;
        subvalue += subvalueQueue;
        content += contentQueue;
        subvalueQueue = "";
        contentQueue = "";
        if (character === lineFeed2) {
          subvalueQueue = character;
          contentQueue = character;
        } else {
          subvalue += character;
          content += character;
          while (++index2 < length) {
            character = value.charAt(index2);
            if (!character || character === lineFeed2) {
              contentQueue = character;
              subvalueQueue = character;
              break;
            }
            subvalue += character;
            content += character;
          }
        }
      } else if (character === space3 && value.charAt(index2 + 1) === character && value.charAt(index2 + 2) === character && value.charAt(index2 + 3) === character) {
        subvalueQueue += codeIndent;
        index2 += 3;
        indent2 = true;
      } else if (character === tab2) {
        subvalueQueue += character;
        indent2 = true;
      } else {
        blankQueue = "";
        while (character === tab2 || character === space3) {
          blankQueue += character;
          character = value.charAt(++index2);
        }
        if (character !== lineFeed2) {
          break;
        }
        subvalueQueue += blankQueue + character;
        contentQueue += character;
      }
    }
    if (content) {
      if (silent) {
        return true;
      }
      return eat2(subvalue)({
        type: "code",
        lang: null,
        meta: null,
        value: trim2(content)
      });
    }
  }
  return codeIndented;
}
var codeFenced;
var hasRequiredCodeFenced;
function requireCodeFenced() {
  if (hasRequiredCodeFenced) return codeFenced;
  hasRequiredCodeFenced = 1;
  codeFenced = fencedCode;
  var lineFeed2 = "\n";
  var tab2 = "	";
  var space3 = " ";
  var tilde2 = "~";
  var graveAccent = "`";
  var minFenceCount = 3;
  var tabSize = 4;
  function fencedCode(eat2, value, silent) {
    var self2 = this;
    var gfm = self2.options.gfm;
    var length = value.length + 1;
    var index2 = 0;
    var subvalue = "";
    var fenceCount;
    var marker2;
    var character;
    var flag;
    var lang2;
    var meta2;
    var queue;
    var content;
    var exdentedContent;
    var closing2;
    var exdentedClosing;
    var indent2;
    var now;
    if (!gfm) {
      return;
    }
    while (index2 < length) {
      character = value.charAt(index2);
      if (character !== space3 && character !== tab2) {
        break;
      }
      subvalue += character;
      index2++;
    }
    indent2 = index2;
    character = value.charAt(index2);
    if (character !== tilde2 && character !== graveAccent) {
      return;
    }
    index2++;
    marker2 = character;
    fenceCount = 1;
    subvalue += character;
    while (index2 < length) {
      character = value.charAt(index2);
      if (character !== marker2) {
        break;
      }
      subvalue += character;
      fenceCount++;
      index2++;
    }
    if (fenceCount < minFenceCount) {
      return;
    }
    while (index2 < length) {
      character = value.charAt(index2);
      if (character !== space3 && character !== tab2) {
        break;
      }
      subvalue += character;
      index2++;
    }
    flag = "";
    queue = "";
    while (index2 < length) {
      character = value.charAt(index2);
      if (character === lineFeed2 || marker2 === graveAccent && character === marker2) {
        break;
      }
      if (character === space3 || character === tab2) {
        queue += character;
      } else {
        flag += queue + character;
        queue = "";
      }
      index2++;
    }
    character = value.charAt(index2);
    if (character && character !== lineFeed2) {
      return;
    }
    if (silent) {
      return true;
    }
    now = eat2.now();
    now.column += subvalue.length;
    now.offset += subvalue.length;
    subvalue += flag;
    flag = self2.decode.raw(self2.unescape(flag), now);
    if (queue) {
      subvalue += queue;
    }
    queue = "";
    closing2 = "";
    exdentedClosing = "";
    content = "";
    exdentedContent = "";
    var skip = true;
    while (index2 < length) {
      character = value.charAt(index2);
      content += closing2;
      exdentedContent += exdentedClosing;
      closing2 = "";
      exdentedClosing = "";
      if (character !== lineFeed2) {
        content += character;
        exdentedClosing += character;
        index2++;
        continue;
      }
      if (skip) {
        subvalue += character;
        skip = false;
      } else {
        closing2 += character;
        exdentedClosing += character;
      }
      queue = "";
      index2++;
      while (index2 < length) {
        character = value.charAt(index2);
        if (character !== space3) {
          break;
        }
        queue += character;
        index2++;
      }
      closing2 += queue;
      exdentedClosing += queue.slice(indent2);
      if (queue.length >= tabSize) {
        continue;
      }
      queue = "";
      while (index2 < length) {
        character = value.charAt(index2);
        if (character !== marker2) {
          break;
        }
        queue += character;
        index2++;
      }
      closing2 += queue;
      exdentedClosing += queue;
      if (queue.length < fenceCount) {
        continue;
      }
      queue = "";
      while (index2 < length) {
        character = value.charAt(index2);
        if (character !== space3 && character !== tab2) {
          break;
        }
        closing2 += character;
        exdentedClosing += character;
        index2++;
      }
      if (!character || character === lineFeed2) {
        break;
      }
    }
    subvalue += content + closing2;
    index2 = -1;
    length = flag.length;
    while (++index2 < length) {
      character = flag.charAt(index2);
      if (character === space3 || character === tab2) {
        if (!lang2) {
          lang2 = flag.slice(0, index2);
        }
      } else if (lang2) {
        meta2 = flag.slice(index2);
        break;
      }
    }
    return eat2(subvalue)({
      type: "code",
      lang: lang2 || flag || null,
      meta: meta2 || null,
      value: exdentedContent
    });
  }
  return codeFenced;
}
var trim = { exports: {} };
var hasRequiredTrim;
function requireTrim() {
  if (hasRequiredTrim) return trim.exports;
  hasRequiredTrim = 1;
  (function(module, exports) {
    exports = module.exports = trim2;
    function trim2(str2) {
      return str2.replace(/^\s*|\s*$/g, "");
    }
    exports.left = function(str2) {
      return str2.replace(/^\s*/, "");
    };
    exports.right = function(str2) {
      return str2.replace(/\s*$/, "");
    };
  })(trim, trim.exports);
  return trim.exports;
}
var interrupt_1;
var hasRequiredInterrupt;
function requireInterrupt() {
  if (hasRequiredInterrupt) return interrupt_1;
  hasRequiredInterrupt = 1;
  interrupt_1 = interrupt;
  function interrupt(interruptors, tokenizers, ctx, parameters) {
    var length = interruptors.length;
    var index2 = -1;
    var interruptor;
    var config;
    while (++index2 < length) {
      interruptor = interruptors[index2];
      config = interruptor[1] || {};
      if (config.pedantic !== void 0 && config.pedantic !== ctx.options.pedantic) {
        continue;
      }
      if (config.commonmark !== void 0 && config.commonmark !== ctx.options.commonmark) {
        continue;
      }
      if (tokenizers[interruptor[0]].apply(ctx, parameters)) {
        return true;
      }
    }
    return false;
  }
  return interrupt_1;
}
var blockquote_1$1;
var hasRequiredBlockquote;
function requireBlockquote() {
  if (hasRequiredBlockquote) return blockquote_1$1;
  hasRequiredBlockquote = 1;
  var trim2 = requireTrim();
  var interrupt = requireInterrupt();
  blockquote_1$1 = blockquote2;
  var lineFeed2 = "\n";
  var tab2 = "	";
  var space3 = " ";
  var greaterThan = ">";
  function blockquote2(eat2, value, silent) {
    var self2 = this;
    var offsets = self2.offset;
    var tokenizers = self2.blockTokenizers;
    var interruptors = self2.interruptBlockquote;
    var now = eat2.now();
    var currentLine = now.line;
    var length = value.length;
    var values = [];
    var contents = [];
    var indents = [];
    var add;
    var index2 = 0;
    var character;
    var rest2;
    var nextIndex2;
    var content;
    var line;
    var startIndex;
    var prefixed;
    var exit;
    while (index2 < length) {
      character = value.charAt(index2);
      if (character !== space3 && character !== tab2) {
        break;
      }
      index2++;
    }
    if (value.charAt(index2) !== greaterThan) {
      return;
    }
    if (silent) {
      return true;
    }
    index2 = 0;
    while (index2 < length) {
      nextIndex2 = value.indexOf(lineFeed2, index2);
      startIndex = index2;
      prefixed = false;
      if (nextIndex2 === -1) {
        nextIndex2 = length;
      }
      while (index2 < length) {
        character = value.charAt(index2);
        if (character !== space3 && character !== tab2) {
          break;
        }
        index2++;
      }
      if (value.charAt(index2) === greaterThan) {
        index2++;
        prefixed = true;
        if (value.charAt(index2) === space3) {
          index2++;
        }
      } else {
        index2 = startIndex;
      }
      content = value.slice(index2, nextIndex2);
      if (!prefixed && !trim2(content)) {
        index2 = startIndex;
        break;
      }
      if (!prefixed) {
        rest2 = value.slice(index2);
        if (interrupt(interruptors, tokenizers, self2, [eat2, rest2, true])) {
          break;
        }
      }
      line = startIndex === index2 ? content : value.slice(startIndex, nextIndex2);
      indents.push(index2 - startIndex);
      values.push(line);
      contents.push(content);
      index2 = nextIndex2 + 1;
    }
    index2 = -1;
    length = indents.length;
    add = eat2(values.join(lineFeed2));
    while (++index2 < length) {
      offsets[currentLine] = (offsets[currentLine] || 0) + indents[index2];
      currentLine++;
    }
    exit = self2.enterBlock();
    contents = self2.tokenizeBlock(contents.join(lineFeed2), now);
    exit();
    return add({ type: "blockquote", children: contents });
  }
  return blockquote_1$1;
}
var headingAtx;
var hasRequiredHeadingAtx;
function requireHeadingAtx() {
  if (hasRequiredHeadingAtx) return headingAtx;
  hasRequiredHeadingAtx = 1;
  headingAtx = atxHeading;
  var lineFeed2 = "\n";
  var tab2 = "	";
  var space3 = " ";
  var numberSign2 = "#";
  var maxFenceCount = 6;
  function atxHeading(eat2, value, silent) {
    var self2 = this;
    var pedantic = self2.options.pedantic;
    var length = value.length + 1;
    var index2 = -1;
    var now = eat2.now();
    var subvalue = "";
    var content = "";
    var character;
    var queue;
    var depth;
    while (++index2 < length) {
      character = value.charAt(index2);
      if (character !== space3 && character !== tab2) {
        index2--;
        break;
      }
      subvalue += character;
    }
    depth = 0;
    while (++index2 <= length) {
      character = value.charAt(index2);
      if (character !== numberSign2) {
        index2--;
        break;
      }
      subvalue += character;
      depth++;
    }
    if (depth > maxFenceCount) {
      return;
    }
    if (!depth || !pedantic && value.charAt(index2 + 1) === numberSign2) {
      return;
    }
    length = value.length + 1;
    queue = "";
    while (++index2 < length) {
      character = value.charAt(index2);
      if (character !== space3 && character !== tab2) {
        index2--;
        break;
      }
      queue += character;
    }
    if (!pedantic && queue.length === 0 && character && character !== lineFeed2) {
      return;
    }
    if (silent) {
      return true;
    }
    subvalue += queue;
    queue = "";
    content = "";
    while (++index2 < length) {
      character = value.charAt(index2);
      if (!character || character === lineFeed2) {
        break;
      }
      if (character !== space3 && character !== tab2 && character !== numberSign2) {
        content += queue + character;
        queue = "";
        continue;
      }
      while (character === space3 || character === tab2) {
        queue += character;
        character = value.charAt(++index2);
      }
      if (!pedantic && content && !queue && character === numberSign2) {
        content += character;
        continue;
      }
      while (character === numberSign2) {
        queue += character;
        character = value.charAt(++index2);
      }
      while (character === space3 || character === tab2) {
        queue += character;
        character = value.charAt(++index2);
      }
      index2--;
    }
    now.column += subvalue.length;
    now.offset += subvalue.length;
    subvalue += content + queue;
    return eat2(subvalue)({
      type: "heading",
      depth,
      children: self2.tokenizeInline(content, now)
    });
  }
  return headingAtx;
}
var thematicBreak_1$1;
var hasRequiredThematicBreak;
function requireThematicBreak() {
  if (hasRequiredThematicBreak) return thematicBreak_1$1;
  hasRequiredThematicBreak = 1;
  thematicBreak_1$1 = thematicBreak2;
  var tab2 = "	";
  var lineFeed2 = "\n";
  var space3 = " ";
  var asterisk = "*";
  var dash2 = "-";
  var underscore = "_";
  var maxCount = 3;
  function thematicBreak2(eat2, value, silent) {
    var index2 = -1;
    var length = value.length + 1;
    var subvalue = "";
    var character;
    var marker2;
    var markerCount;
    var queue;
    while (++index2 < length) {
      character = value.charAt(index2);
      if (character !== tab2 && character !== space3) {
        break;
      }
      subvalue += character;
    }
    if (character !== asterisk && character !== dash2 && character !== underscore) {
      return;
    }
    marker2 = character;
    subvalue += character;
    markerCount = 1;
    queue = "";
    while (++index2 < length) {
      character = value.charAt(index2);
      if (character === marker2) {
        markerCount++;
        subvalue += queue + marker2;
        queue = "";
      } else if (character === space3) {
        queue += character;
      } else if (markerCount >= maxCount && (!character || character === lineFeed2)) {
        subvalue += queue;
        if (silent) {
          return true;
        }
        return eat2(subvalue)({ type: "thematicBreak" });
      } else {
        return;
      }
    }
  }
  return thematicBreak_1$1;
}
var getIndentation;
var hasRequiredGetIndentation;
function requireGetIndentation() {
  if (hasRequiredGetIndentation) return getIndentation;
  hasRequiredGetIndentation = 1;
  getIndentation = indentation;
  var tab2 = "	";
  var space3 = " ";
  var spaceSize = 1;
  var tabSize = 4;
  function indentation(value) {
    var index2 = 0;
    var indent2 = 0;
    var character = value.charAt(index2);
    var stops = {};
    var size;
    var lastIndent = 0;
    while (character === tab2 || character === space3) {
      size = character === tab2 ? tabSize : spaceSize;
      indent2 += size;
      if (size > 1) {
        indent2 = Math.floor(indent2 / size) * size;
      }
      while (lastIndent < indent2) {
        stops[++lastIndent] = index2;
      }
      character = value.charAt(++index2);
    }
    return { indent: indent2, stops };
  }
  return getIndentation;
}
var removeIndentation;
var hasRequiredRemoveIndentation;
function requireRemoveIndentation() {
  if (hasRequiredRemoveIndentation) return removeIndentation;
  hasRequiredRemoveIndentation = 1;
  var trim2 = requireTrim();
  var repeat2 = repeatString;
  var getIndent = requireGetIndentation();
  removeIndentation = indentation;
  var lineFeed2 = "\n";
  var space3 = " ";
  var exclamationMark = "!";
  function indentation(value, maximum) {
    var values = value.split(lineFeed2);
    var position2 = values.length + 1;
    var minIndent = Infinity;
    var matrix = [];
    var index2;
    var indentation2;
    var stops;
    values.unshift(repeat2(space3, maximum) + exclamationMark);
    while (position2--) {
      indentation2 = getIndent(values[position2]);
      matrix[position2] = indentation2.stops;
      if (trim2(values[position2]).length === 0) {
        continue;
      }
      if (indentation2.indent) {
        if (indentation2.indent > 0 && indentation2.indent < minIndent) {
          minIndent = indentation2.indent;
        }
      } else {
        minIndent = Infinity;
        break;
      }
    }
    if (minIndent !== Infinity) {
      position2 = values.length;
      while (position2--) {
        stops = matrix[position2];
        index2 = minIndent;
        while (index2 && !(index2 in stops)) {
          index2--;
        }
        values[position2] = values[position2].slice(stops[index2] + 1);
      }
    }
    values.shift();
    return values.join(lineFeed2);
  }
  return removeIndentation;
}
var list_1$1;
var hasRequiredList;
function requireList() {
  if (hasRequiredList) return list_1$1;
  hasRequiredList = 1;
  var trim2 = requireTrim();
  var repeat2 = repeatString;
  var decimal2 = requireIsDecimal();
  var getIndent = requireGetIndentation();
  var removeIndent = requireRemoveIndentation();
  var interrupt = requireInterrupt();
  list_1$1 = list4;
  var asterisk = "*";
  var underscore = "_";
  var plusSign = "+";
  var dash2 = "-";
  var dot2 = ".";
  var space3 = " ";
  var lineFeed2 = "\n";
  var tab2 = "	";
  var rightParenthesis = ")";
  var lowercaseX2 = "x";
  var tabSize = 4;
  var looseListItemExpression = /\n\n(?!\s*$)/;
  var taskItemExpression = /^\[([ X\tx])][ \t]/;
  var bulletExpression = /^([ \t]*)([*+-]|\d+[.)])( {1,4}(?! )| |\t|$|(?=\n))([^\n]*)/;
  var pedanticBulletExpression = /^([ \t]*)([*+-]|\d+[.)])([ \t]+)/;
  var initialIndentExpression = /^( {1,4}|\t)?/gm;
  function list4(eat2, value, silent) {
    var self2 = this;
    var commonmark = self2.options.commonmark;
    var pedantic = self2.options.pedantic;
    var tokenizers = self2.blockTokenizers;
    var interuptors = self2.interruptList;
    var index2 = 0;
    var length = value.length;
    var start2 = null;
    var size;
    var queue;
    var ordered;
    var character;
    var marker2;
    var nextIndex2;
    var startIndex;
    var prefixed;
    var currentMarker;
    var content;
    var line;
    var previousEmpty;
    var empty4;
    var items;
    var allLines;
    var emptyLines;
    var item;
    var enterTop;
    var exitBlockquote;
    var spread2 = false;
    var node;
    var now;
    var end2;
    var indented;
    while (index2 < length) {
      character = value.charAt(index2);
      if (character !== tab2 && character !== space3) {
        break;
      }
      index2++;
    }
    character = value.charAt(index2);
    if (character === asterisk || character === plusSign || character === dash2) {
      marker2 = character;
      ordered = false;
    } else {
      ordered = true;
      queue = "";
      while (index2 < length) {
        character = value.charAt(index2);
        if (!decimal2(character)) {
          break;
        }
        queue += character;
        index2++;
      }
      character = value.charAt(index2);
      if (!queue || !(character === dot2 || commonmark && character === rightParenthesis)) {
        return;
      }
      if (silent && queue !== "1") {
        return;
      }
      start2 = parseInt(queue, 10);
      marker2 = character;
    }
    character = value.charAt(++index2);
    if (character !== space3 && character !== tab2 && (pedantic || character !== lineFeed2 && character !== "")) {
      return;
    }
    if (silent) {
      return true;
    }
    index2 = 0;
    items = [];
    allLines = [];
    emptyLines = [];
    while (index2 < length) {
      nextIndex2 = value.indexOf(lineFeed2, index2);
      startIndex = index2;
      prefixed = false;
      indented = false;
      if (nextIndex2 === -1) {
        nextIndex2 = length;
      }
      size = 0;
      while (index2 < length) {
        character = value.charAt(index2);
        if (character === tab2) {
          size += tabSize - size % tabSize;
        } else if (character === space3) {
          size++;
        } else {
          break;
        }
        index2++;
      }
      if (item && size >= item.indent) {
        indented = true;
      }
      character = value.charAt(index2);
      currentMarker = null;
      if (!indented) {
        if (character === asterisk || character === plusSign || character === dash2) {
          currentMarker = character;
          index2++;
          size++;
        } else {
          queue = "";
          while (index2 < length) {
            character = value.charAt(index2);
            if (!decimal2(character)) {
              break;
            }
            queue += character;
            index2++;
          }
          character = value.charAt(index2);
          index2++;
          if (queue && (character === dot2 || commonmark && character === rightParenthesis)) {
            currentMarker = character;
            size += queue.length + 1;
          }
        }
        if (currentMarker) {
          character = value.charAt(index2);
          if (character === tab2) {
            size += tabSize - size % tabSize;
            index2++;
          } else if (character === space3) {
            end2 = index2 + tabSize;
            while (index2 < end2) {
              if (value.charAt(index2) !== space3) {
                break;
              }
              index2++;
              size++;
            }
            if (index2 === end2 && value.charAt(index2) === space3) {
              index2 -= tabSize - 1;
              size -= tabSize - 1;
            }
          } else if (character !== lineFeed2 && character !== "") {
            currentMarker = null;
          }
        }
      }
      if (currentMarker) {
        if (!pedantic && marker2 !== currentMarker) {
          break;
        }
        prefixed = true;
      } else {
        if (!commonmark && !indented && value.charAt(startIndex) === space3) {
          indented = true;
        } else if (commonmark && item) {
          indented = size >= item.indent || size > tabSize;
        }
        prefixed = false;
        index2 = startIndex;
      }
      line = value.slice(startIndex, nextIndex2);
      content = startIndex === index2 ? line : value.slice(index2, nextIndex2);
      if (currentMarker === asterisk || currentMarker === underscore || currentMarker === dash2) {
        if (tokenizers.thematicBreak.call(self2, eat2, line, true)) {
          break;
        }
      }
      previousEmpty = empty4;
      empty4 = !prefixed && !trim2(content).length;
      if (indented && item) {
        item.value = item.value.concat(emptyLines, line);
        allLines = allLines.concat(emptyLines, line);
        emptyLines = [];
      } else if (prefixed) {
        if (emptyLines.length !== 0) {
          spread2 = true;
          item.value.push("");
          item.trail = emptyLines.concat();
        }
        item = {
          value: [line],
          indent: size,
          trail: []
        };
        items.push(item);
        allLines = allLines.concat(emptyLines, line);
        emptyLines = [];
      } else if (empty4) {
        if (previousEmpty && !commonmark) {
          break;
        }
        emptyLines.push(line);
      } else {
        if (previousEmpty) {
          break;
        }
        if (interrupt(interuptors, tokenizers, self2, [eat2, line, true])) {
          break;
        }
        item.value = item.value.concat(emptyLines, line);
        allLines = allLines.concat(emptyLines, line);
        emptyLines = [];
      }
      index2 = nextIndex2 + 1;
    }
    node = eat2(allLines.join(lineFeed2)).reset({
      type: "list",
      ordered,
      start: start2,
      spread: spread2,
      children: []
    });
    enterTop = self2.enterList();
    exitBlockquote = self2.enterBlock();
    index2 = -1;
    length = items.length;
    while (++index2 < length) {
      item = items[index2].value.join(lineFeed2);
      now = eat2.now();
      eat2(item)(listItem2(self2, item, now), node);
      item = items[index2].trail.join(lineFeed2);
      if (index2 !== length - 1) {
        item += lineFeed2;
      }
      eat2(item);
    }
    enterTop();
    exitBlockquote();
    return node;
  }
  function listItem2(ctx, value, position2) {
    var offsets = ctx.offset;
    var fn = ctx.options.pedantic ? pedanticListItem : normalListItem;
    var checked = null;
    var task;
    var indent2;
    value = fn.apply(null, arguments);
    if (ctx.options.gfm) {
      task = value.match(taskItemExpression);
      if (task) {
        indent2 = task[0].length;
        checked = task[1].toLowerCase() === lowercaseX2;
        offsets[position2.line] += indent2;
        value = value.slice(indent2);
      }
    }
    return {
      type: "listItem",
      spread: looseListItemExpression.test(value),
      checked,
      children: ctx.tokenizeBlock(value, position2)
    };
  }
  function pedanticListItem(ctx, value, position2) {
    var offsets = ctx.offset;
    var line = position2.line;
    value = value.replace(pedanticBulletExpression, replacer);
    line = position2.line;
    return value.replace(initialIndentExpression, replacer);
    function replacer($0) {
      offsets[line] = (offsets[line] || 0) + $0.length;
      line++;
      return "";
    }
  }
  function normalListItem(ctx, value, position2) {
    var offsets = ctx.offset;
    var line = position2.line;
    var max;
    var bullet2;
    var rest2;
    var lines;
    var trimmedLines;
    var index2;
    var length;
    value = value.replace(bulletExpression, replacer);
    lines = value.split(lineFeed2);
    trimmedLines = removeIndent(value, getIndent(max).indent).split(lineFeed2);
    trimmedLines[0] = rest2;
    offsets[line] = (offsets[line] || 0) + bullet2.length;
    line++;
    index2 = 0;
    length = lines.length;
    while (++index2 < length) {
      offsets[line] = (offsets[line] || 0) + lines[index2].length - trimmedLines[index2].length;
      line++;
    }
    return trimmedLines.join(lineFeed2);
    function replacer($0, $1, $2, $3, $4) {
      bullet2 = $1 + $2 + $3;
      rest2 = $4;
      if (Number($2) < 10 && bullet2.length % 2 === 1) {
        $2 = space3 + $2;
      }
      max = $1 + repeat2(space3, $2.length) + $3;
      return max + rest2;
    }
  }
  return list_1$1;
}
var headingSetext;
var hasRequiredHeadingSetext;
function requireHeadingSetext() {
  if (hasRequiredHeadingSetext) return headingSetext;
  hasRequiredHeadingSetext = 1;
  headingSetext = setextHeading;
  var lineFeed2 = "\n";
  var tab2 = "	";
  var space3 = " ";
  var equalsTo2 = "=";
  var dash2 = "-";
  var maxIndent = 3;
  var equalsToDepth = 1;
  var dashDepth = 2;
  function setextHeading(eat2, value, silent) {
    var self2 = this;
    var now = eat2.now();
    var length = value.length;
    var index2 = -1;
    var subvalue = "";
    var content;
    var queue;
    var character;
    var marker2;
    var depth;
    while (++index2 < length) {
      character = value.charAt(index2);
      if (character !== space3 || index2 >= maxIndent) {
        index2--;
        break;
      }
      subvalue += character;
    }
    content = "";
    queue = "";
    while (++index2 < length) {
      character = value.charAt(index2);
      if (character === lineFeed2) {
        index2--;
        break;
      }
      if (character === space3 || character === tab2) {
        queue += character;
      } else {
        content += queue + character;
        queue = "";
      }
    }
    now.column += subvalue.length;
    now.offset += subvalue.length;
    subvalue += content + queue;
    character = value.charAt(++index2);
    marker2 = value.charAt(++index2);
    if (character !== lineFeed2 || marker2 !== equalsTo2 && marker2 !== dash2) {
      return;
    }
    subvalue += character;
    queue = marker2;
    depth = marker2 === equalsTo2 ? equalsToDepth : dashDepth;
    while (++index2 < length) {
      character = value.charAt(index2);
      if (character !== marker2) {
        if (character !== lineFeed2) {
          return;
        }
        index2--;
        break;
      }
      queue += character;
    }
    if (silent) {
      return true;
    }
    return eat2(subvalue + queue)({
      type: "heading",
      depth,
      children: self2.tokenizeInline(content, now)
    });
  }
  return headingSetext;
}
var html$6 = {};
var hasRequiredHtml;
function requireHtml() {
  if (hasRequiredHtml) return html$6;
  hasRequiredHtml = 1;
  var attributeName2 = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
  var unquoted2 = "[^\"'=<>`\\u0000-\\u0020]+";
  var singleQuoted2 = "'[^']*'";
  var doubleQuoted2 = '"[^"]*"';
  var attributeValue2 = "(?:" + unquoted2 + "|" + singleQuoted2 + "|" + doubleQuoted2 + ")";
  var attribute2 = "(?:\\s+" + attributeName2 + "(?:\\s*=\\s*" + attributeValue2 + ")?)";
  var openTag2 = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute2 + "*\\s*\\/?>";
  var closeTag2 = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
  var comment2 = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
  var processing = "<[?].*?[?]>";
  var declaration2 = "<![A-Za-z]+\\s+[^>]*>";
  var cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
  html$6.openCloseTag = new RegExp("^(?:" + openTag2 + "|" + closeTag2 + ")");
  html$6.tag = new RegExp(
    "^(?:" + openTag2 + "|" + closeTag2 + "|" + comment2 + "|" + processing + "|" + declaration2 + "|" + cdata + ")"
  );
  return html$6;
}
var htmlBlock;
var hasRequiredHtmlBlock;
function requireHtmlBlock() {
  if (hasRequiredHtmlBlock) return htmlBlock;
  hasRequiredHtmlBlock = 1;
  var openCloseTag2 = requireHtml().openCloseTag;
  htmlBlock = blockHtml2;
  var tab2 = "	";
  var space3 = " ";
  var lineFeed2 = "\n";
  var lessThan2 = "<";
  var rawOpenExpression2 = /^<(script|pre|style)(?=(\s|>|$))/i;
  var rawCloseExpression2 = /<\/(script|pre|style)>/i;
  var commentOpenExpression2 = /^<!--/;
  var commentCloseExpression2 = /-->/;
  var instructionOpenExpression2 = /^<\?/;
  var instructionCloseExpression2 = /\?>/;
  var directiveOpenExpression2 = /^<![A-Za-z]/;
  var directiveCloseExpression2 = />/;
  var cdataOpenExpression2 = /^<!\[CDATA\[/;
  var cdataCloseExpression2 = /]]>/;
  var elementCloseExpression2 = /^$/;
  var otherElementOpenExpression2 = new RegExp(openCloseTag2.source + "\\s*$");
  function blockHtml2(eat2, value, silent) {
    var self2 = this;
    var blocks = self2.options.blocks.join("|");
    var elementOpenExpression = new RegExp(
      "^</?(" + blocks + ")(?=(\\s|/?>|$))",
      "i"
    );
    var length = value.length;
    var index2 = 0;
    var next2;
    var line;
    var offset2;
    var character;
    var count;
    var sequence2;
    var subvalue;
    var sequences = [
      [rawOpenExpression2, rawCloseExpression2, true],
      [commentOpenExpression2, commentCloseExpression2, true],
      [instructionOpenExpression2, instructionCloseExpression2, true],
      [directiveOpenExpression2, directiveCloseExpression2, true],
      [cdataOpenExpression2, cdataCloseExpression2, true],
      [elementOpenExpression, elementCloseExpression2, true],
      [otherElementOpenExpression2, elementCloseExpression2, false]
    ];
    while (index2 < length) {
      character = value.charAt(index2);
      if (character !== tab2 && character !== space3) {
        break;
      }
      index2++;
    }
    if (value.charAt(index2) !== lessThan2) {
      return;
    }
    next2 = value.indexOf(lineFeed2, index2 + 1);
    next2 = next2 === -1 ? length : next2;
    line = value.slice(index2, next2);
    offset2 = -1;
    count = sequences.length;
    while (++offset2 < count) {
      if (sequences[offset2][0].test(line)) {
        sequence2 = sequences[offset2];
        break;
      }
    }
    if (!sequence2) {
      return;
    }
    if (silent) {
      return sequence2[2];
    }
    index2 = next2;
    if (!sequence2[1].test(line)) {
      while (index2 < length) {
        next2 = value.indexOf(lineFeed2, index2 + 1);
        next2 = next2 === -1 ? length : next2;
        line = value.slice(index2 + 1, next2);
        if (sequence2[1].test(line)) {
          if (line) {
            index2 = next2;
          }
          break;
        }
        index2 = next2;
      }
    }
    subvalue = value.slice(0, index2);
    return eat2(subvalue)({ type: "html", value: subvalue });
  }
  return htmlBlock;
}
var isWhitespaceCharacter;
var hasRequiredIsWhitespaceCharacter;
function requireIsWhitespaceCharacter() {
  if (hasRequiredIsWhitespaceCharacter) return isWhitespaceCharacter;
  hasRequiredIsWhitespaceCharacter = 1;
  isWhitespaceCharacter = whitespace2;
  var fromCode = String.fromCharCode;
  var re2 = /\s/;
  function whitespace2(character) {
    return re2.test(
      typeof character === "number" ? fromCode(character) : character.charAt(0)
    );
  }
  return isWhitespaceCharacter;
}
var collapseWhiteSpace;
var hasRequiredCollapseWhiteSpace;
function requireCollapseWhiteSpace() {
  if (hasRequiredCollapseWhiteSpace) return collapseWhiteSpace;
  hasRequiredCollapseWhiteSpace = 1;
  collapseWhiteSpace = collapse;
  function collapse(value) {
    return String(value).replace(/\s+/g, " ");
  }
  return collapseWhiteSpace;
}
var normalize_1$1;
var hasRequiredNormalize;
function requireNormalize() {
  if (hasRequiredNormalize) return normalize_1$1;
  hasRequiredNormalize = 1;
  var collapseWhiteSpace2 = requireCollapseWhiteSpace();
  normalize_1$1 = normalize2;
  function normalize2(value) {
    return collapseWhiteSpace2(value).toLowerCase();
  }
  return normalize_1$1;
}
var definition_1;
var hasRequiredDefinition;
function requireDefinition() {
  if (hasRequiredDefinition) return definition_1;
  hasRequiredDefinition = 1;
  var whitespace2 = requireIsWhitespaceCharacter();
  var normalize2 = requireNormalize();
  definition_1 = definition;
  var quotationMark = '"';
  var apostrophe2 = "'";
  var backslash2 = "\\";
  var lineFeed2 = "\n";
  var tab2 = "	";
  var space3 = " ";
  var leftSquareBracket = "[";
  var rightSquareBracket = "]";
  var leftParenthesis = "(";
  var rightParenthesis = ")";
  var colon2 = ":";
  var lessThan2 = "<";
  var greaterThan = ">";
  function definition(eat2, value, silent) {
    var self2 = this;
    var commonmark = self2.options.commonmark;
    var index2 = 0;
    var length = value.length;
    var subvalue = "";
    var beforeURL;
    var beforeTitle;
    var queue;
    var character;
    var test;
    var identifier;
    var url2;
    var title;
    while (index2 < length) {
      character = value.charAt(index2);
      if (character !== space3 && character !== tab2) {
        break;
      }
      subvalue += character;
      index2++;
    }
    character = value.charAt(index2);
    if (character !== leftSquareBracket) {
      return;
    }
    index2++;
    subvalue += character;
    queue = "";
    while (index2 < length) {
      character = value.charAt(index2);
      if (character === rightSquareBracket) {
        break;
      } else if (character === backslash2) {
        queue += character;
        index2++;
        character = value.charAt(index2);
      }
      queue += character;
      index2++;
    }
    if (!queue || value.charAt(index2) !== rightSquareBracket || value.charAt(index2 + 1) !== colon2) {
      return;
    }
    identifier = queue;
    subvalue += queue + rightSquareBracket + colon2;
    index2 = subvalue.length;
    queue = "";
    while (index2 < length) {
      character = value.charAt(index2);
      if (character !== tab2 && character !== space3 && character !== lineFeed2) {
        break;
      }
      subvalue += character;
      index2++;
    }
    character = value.charAt(index2);
    queue = "";
    beforeURL = subvalue;
    if (character === lessThan2) {
      index2++;
      while (index2 < length) {
        character = value.charAt(index2);
        if (!isEnclosedURLCharacter(character)) {
          break;
        }
        queue += character;
        index2++;
      }
      character = value.charAt(index2);
      if (character === isEnclosedURLCharacter.delimiter) {
        subvalue += lessThan2 + queue + character;
        index2++;
      } else {
        if (commonmark) {
          return;
        }
        index2 -= queue.length + 1;
        queue = "";
      }
    }
    if (!queue) {
      while (index2 < length) {
        character = value.charAt(index2);
        if (!isUnclosedURLCharacter(character)) {
          break;
        }
        queue += character;
        index2++;
      }
      subvalue += queue;
    }
    if (!queue) {
      return;
    }
    url2 = queue;
    queue = "";
    while (index2 < length) {
      character = value.charAt(index2);
      if (character !== tab2 && character !== space3 && character !== lineFeed2) {
        break;
      }
      queue += character;
      index2++;
    }
    character = value.charAt(index2);
    test = null;
    if (character === quotationMark) {
      test = quotationMark;
    } else if (character === apostrophe2) {
      test = apostrophe2;
    } else if (character === leftParenthesis) {
      test = rightParenthesis;
    }
    if (!test) {
      queue = "";
      index2 = subvalue.length;
    } else if (queue) {
      subvalue += queue + character;
      index2 = subvalue.length;
      queue = "";
      while (index2 < length) {
        character = value.charAt(index2);
        if (character === test) {
          break;
        }
        if (character === lineFeed2) {
          index2++;
          character = value.charAt(index2);
          if (character === lineFeed2 || character === test) {
            return;
          }
          queue += lineFeed2;
        }
        queue += character;
        index2++;
      }
      character = value.charAt(index2);
      if (character !== test) {
        return;
      }
      beforeTitle = subvalue;
      subvalue += queue + character;
      index2++;
      title = queue;
      queue = "";
    } else {
      return;
    }
    while (index2 < length) {
      character = value.charAt(index2);
      if (character !== tab2 && character !== space3) {
        break;
      }
      subvalue += character;
      index2++;
    }
    character = value.charAt(index2);
    if (!character || character === lineFeed2) {
      if (silent) {
        return true;
      }
      beforeURL = eat2(beforeURL).test().end;
      url2 = self2.decode.raw(self2.unescape(url2), beforeURL, { nonTerminated: false });
      if (title) {
        beforeTitle = eat2(beforeTitle).test().end;
        title = self2.decode.raw(self2.unescape(title), beforeTitle);
      }
      return eat2(subvalue)({
        type: "definition",
        identifier: normalize2(identifier),
        label: identifier,
        title: title || null,
        url: url2
      });
    }
  }
  function isEnclosedURLCharacter(character) {
    return character !== greaterThan && character !== leftSquareBracket && character !== rightSquareBracket;
  }
  isEnclosedURLCharacter.delimiter = greaterThan;
  function isUnclosedURLCharacter(character) {
    return character !== leftSquareBracket && character !== rightSquareBracket && !whitespace2(character);
  }
  return definition_1;
}
var table_1$1;
var hasRequiredTable;
function requireTable() {
  if (hasRequiredTable) return table_1$1;
  hasRequiredTable = 1;
  var whitespace2 = requireIsWhitespaceCharacter();
  table_1$1 = table2;
  var tab2 = "	";
  var lineFeed2 = "\n";
  var space3 = " ";
  var dash2 = "-";
  var colon2 = ":";
  var backslash2 = "\\";
  var verticalBar = "|";
  var minColumns = 1;
  var minRows = 2;
  var left = "left";
  var center = "center";
  var right = "right";
  function table2(eat2, value, silent) {
    var self2 = this;
    var index2;
    var alignments;
    var alignment;
    var subvalue;
    var row;
    var length;
    var lines;
    var queue;
    var character;
    var hasDash;
    var align;
    var cell;
    var preamble;
    var now;
    var position2;
    var lineCount;
    var line;
    var rows;
    var table3;
    var lineIndex;
    var pipeIndex;
    var first2;
    if (!self2.options.gfm) {
      return;
    }
    index2 = 0;
    lineCount = 0;
    length = value.length + 1;
    lines = [];
    while (index2 < length) {
      lineIndex = value.indexOf(lineFeed2, index2);
      pipeIndex = value.indexOf(verticalBar, index2 + 1);
      if (lineIndex === -1) {
        lineIndex = value.length;
      }
      if (pipeIndex === -1 || pipeIndex > lineIndex) {
        if (lineCount < minRows) {
          return;
        }
        break;
      }
      lines.push(value.slice(index2, lineIndex));
      lineCount++;
      index2 = lineIndex + 1;
    }
    subvalue = lines.join(lineFeed2);
    alignments = lines.splice(1, 1)[0] || [];
    index2 = 0;
    length = alignments.length;
    lineCount--;
    alignment = false;
    align = [];
    while (index2 < length) {
      character = alignments.charAt(index2);
      if (character === verticalBar) {
        hasDash = null;
        if (alignment === false) {
          if (first2 === false) {
            return;
          }
        } else {
          align.push(alignment);
          alignment = false;
        }
        first2 = false;
      } else if (character === dash2) {
        hasDash = true;
        alignment = alignment || null;
      } else if (character === colon2) {
        if (alignment === left) {
          alignment = center;
        } else if (hasDash && alignment === null) {
          alignment = right;
        } else {
          alignment = left;
        }
      } else if (!whitespace2(character)) {
        return;
      }
      index2++;
    }
    if (alignment !== false) {
      align.push(alignment);
    }
    if (align.length < minColumns) {
      return;
    }
    if (silent) {
      return true;
    }
    position2 = -1;
    rows = [];
    table3 = eat2(subvalue).reset({ type: "table", align, children: rows });
    while (++position2 < lineCount) {
      line = lines[position2];
      row = { type: "tableRow", children: [] };
      if (position2) {
        eat2(lineFeed2);
      }
      eat2(line).reset(row, table3);
      length = line.length + 1;
      index2 = 0;
      queue = "";
      cell = "";
      preamble = true;
      while (index2 < length) {
        character = line.charAt(index2);
        if (character === tab2 || character === space3) {
          if (cell) {
            queue += character;
          } else {
            eat2(character);
          }
          index2++;
          continue;
        }
        if (character === "" || character === verticalBar) {
          if (preamble) {
            eat2(character);
          } else {
            if ((cell || character) && !preamble) {
              subvalue = cell;
              if (queue.length > 1) {
                if (character) {
                  subvalue += queue.slice(0, -1);
                  queue = queue.charAt(queue.length - 1);
                } else {
                  subvalue += queue;
                  queue = "";
                }
              }
              now = eat2.now();
              eat2(subvalue)(
                { type: "tableCell", children: self2.tokenizeInline(cell, now) },
                row
              );
            }
            eat2(queue + character);
            queue = "";
            cell = "";
          }
        } else {
          if (queue) {
            cell += queue;
            queue = "";
          }
          cell += character;
          if (character === backslash2 && index2 !== length - 2) {
            cell += line.charAt(index2 + 1);
            index2++;
          }
        }
        preamble = false;
        index2++;
      }
      if (!position2) {
        eat2(lineFeed2 + alignments);
      }
    }
    return table3;
  }
  return table_1$1;
}
var paragraph_1$1;
var hasRequiredParagraph;
function requireParagraph() {
  if (hasRequiredParagraph) return paragraph_1$1;
  hasRequiredParagraph = 1;
  var trim2 = requireTrim();
  var trimTrailingLines = requireTrimTrailingLines();
  var interrupt = requireInterrupt();
  paragraph_1$1 = paragraph2;
  var tab2 = "	";
  var lineFeed2 = "\n";
  var space3 = " ";
  var tabSize = 4;
  function paragraph2(eat2, value, silent) {
    var self2 = this;
    var settings = self2.options;
    var commonmark = settings.commonmark;
    var tokenizers = self2.blockTokenizers;
    var interruptors = self2.interruptParagraph;
    var index2 = value.indexOf(lineFeed2);
    var length = value.length;
    var position2;
    var subvalue;
    var character;
    var size;
    var now;
    while (index2 < length) {
      if (index2 === -1) {
        index2 = length;
        break;
      }
      if (value.charAt(index2 + 1) === lineFeed2) {
        break;
      }
      if (commonmark) {
        size = 0;
        position2 = index2 + 1;
        while (position2 < length) {
          character = value.charAt(position2);
          if (character === tab2) {
            size = tabSize;
            break;
          } else if (character === space3) {
            size++;
          } else {
            break;
          }
          position2++;
        }
        if (size >= tabSize && character !== lineFeed2) {
          index2 = value.indexOf(lineFeed2, index2 + 1);
          continue;
        }
      }
      subvalue = value.slice(index2 + 1);
      if (interrupt(interruptors, tokenizers, self2, [eat2, subvalue, true])) {
        break;
      }
      position2 = index2;
      index2 = value.indexOf(lineFeed2, index2 + 1);
      if (index2 !== -1 && trim2(value.slice(position2, index2)) === "") {
        index2 = position2;
        break;
      }
    }
    subvalue = value.slice(0, index2);
    if (silent) {
      return true;
    }
    now = eat2.now();
    subvalue = trimTrailingLines(subvalue);
    return eat2(subvalue)({
      type: "paragraph",
      children: self2.tokenizeInline(subvalue, now)
    });
  }
  return paragraph_1$1;
}
var _escape$1;
var hasRequired_escape$1;
function require_escape$1() {
  if (hasRequired_escape$1) return _escape$1;
  hasRequired_escape$1 = 1;
  _escape$1 = locate;
  function locate(value, fromIndex) {
    return value.indexOf("\\", fromIndex);
  }
  return _escape$1;
}
var _escape;
var hasRequired_escape;
function require_escape() {
  if (hasRequired_escape) return _escape;
  hasRequired_escape = 1;
  var locate = require_escape$1();
  _escape = escape2;
  escape2.locator = locate;
  var lineFeed2 = "\n";
  var backslash2 = "\\";
  function escape2(eat2, value, silent) {
    var self2 = this;
    var character;
    var node;
    if (value.charAt(0) === backslash2) {
      character = value.charAt(1);
      if (self2.escape.indexOf(character) !== -1) {
        if (silent) {
          return true;
        }
        if (character === lineFeed2) {
          node = { type: "break" };
        } else {
          node = { type: "text", value: character };
        }
        return eat2(backslash2 + character)(node);
      }
    }
  }
  return _escape;
}
var tag2;
var hasRequiredTag;
function requireTag() {
  if (hasRequiredTag) return tag2;
  hasRequiredTag = 1;
  tag2 = locate;
  function locate(value, fromIndex) {
    return value.indexOf("<", fromIndex);
  }
  return tag2;
}
var autoLink_1;
var hasRequiredAutoLink;
function requireAutoLink() {
  if (hasRequiredAutoLink) return autoLink_1;
  hasRequiredAutoLink = 1;
  var whitespace2 = requireIsWhitespaceCharacter();
  var decode3 = parseEntities_1;
  var locate = requireTag();
  autoLink_1 = autoLink;
  autoLink.locator = locate;
  autoLink.notInLink = true;
  var lessThan2 = "<";
  var greaterThan = ">";
  var atSign = "@";
  var slash = "/";
  var mailto = "mailto:";
  var mailtoLength = mailto.length;
  function autoLink(eat2, value, silent) {
    var self2 = this;
    var subvalue = "";
    var length = value.length;
    var index2 = 0;
    var queue = "";
    var hasAtCharacter = false;
    var link2 = "";
    var character;
    var now;
    var content;
    var tokenizers;
    var exit;
    if (value.charAt(0) !== lessThan2) {
      return;
    }
    index2++;
    subvalue = lessThan2;
    while (index2 < length) {
      character = value.charAt(index2);
      if (whitespace2(character) || character === greaterThan || character === atSign || character === ":" && value.charAt(index2 + 1) === slash) {
        break;
      }
      queue += character;
      index2++;
    }
    if (!queue) {
      return;
    }
    link2 += queue;
    queue = "";
    character = value.charAt(index2);
    link2 += character;
    index2++;
    if (character === atSign) {
      hasAtCharacter = true;
    } else {
      if (character !== ":" || value.charAt(index2 + 1) !== slash) {
        return;
      }
      link2 += slash;
      index2++;
    }
    while (index2 < length) {
      character = value.charAt(index2);
      if (whitespace2(character) || character === greaterThan) {
        break;
      }
      queue += character;
      index2++;
    }
    character = value.charAt(index2);
    if (!queue || character !== greaterThan) {
      return;
    }
    if (silent) {
      return true;
    }
    link2 += queue;
    content = link2;
    subvalue += link2 + character;
    now = eat2.now();
    now.column++;
    now.offset++;
    if (hasAtCharacter) {
      if (link2.slice(0, mailtoLength).toLowerCase() === mailto) {
        content = content.slice(mailtoLength);
        now.column += mailtoLength;
        now.offset += mailtoLength;
      } else {
        link2 = mailto + link2;
      }
    }
    tokenizers = self2.inlineTokenizers;
    self2.inlineTokenizers = { text: tokenizers.text };
    exit = self2.enterLink();
    content = self2.tokenizeInline(content, now);
    self2.inlineTokenizers = tokenizers;
    exit();
    return eat2(subvalue)({
      type: "link",
      title: null,
      url: decode3(link2, { nonTerminated: false }),
      children: content
    });
  }
  return autoLink_1;
}
var ccount_1;
var hasRequiredCcount;
function requireCcount() {
  if (hasRequiredCcount) return ccount_1;
  hasRequiredCcount = 1;
  ccount_1 = ccount;
  function ccount(value, character) {
    var val = String(value);
    var count = 0;
    var index2;
    if (typeof character !== "string" || character.length !== 1) {
      throw new Error("Expected character");
    }
    index2 = val.indexOf(character);
    while (index2 !== -1) {
      count++;
      index2 = val.indexOf(character, index2 + 1);
    }
    return count;
  }
  return ccount_1;
}
var url;
var hasRequiredUrl$1;
function requireUrl$1() {
  if (hasRequiredUrl$1) return url;
  hasRequiredUrl$1 = 1;
  url = locate;
  var values = ["www.", "http://", "https://"];
  function locate(value, fromIndex) {
    var min = -1;
    var index2;
    var length;
    var position2;
    if (!this.options.gfm) {
      return min;
    }
    length = values.length;
    index2 = -1;
    while (++index2 < length) {
      position2 = value.indexOf(values[index2], fromIndex);
      if (position2 !== -1 && (min === -1 || position2 < min)) {
        min = position2;
      }
    }
    return min;
  }
  return url;
}
var url_1;
var hasRequiredUrl;
function requireUrl() {
  if (hasRequiredUrl) return url_1;
  hasRequiredUrl = 1;
  var ccount = requireCcount();
  var decode3 = parseEntities_1;
  var decimal2 = requireIsDecimal();
  var alphabetical2 = requireIsAlphabetical();
  var whitespace2 = requireIsWhitespaceCharacter();
  var locate = requireUrl$1();
  url_1 = url2;
  url2.locator = locate;
  url2.notInLink = true;
  var exclamationMark = 33;
  var ampersand2 = 38;
  var rightParenthesis = 41;
  var asterisk = 42;
  var comma3 = 44;
  var dash2 = 45;
  var dot2 = 46;
  var colon2 = 58;
  var semicolon3 = 59;
  var questionMark = 63;
  var lessThan2 = 60;
  var underscore = 95;
  var tilde2 = 126;
  var leftParenthesisCharacter = "(";
  var rightParenthesisCharacter = ")";
  function url2(eat2, value, silent) {
    var self2 = this;
    var gfm = self2.options.gfm;
    var tokenizers = self2.inlineTokenizers;
    var length = value.length;
    var previousDot = -1;
    var protocolless = false;
    var dots;
    var lastTwoPartsStart;
    var start2;
    var index2;
    var pathStart;
    var path2;
    var code2;
    var end2;
    var leftCount;
    var rightCount;
    var content;
    var children;
    var url3;
    var exit;
    if (!gfm) {
      return;
    }
    if (value.slice(0, 4) === "www.") {
      protocolless = true;
      index2 = 4;
    } else if (value.slice(0, 7).toLowerCase() === "http://") {
      index2 = 7;
    } else if (value.slice(0, 8).toLowerCase() === "https://") {
      index2 = 8;
    } else {
      return;
    }
    previousDot = index2 - 1;
    start2 = index2;
    dots = [];
    while (index2 < length) {
      code2 = value.charCodeAt(index2);
      if (code2 === dot2) {
        if (previousDot === index2 - 1) {
          break;
        }
        dots.push(index2);
        previousDot = index2;
        index2++;
        continue;
      }
      if (decimal2(code2) || alphabetical2(code2) || code2 === dash2 || code2 === underscore) {
        index2++;
        continue;
      }
      break;
    }
    if (code2 === dot2) {
      dots.pop();
      index2--;
    }
    if (dots[0] === void 0) {
      return;
    }
    lastTwoPartsStart = dots.length < 2 ? start2 : dots[dots.length - 2] + 1;
    if (value.slice(lastTwoPartsStart, index2).indexOf("_") !== -1) {
      return;
    }
    if (silent) {
      return true;
    }
    end2 = index2;
    pathStart = index2;
    while (index2 < length) {
      code2 = value.charCodeAt(index2);
      if (whitespace2(code2) || code2 === lessThan2) {
        break;
      }
      index2++;
      if (code2 === exclamationMark || code2 === asterisk || code2 === comma3 || code2 === dot2 || code2 === colon2 || code2 === questionMark || code2 === underscore || code2 === tilde2) ;
      else {
        end2 = index2;
      }
    }
    index2 = end2;
    if (value.charCodeAt(index2 - 1) === rightParenthesis) {
      path2 = value.slice(pathStart, index2);
      leftCount = ccount(path2, leftParenthesisCharacter);
      rightCount = ccount(path2, rightParenthesisCharacter);
      while (rightCount > leftCount) {
        index2 = pathStart + path2.lastIndexOf(rightParenthesisCharacter);
        path2 = value.slice(pathStart, index2);
        rightCount--;
      }
    }
    if (value.charCodeAt(index2 - 1) === semicolon3) {
      index2--;
      if (alphabetical2(value.charCodeAt(index2 - 1))) {
        end2 = index2 - 2;
        while (alphabetical2(value.charCodeAt(end2))) {
          end2--;
        }
        if (value.charCodeAt(end2) === ampersand2) {
          index2 = end2;
        }
      }
    }
    content = value.slice(0, index2);
    url3 = decode3(content, { nonTerminated: false });
    if (protocolless) {
      url3 = "http://" + url3;
    }
    exit = self2.enterLink();
    self2.inlineTokenizers = { text: tokenizers.text };
    children = self2.tokenizeInline(content, eat2.now());
    self2.inlineTokenizers = tokenizers;
    exit();
    return eat2(content)({ type: "link", title: null, url: url3, children });
  }
  return url_1;
}
var email;
var hasRequiredEmail$1;
function requireEmail$1() {
  if (hasRequiredEmail$1) return email;
  hasRequiredEmail$1 = 1;
  var decimal2 = requireIsDecimal();
  var alphabetical2 = requireIsAlphabetical();
  var plusSign = 43;
  var dash2 = 45;
  var dot2 = 46;
  var underscore = 95;
  email = locate;
  function locate(value, fromIndex) {
    var self2 = this;
    var at2;
    var position2;
    if (!this.options.gfm) {
      return -1;
    }
    at2 = value.indexOf("@", fromIndex);
    if (at2 === -1) {
      return -1;
    }
    position2 = at2;
    if (position2 === fromIndex || !isGfmAtext(value.charCodeAt(position2 - 1))) {
      return locate.call(self2, value, at2 + 1);
    }
    while (position2 > fromIndex && isGfmAtext(value.charCodeAt(position2 - 1))) {
      position2--;
    }
    return position2;
  }
  function isGfmAtext(code2) {
    return decimal2(code2) || alphabetical2(code2) || code2 === plusSign || code2 === dash2 || code2 === dot2 || code2 === underscore;
  }
  return email;
}
var email_1;
var hasRequiredEmail;
function requireEmail() {
  if (hasRequiredEmail) return email_1;
  hasRequiredEmail = 1;
  var decode3 = parseEntities_1;
  var decimal2 = requireIsDecimal();
  var alphabetical2 = requireIsAlphabetical();
  var locate = requireEmail$1();
  email_1 = email2;
  email2.locator = locate;
  email2.notInLink = true;
  var plusSign = 43;
  var dash2 = 45;
  var dot2 = 46;
  var atSign = 64;
  var underscore = 95;
  function email2(eat2, value, silent) {
    var self2 = this;
    var gfm = self2.options.gfm;
    var tokenizers = self2.inlineTokenizers;
    var index2 = 0;
    var length = value.length;
    var firstDot = -1;
    var code2;
    var content;
    var children;
    var exit;
    if (!gfm) {
      return;
    }
    code2 = value.charCodeAt(index2);
    while (decimal2(code2) || alphabetical2(code2) || code2 === plusSign || code2 === dash2 || code2 === dot2 || code2 === underscore) {
      code2 = value.charCodeAt(++index2);
    }
    if (index2 === 0) {
      return;
    }
    if (code2 !== atSign) {
      return;
    }
    index2++;
    while (index2 < length) {
      code2 = value.charCodeAt(index2);
      if (decimal2(code2) || alphabetical2(code2) || code2 === dash2 || code2 === dot2 || code2 === underscore) {
        index2++;
        if (firstDot === -1 && code2 === dot2) {
          firstDot = index2;
        }
        continue;
      }
      break;
    }
    if (firstDot === -1 || firstDot === index2 || code2 === dash2 || code2 === underscore) {
      return;
    }
    if (code2 === dot2) {
      index2--;
    }
    content = value.slice(0, index2);
    if (silent) {
      return true;
    }
    exit = self2.enterLink();
    self2.inlineTokenizers = { text: tokenizers.text };
    children = self2.tokenizeInline(content, eat2.now());
    self2.inlineTokenizers = tokenizers;
    exit();
    return eat2(content)({
      type: "link",
      title: null,
      url: "mailto:" + decode3(content, { nonTerminated: false }),
      children
    });
  }
  return email_1;
}
var htmlInline;
var hasRequiredHtmlInline;
function requireHtmlInline() {
  if (hasRequiredHtmlInline) return htmlInline;
  hasRequiredHtmlInline = 1;
  var alphabetical2 = requireIsAlphabetical();
  var locate = requireTag();
  var tag3 = requireHtml().tag;
  htmlInline = inlineHTML;
  inlineHTML.locator = locate;
  var lessThan2 = "<";
  var questionMark = "?";
  var exclamationMark = "!";
  var slash = "/";
  var htmlLinkOpenExpression = /^<a /i;
  var htmlLinkCloseExpression = /^<\/a>/i;
  function inlineHTML(eat2, value, silent) {
    var self2 = this;
    var length = value.length;
    var character;
    var subvalue;
    if (value.charAt(0) !== lessThan2 || length < 3) {
      return;
    }
    character = value.charAt(1);
    if (!alphabetical2(character) && character !== questionMark && character !== exclamationMark && character !== slash) {
      return;
    }
    subvalue = value.match(tag3);
    if (!subvalue) {
      return;
    }
    if (silent) {
      return true;
    }
    subvalue = subvalue[0];
    if (!self2.inLink && htmlLinkOpenExpression.test(subvalue)) {
      self2.inLink = true;
    } else if (self2.inLink && htmlLinkCloseExpression.test(subvalue)) {
      self2.inLink = false;
    }
    return eat2(subvalue)({ type: "html", value: subvalue });
  }
  return htmlInline;
}
var link$1;
var hasRequiredLink$1;
function requireLink$1() {
  if (hasRequiredLink$1) return link$1;
  hasRequiredLink$1 = 1;
  link$1 = locate;
  function locate(value, fromIndex) {
    var link2 = value.indexOf("[", fromIndex);
    var image2 = value.indexOf("![", fromIndex);
    if (image2 === -1) {
      return link2;
    }
    return link2 < image2 ? link2 : image2;
  }
  return link$1;
}
var link_1$1;
var hasRequiredLink;
function requireLink() {
  if (hasRequiredLink) return link_1$1;
  hasRequiredLink = 1;
  var whitespace2 = requireIsWhitespaceCharacter();
  var locate = requireLink$1();
  link_1$1 = link2;
  link2.locator = locate;
  var lineFeed2 = "\n";
  var exclamationMark = "!";
  var quotationMark = '"';
  var apostrophe2 = "'";
  var leftParenthesis = "(";
  var rightParenthesis = ")";
  var lessThan2 = "<";
  var greaterThan = ">";
  var leftSquareBracket = "[";
  var backslash2 = "\\";
  var rightSquareBracket = "]";
  var graveAccent = "`";
  function link2(eat2, value, silent) {
    var self2 = this;
    var subvalue = "";
    var index2 = 0;
    var character = value.charAt(0);
    var pedantic = self2.options.pedantic;
    var commonmark = self2.options.commonmark;
    var gfm = self2.options.gfm;
    var closed;
    var count;
    var opening2;
    var beforeURL;
    var beforeTitle;
    var subqueue;
    var hasMarker;
    var isImage;
    var content;
    var marker2;
    var length;
    var title;
    var depth;
    var queue;
    var url2;
    var now;
    var exit;
    var node;
    if (character === exclamationMark) {
      isImage = true;
      subvalue = character;
      character = value.charAt(++index2);
    }
    if (character !== leftSquareBracket) {
      return;
    }
    if (!isImage && self2.inLink) {
      return;
    }
    subvalue += character;
    queue = "";
    index2++;
    length = value.length;
    now = eat2.now();
    depth = 0;
    now.column += index2;
    now.offset += index2;
    while (index2 < length) {
      character = value.charAt(index2);
      subqueue = character;
      if (character === graveAccent) {
        count = 1;
        while (value.charAt(index2 + 1) === graveAccent) {
          subqueue += character;
          index2++;
          count++;
        }
        if (!opening2) {
          opening2 = count;
        } else if (count >= opening2) {
          opening2 = 0;
        }
      } else if (character === backslash2) {
        index2++;
        subqueue += value.charAt(index2);
      } else if ((!opening2 || gfm) && character === leftSquareBracket) {
        depth++;
      } else if ((!opening2 || gfm) && character === rightSquareBracket) {
        if (depth) {
          depth--;
        } else {
          if (value.charAt(index2 + 1) !== leftParenthesis) {
            return;
          }
          subqueue += leftParenthesis;
          closed = true;
          index2++;
          break;
        }
      }
      queue += subqueue;
      subqueue = "";
      index2++;
    }
    if (!closed) {
      return;
    }
    content = queue;
    subvalue += queue + subqueue;
    index2++;
    while (index2 < length) {
      character = value.charAt(index2);
      if (!whitespace2(character)) {
        break;
      }
      subvalue += character;
      index2++;
    }
    character = value.charAt(index2);
    queue = "";
    beforeURL = subvalue;
    if (character === lessThan2) {
      index2++;
      beforeURL += lessThan2;
      while (index2 < length) {
        character = value.charAt(index2);
        if (character === greaterThan) {
          break;
        }
        if (commonmark && character === lineFeed2) {
          return;
        }
        queue += character;
        index2++;
      }
      if (value.charAt(index2) !== greaterThan) {
        return;
      }
      subvalue += lessThan2 + queue + greaterThan;
      url2 = queue;
      index2++;
    } else {
      character = null;
      subqueue = "";
      while (index2 < length) {
        character = value.charAt(index2);
        if (subqueue && (character === quotationMark || character === apostrophe2 || commonmark && character === leftParenthesis)) {
          break;
        }
        if (whitespace2(character)) {
          if (!pedantic) {
            break;
          }
          subqueue += character;
        } else {
          if (character === leftParenthesis) {
            depth++;
          } else if (character === rightParenthesis) {
            if (depth === 0) {
              break;
            }
            depth--;
          }
          queue += subqueue;
          subqueue = "";
          if (character === backslash2) {
            queue += backslash2;
            character = value.charAt(++index2);
          }
          queue += character;
        }
        index2++;
      }
      subvalue += queue;
      url2 = queue;
      index2 = subvalue.length;
    }
    queue = "";
    while (index2 < length) {
      character = value.charAt(index2);
      if (!whitespace2(character)) {
        break;
      }
      queue += character;
      index2++;
    }
    character = value.charAt(index2);
    subvalue += queue;
    if (queue && (character === quotationMark || character === apostrophe2 || commonmark && character === leftParenthesis)) {
      index2++;
      subvalue += character;
      queue = "";
      marker2 = character === leftParenthesis ? rightParenthesis : character;
      beforeTitle = subvalue;
      if (commonmark) {
        while (index2 < length) {
          character = value.charAt(index2);
          if (character === marker2) {
            break;
          }
          if (character === backslash2) {
            queue += backslash2;
            character = value.charAt(++index2);
          }
          index2++;
          queue += character;
        }
        character = value.charAt(index2);
        if (character !== marker2) {
          return;
        }
        title = queue;
        subvalue += queue + character;
        index2++;
        while (index2 < length) {
          character = value.charAt(index2);
          if (!whitespace2(character)) {
            break;
          }
          subvalue += character;
          index2++;
        }
      } else {
        subqueue = "";
        while (index2 < length) {
          character = value.charAt(index2);
          if (character === marker2) {
            if (hasMarker) {
              queue += marker2 + subqueue;
              subqueue = "";
            }
            hasMarker = true;
          } else if (!hasMarker) {
            queue += character;
          } else if (character === rightParenthesis) {
            subvalue += queue + marker2 + subqueue;
            title = queue;
            break;
          } else if (whitespace2(character)) {
            subqueue += character;
          } else {
            queue += marker2 + subqueue + character;
            subqueue = "";
            hasMarker = false;
          }
          index2++;
        }
      }
    }
    if (value.charAt(index2) !== rightParenthesis) {
      return;
    }
    if (silent) {
      return true;
    }
    subvalue += rightParenthesis;
    url2 = self2.decode.raw(self2.unescape(url2), eat2(beforeURL).test().end, {
      nonTerminated: false
    });
    if (title) {
      beforeTitle = eat2(beforeTitle).test().end;
      title = self2.decode.raw(self2.unescape(title), beforeTitle);
    }
    node = {
      type: isImage ? "image" : "link",
      title: title || null,
      url: url2
    };
    if (isImage) {
      node.alt = self2.decode.raw(self2.unescape(content), now) || null;
    } else {
      exit = self2.enterLink();
      node.children = self2.tokenizeInline(content, now);
      exit();
    }
    return eat2(subvalue)(node);
  }
  return link_1$1;
}
var reference_1;
var hasRequiredReference;
function requireReference() {
  if (hasRequiredReference) return reference_1;
  hasRequiredReference = 1;
  var whitespace2 = requireIsWhitespaceCharacter();
  var locate = requireLink$1();
  var normalize2 = requireNormalize();
  reference_1 = reference;
  reference.locator = locate;
  var link2 = "link";
  var image2 = "image";
  var shortcut = "shortcut";
  var collapsed = "collapsed";
  var full = "full";
  var exclamationMark = "!";
  var leftSquareBracket = "[";
  var backslash2 = "\\";
  var rightSquareBracket = "]";
  function reference(eat2, value, silent) {
    var self2 = this;
    var commonmark = self2.options.commonmark;
    var character = value.charAt(0);
    var index2 = 0;
    var length = value.length;
    var subvalue = "";
    var intro = "";
    var type2 = link2;
    var referenceType = shortcut;
    var content;
    var identifier;
    var now;
    var node;
    var exit;
    var queue;
    var bracketed;
    var depth;
    if (character === exclamationMark) {
      type2 = image2;
      intro = character;
      character = value.charAt(++index2);
    }
    if (character !== leftSquareBracket) {
      return;
    }
    index2++;
    intro += character;
    queue = "";
    depth = 0;
    while (index2 < length) {
      character = value.charAt(index2);
      if (character === leftSquareBracket) {
        bracketed = true;
        depth++;
      } else if (character === rightSquareBracket) {
        if (!depth) {
          break;
        }
        depth--;
      }
      if (character === backslash2) {
        queue += backslash2;
        character = value.charAt(++index2);
      }
      queue += character;
      index2++;
    }
    subvalue = queue;
    content = queue;
    character = value.charAt(index2);
    if (character !== rightSquareBracket) {
      return;
    }
    index2++;
    subvalue += character;
    queue = "";
    if (!commonmark) {
      while (index2 < length) {
        character = value.charAt(index2);
        if (!whitespace2(character)) {
          break;
        }
        queue += character;
        index2++;
      }
    }
    character = value.charAt(index2);
    if (character === leftSquareBracket) {
      identifier = "";
      queue += character;
      index2++;
      while (index2 < length) {
        character = value.charAt(index2);
        if (character === leftSquareBracket || character === rightSquareBracket) {
          break;
        }
        if (character === backslash2) {
          identifier += backslash2;
          character = value.charAt(++index2);
        }
        identifier += character;
        index2++;
      }
      character = value.charAt(index2);
      if (character === rightSquareBracket) {
        referenceType = identifier ? full : collapsed;
        queue += identifier + character;
        index2++;
      } else {
        identifier = "";
      }
      subvalue += queue;
      queue = "";
    } else {
      if (!content) {
        return;
      }
      identifier = content;
    }
    if (referenceType !== full && bracketed) {
      return;
    }
    subvalue = intro + subvalue;
    if (type2 === link2 && self2.inLink) {
      return null;
    }
    if (silent) {
      return true;
    }
    now = eat2.now();
    now.column += intro.length;
    now.offset += intro.length;
    identifier = referenceType === full ? identifier : content;
    node = {
      type: type2 + "Reference",
      identifier: normalize2(identifier),
      label: identifier,
      referenceType
    };
    if (type2 === link2) {
      exit = self2.enterLink();
      node.children = self2.tokenizeInline(content, now);
      exit();
    } else {
      node.alt = self2.decode.raw(self2.unescape(content), now) || null;
    }
    return eat2(subvalue)(node);
  }
  return reference_1;
}
var strong$1;
var hasRequiredStrong$1;
function requireStrong$1() {
  if (hasRequiredStrong$1) return strong$1;
  hasRequiredStrong$1 = 1;
  strong$1 = locate;
  function locate(value, fromIndex) {
    var asterisk = value.indexOf("**", fromIndex);
    var underscore = value.indexOf("__", fromIndex);
    if (underscore === -1) {
      return asterisk;
    }
    if (asterisk === -1) {
      return underscore;
    }
    return underscore < asterisk ? underscore : asterisk;
  }
  return strong$1;
}
var strong_1$1;
var hasRequiredStrong;
function requireStrong() {
  if (hasRequiredStrong) return strong_1$1;
  hasRequiredStrong = 1;
  var trim2 = requireTrim();
  var whitespace2 = requireIsWhitespaceCharacter();
  var locate = requireStrong$1();
  strong_1$1 = strong2;
  strong2.locator = locate;
  var backslash2 = "\\";
  var asterisk = "*";
  var underscore = "_";
  function strong2(eat2, value, silent) {
    var self2 = this;
    var index2 = 0;
    var character = value.charAt(index2);
    var now;
    var pedantic;
    var marker2;
    var queue;
    var subvalue;
    var length;
    var previous;
    if (character !== asterisk && character !== underscore || value.charAt(++index2) !== character) {
      return;
    }
    pedantic = self2.options.pedantic;
    marker2 = character;
    subvalue = marker2 + marker2;
    length = value.length;
    index2++;
    queue = "";
    character = "";
    if (pedantic && whitespace2(value.charAt(index2))) {
      return;
    }
    while (index2 < length) {
      previous = character;
      character = value.charAt(index2);
      if (character === marker2 && value.charAt(index2 + 1) === marker2 && (!pedantic || !whitespace2(previous))) {
        character = value.charAt(index2 + 2);
        if (character !== marker2) {
          if (!trim2(queue)) {
            return;
          }
          if (silent) {
            return true;
          }
          now = eat2.now();
          now.column += 2;
          now.offset += 2;
          return eat2(subvalue + queue + subvalue)({
            type: "strong",
            children: self2.tokenizeInline(queue, now)
          });
        }
      }
      if (!pedantic && character === backslash2) {
        queue += character;
        character = value.charAt(++index2);
      }
      queue += character;
      index2++;
    }
  }
  return strong_1$1;
}
var isWordCharacter;
var hasRequiredIsWordCharacter;
function requireIsWordCharacter() {
  if (hasRequiredIsWordCharacter) return isWordCharacter;
  hasRequiredIsWordCharacter = 1;
  isWordCharacter = wordCharacter;
  var fromCode = String.fromCharCode;
  var re2 = /\w/;
  function wordCharacter(character) {
    return re2.test(
      typeof character === "number" ? fromCode(character) : character.charAt(0)
    );
  }
  return isWordCharacter;
}
var emphasis$1;
var hasRequiredEmphasis$1;
function requireEmphasis$1() {
  if (hasRequiredEmphasis$1) return emphasis$1;
  hasRequiredEmphasis$1 = 1;
  emphasis$1 = locate;
  function locate(value, fromIndex) {
    var asterisk = value.indexOf("*", fromIndex);
    var underscore = value.indexOf("_", fromIndex);
    if (underscore === -1) {
      return asterisk;
    }
    if (asterisk === -1) {
      return underscore;
    }
    return underscore < asterisk ? underscore : asterisk;
  }
  return emphasis$1;
}
var emphasis_1$1;
var hasRequiredEmphasis;
function requireEmphasis() {
  if (hasRequiredEmphasis) return emphasis_1$1;
  hasRequiredEmphasis = 1;
  var trim2 = requireTrim();
  var word2 = requireIsWordCharacter();
  var whitespace2 = requireIsWhitespaceCharacter();
  var locate = requireEmphasis$1();
  emphasis_1$1 = emphasis2;
  emphasis2.locator = locate;
  var asterisk = "*";
  var underscore = "_";
  var backslash2 = "\\";
  function emphasis2(eat2, value, silent) {
    var self2 = this;
    var index2 = 0;
    var character = value.charAt(index2);
    var now;
    var pedantic;
    var marker2;
    var queue;
    var subvalue;
    var length;
    var previous;
    if (character !== asterisk && character !== underscore) {
      return;
    }
    pedantic = self2.options.pedantic;
    subvalue = character;
    marker2 = character;
    length = value.length;
    index2++;
    queue = "";
    character = "";
    if (pedantic && whitespace2(value.charAt(index2))) {
      return;
    }
    while (index2 < length) {
      previous = character;
      character = value.charAt(index2);
      if (character === marker2 && (!pedantic || !whitespace2(previous))) {
        character = value.charAt(++index2);
        if (character !== marker2) {
          if (!trim2(queue) || previous === marker2) {
            return;
          }
          if (!pedantic && marker2 === underscore && word2(character)) {
            queue += marker2;
            continue;
          }
          if (silent) {
            return true;
          }
          now = eat2.now();
          now.column++;
          now.offset++;
          return eat2(subvalue + queue + marker2)({
            type: "emphasis",
            children: self2.tokenizeInline(queue, now)
          });
        }
        queue += marker2;
      }
      if (!pedantic && character === backslash2) {
        queue += character;
        character = value.charAt(++index2);
      }
      queue += character;
      index2++;
    }
  }
  return emphasis_1$1;
}
var _delete$2;
var hasRequired_delete$1;
function require_delete$1() {
  if (hasRequired_delete$1) return _delete$2;
  hasRequired_delete$1 = 1;
  _delete$2 = locate;
  function locate(value, fromIndex) {
    return value.indexOf("~~", fromIndex);
  }
  return _delete$2;
}
var _delete$1;
var hasRequired_delete;
function require_delete() {
  if (hasRequired_delete) return _delete$1;
  hasRequired_delete = 1;
  var whitespace2 = requireIsWhitespaceCharacter();
  var locate = require_delete$1();
  _delete$1 = strikethrough2;
  strikethrough2.locator = locate;
  var tilde2 = "~";
  var fence2 = "~~";
  function strikethrough2(eat2, value, silent) {
    var self2 = this;
    var character = "";
    var previous = "";
    var preceding = "";
    var subvalue = "";
    var index2;
    var length;
    var now;
    if (!self2.options.gfm || value.charAt(0) !== tilde2 || value.charAt(1) !== tilde2 || whitespace2(value.charAt(2))) {
      return;
    }
    index2 = 1;
    length = value.length;
    now = eat2.now();
    now.column += 2;
    now.offset += 2;
    while (++index2 < length) {
      character = value.charAt(index2);
      if (character === tilde2 && previous === tilde2 && (!preceding || !whitespace2(preceding))) {
        if (silent) {
          return true;
        }
        return eat2(fence2 + subvalue + fence2)({
          type: "delete",
          children: self2.tokenizeInline(subvalue, now)
        });
      }
      subvalue += previous;
      preceding = previous;
      previous = character;
    }
  }
  return _delete$1;
}
var codeInline$1;
var hasRequiredCodeInline$1;
function requireCodeInline$1() {
  if (hasRequiredCodeInline$1) return codeInline$1;
  hasRequiredCodeInline$1 = 1;
  codeInline$1 = locate;
  function locate(value, fromIndex) {
    return value.indexOf("`", fromIndex);
  }
  return codeInline$1;
}
var codeInline;
var hasRequiredCodeInline;
function requireCodeInline() {
  if (hasRequiredCodeInline) return codeInline;
  hasRequiredCodeInline = 1;
  var locate = requireCodeInline$1();
  codeInline = inlineCode2;
  inlineCode2.locator = locate;
  var lineFeed2 = 10;
  var space3 = 32;
  var graveAccent = 96;
  function inlineCode2(eat2, value, silent) {
    var length = value.length;
    var index2 = 0;
    var openingFenceEnd;
    var closingFenceStart;
    var closingFenceEnd;
    var code2;
    var next2;
    var found;
    while (index2 < length) {
      if (value.charCodeAt(index2) !== graveAccent) {
        break;
      }
      index2++;
    }
    if (index2 === 0 || index2 === length) {
      return;
    }
    openingFenceEnd = index2;
    next2 = value.charCodeAt(index2);
    while (index2 < length) {
      code2 = next2;
      next2 = value.charCodeAt(index2 + 1);
      if (code2 === graveAccent) {
        if (closingFenceStart === void 0) {
          closingFenceStart = index2;
        }
        closingFenceEnd = index2 + 1;
        if (next2 !== graveAccent && closingFenceEnd - closingFenceStart === openingFenceEnd) {
          found = true;
          break;
        }
      } else if (closingFenceStart !== void 0) {
        closingFenceStart = void 0;
        closingFenceEnd = void 0;
      }
      index2++;
    }
    if (!found) {
      return;
    }
    if (silent) {
      return true;
    }
    index2 = openingFenceEnd;
    length = closingFenceStart;
    code2 = value.charCodeAt(index2);
    next2 = value.charCodeAt(length - 1);
    found = false;
    if (length - index2 > 2 && (code2 === space3 || code2 === lineFeed2) && (next2 === space3 || next2 === lineFeed2)) {
      index2++;
      length--;
      while (index2 < length) {
        code2 = value.charCodeAt(index2);
        if (code2 !== space3 && code2 !== lineFeed2) {
          found = true;
          break;
        }
        index2++;
      }
      if (found === true) {
        openingFenceEnd++;
        closingFenceStart--;
      }
    }
    return eat2(value.slice(0, closingFenceEnd))({
      type: "inlineCode",
      value: value.slice(openingFenceEnd, closingFenceStart)
    });
  }
  return codeInline;
}
var _break$2;
var hasRequired_break$1;
function require_break$1() {
  if (hasRequired_break$1) return _break$2;
  hasRequired_break$1 = 1;
  _break$2 = locate;
  function locate(value, fromIndex) {
    var index2 = value.indexOf("\n", fromIndex);
    while (index2 > fromIndex) {
      if (value.charAt(index2 - 1) !== " ") {
        break;
      }
      index2--;
    }
    return index2;
  }
  return _break$2;
}
var _break$1;
var hasRequired_break;
function require_break() {
  if (hasRequired_break) return _break$1;
  hasRequired_break = 1;
  var locate = require_break$1();
  _break$1 = hardBreak2;
  hardBreak2.locator = locate;
  var space3 = " ";
  var lineFeed2 = "\n";
  var minBreakLength = 2;
  function hardBreak2(eat2, value, silent) {
    var length = value.length;
    var index2 = -1;
    var queue = "";
    var character;
    while (++index2 < length) {
      character = value.charAt(index2);
      if (character === lineFeed2) {
        if (index2 < minBreakLength) {
          return;
        }
        if (silent) {
          return true;
        }
        queue += character;
        return eat2(queue)({ type: "break" });
      }
      if (character !== space3) {
        return;
      }
      queue += character;
    }
  }
  return _break$1;
}
var text_1$2;
var hasRequiredText;
function requireText() {
  if (hasRequiredText) return text_1$2;
  hasRequiredText = 1;
  text_1$2 = text3;
  function text3(eat2, value, silent) {
    var self2 = this;
    var methods;
    var tokenizers;
    var index2;
    var length;
    var subvalue;
    var position2;
    var tokenizer4;
    var name2;
    var min;
    var now;
    if (silent) {
      return true;
    }
    methods = self2.inlineMethods;
    length = methods.length;
    tokenizers = self2.inlineTokenizers;
    index2 = -1;
    min = value.length;
    while (++index2 < length) {
      name2 = methods[index2];
      if (name2 === "text" || !tokenizers[name2]) {
        continue;
      }
      tokenizer4 = tokenizers[name2].locator;
      if (!tokenizer4) {
        eat2.file.fail("Missing locator: `" + name2 + "`");
      }
      position2 = tokenizer4.call(self2, value, 1);
      if (position2 !== -1 && position2 < min) {
        min = position2;
      }
    }
    subvalue = value.slice(0, min);
    now = eat2.now();
    self2.decode(subvalue, now, handler);
    function handler(content, position3, source2) {
      eat2(source2 || content)({ type: "text", value: content });
    }
  }
  return text_1$2;
}
var xtend$2 = immutable;
var toggle = stateToggle;
var vfileLocation = vfileLocation$1;
var unescape2 = _unescape;
var decode2 = decode$1;
var tokenizer$2 = tokenizer$3;
var parser$1 = Parser$1;
function Parser$1(doc, file) {
  this.file = file;
  this.offset = {};
  this.options = xtend$2(this.options);
  this.setOptions({});
  this.inList = false;
  this.inBlock = false;
  this.inLink = false;
  this.atStart = true;
  this.toOffset = vfileLocation(file).toOffset;
  this.unescape = unescape2(this, "escape");
  this.decode = decode2(this);
}
var proto$3 = Parser$1.prototype;
proto$3.setOptions = requireSetOptions();
proto$3.parse = requireParse();
proto$3.options = requireDefaults();
proto$3.exitStart = toggle("atStart", true);
proto$3.enterList = toggle("inList", false);
proto$3.enterLink = toggle("inLink", false);
proto$3.enterBlock = toggle("inBlock", false);
proto$3.interruptParagraph = [
  ["thematicBreak"],
  ["list"],
  ["atxHeading"],
  ["fencedCode"],
  ["blockquote"],
  ["html"],
  ["setextHeading", { commonmark: false }],
  ["definition", { commonmark: false }]
];
proto$3.interruptList = [
  ["atxHeading", { pedantic: false }],
  ["fencedCode", { pedantic: false }],
  ["thematicBreak", { pedantic: false }],
  ["definition", { commonmark: false }]
];
proto$3.interruptBlockquote = [
  ["indentedCode", { commonmark: true }],
  ["fencedCode", { commonmark: true }],
  ["atxHeading", { commonmark: true }],
  ["setextHeading", { commonmark: true }],
  ["thematicBreak", { commonmark: true }],
  ["html", { commonmark: true }],
  ["list", { commonmark: true }],
  ["definition", { commonmark: false }]
];
proto$3.blockTokenizers = {
  blankLine: requireBlankLine(),
  indentedCode: requireCodeIndented(),
  fencedCode: requireCodeFenced(),
  blockquote: requireBlockquote(),
  atxHeading: requireHeadingAtx(),
  thematicBreak: requireThematicBreak(),
  list: requireList(),
  setextHeading: requireHeadingSetext(),
  html: requireHtmlBlock(),
  definition: requireDefinition(),
  table: requireTable(),
  paragraph: requireParagraph()
};
proto$3.inlineTokenizers = {
  escape: require_escape(),
  autoLink: requireAutoLink(),
  url: requireUrl(),
  email: requireEmail(),
  html: requireHtmlInline(),
  link: requireLink(),
  reference: requireReference(),
  strong: requireStrong(),
  emphasis: requireEmphasis(),
  deletion: require_delete(),
  code: requireCodeInline(),
  break: require_break(),
  text: requireText()
};
proto$3.blockMethods = keys$1(proto$3.blockTokenizers);
proto$3.inlineMethods = keys$1(proto$3.inlineTokenizers);
proto$3.tokenizeBlock = tokenizer$2("block");
proto$3.tokenizeInline = tokenizer$2("inline");
proto$3.tokenizeFactory = tokenizer$2;
function keys$1(value) {
  var result = [];
  var key2;
  for (key2 in value) {
    result.push(key2);
  }
  return result;
}
var unherit$1 = unherit_1;
var xtend$1 = immutable;
var Parser4 = parser$1;
var remarkParse = parse$5;
parse$5.Parser = Parser4;
function parse$5(options2) {
  var settings = this.data("settings");
  var Local = unherit$1(Parser4);
  Local.prototype.options = xtend$1(Local.prototype.options, settings, options2);
  this.Parser = Local;
}
var markdown = getDefaultExportFromCjs(remarkParse);
var visit$4 = unistUtilVisit;
var mdastUtilDefinitions$1 = getDefinitionFactory$1;
var own$7 = {}.hasOwnProperty;
function getDefinitionFactory$1(node, options2) {
  return getterFactory$1(gather$1(node, options2));
}
function gather$1(node, options2) {
  var cache2 = {};
  if (!node || !node.type) {
    throw new Error("mdast-util-definitions expected node");
  }
  visit$4(node, "definition", options2 && options2.commonmark ? commonmark : normal);
  return cache2;
  function commonmark(definition) {
    var id2 = normalise$1(definition.identifier);
    if (!own$7.call(cache2, id2)) {
      cache2[id2] = definition;
    }
  }
  function normal(definition) {
    cache2[normalise$1(definition.identifier)] = definition;
  }
}
function getterFactory$1(cache2) {
  return getter;
  function getter(identifier) {
    var id2 = identifier && normalise$1(identifier);
    return id2 && own$7.call(cache2, id2) ? cache2[id2] : null;
  }
}
function normalise$1(identifier) {
  return identifier.toUpperCase();
}
var spaceSeparatedTokens = {};
spaceSeparatedTokens.parse = parse$4;
spaceSeparatedTokens.stringify = stringify$4;
var empty$2 = "";
var space$2 = " ";
var whiteSpace$3 = /[ \t\n\r\f]+/g;
function parse$4(value) {
  var input = String(value || empty$2).trim();
  return input === empty$2 ? [] : input.split(whiteSpace$3);
}
function stringify$4(values) {
  return values.join(space$2).trim();
}
var isAbsoluteUrl = (url2) => {
  if (typeof url2 !== "string") {
    throw new TypeError(`Expected a \`string\`, got \`${typeof url2}\``);
  }
  if (/^[a-zA-Z]:\\/.test(url2)) {
    return false;
  }
  return /^[a-zA-Z][a-zA-Z\d+\-.]*:/.test(url2);
};
var visit$3 = unistUtilVisit;
var definitions$1 = mdastUtilDefinitions$1;
var spaceSeparated$3 = spaceSeparatedTokens.parse;
var absolute = isAbsoluteUrl;
var extend$2 = extend$5;
var remarkExternalLinks = externalLinks;
var defaultTarget = "_blank";
var defaultRel = ["nofollow", "noopener", "noreferrer"];
var defaultProtocols = ["http", "https"];
function externalLinks(options2) {
  var settings = options2 || {};
  var target2 = settings.target;
  var rel = settings.rel;
  var protocols = settings.protocols || defaultProtocols;
  var content = settings.content;
  var contentProperties = settings.contentProperties || {};
  if (typeof rel === "string") {
    rel = spaceSeparated$3(rel);
  }
  if (content && typeof content === "object" && !("length" in content)) {
    content = [content];
  }
  return transform2;
  function transform2(tree) {
    var definition = definitions$1(tree);
    visit$3(tree, ["link", "linkReference"], visitor);
    function visitor(node) {
      var ctx = node.type === "link" ? node : definition(node.identifier);
      var protocol;
      var data3;
      var props;
      if (!ctx) return;
      protocol = ctx.url.slice(0, ctx.url.indexOf(":"));
      if (absolute(ctx.url) && protocols.indexOf(protocol) !== -1) {
        data3 = node.data || (node.data = {});
        props = data3.hProperties || (data3.hProperties = {});
        if (target2 !== false) {
          props.target = target2 || defaultTarget;
        }
        if (rel !== false) {
          props.rel = (rel || defaultRel).concat();
        }
        if (content) {
          node.children.push({
            type: "fragment",
            children: [],
            data: {
              hName: "span",
              hProperties: extend$2(true, contentProperties),
              hChildren: extend$2(true, content)
            }
          });
        }
      }
    }
  }
}
var external = getDefaultExportFromCjs(remarkExternalLinks);
var format = { exports: {} };
(function(module) {
  (function() {
    var namespace;
    {
      namespace = module.exports = format2;
    }
    namespace.format = format2;
    namespace.vsprintf = vsprintf;
    if (typeof console !== "undefined" && typeof console.log === "function") {
      namespace.printf = printf;
    }
    function printf() {
      console.log(format2.apply(null, arguments));
    }
    function vsprintf(fmt, replacements2) {
      return format2.apply(null, [fmt].concat(replacements2));
    }
    function format2(fmt) {
      var argIndex = 1, args = [].slice.call(arguments), i = 0, n = fmt.length, result = "", c, escaped = false, arg, tmp, leadingZero = false, precision, nextArg = function() {
        return args[argIndex++];
      }, slurpNumber = function() {
        var digits = "";
        while (/\d/.test(fmt[i])) {
          digits += fmt[i++];
          c = fmt[i];
        }
        return digits.length > 0 ? parseInt(digits) : null;
      };
      for (; i < n; ++i) {
        c = fmt[i];
        if (escaped) {
          escaped = false;
          if (c == ".") {
            leadingZero = false;
            c = fmt[++i];
          } else if (c == "0" && fmt[i + 1] == ".") {
            leadingZero = true;
            i += 2;
            c = fmt[i];
          } else {
            leadingZero = true;
          }
          precision = slurpNumber();
          switch (c) {
            case "b":
              result += parseInt(nextArg(), 10).toString(2);
              break;
            case "c":
              arg = nextArg();
              if (typeof arg === "string" || arg instanceof String)
                result += arg;
              else
                result += String.fromCharCode(parseInt(arg, 10));
              break;
            case "d":
              result += parseInt(nextArg(), 10);
              break;
            case "f":
              tmp = String(parseFloat(nextArg()).toFixed(precision || 6));
              result += leadingZero ? tmp : tmp.replace(/^0/, "");
              break;
            case "j":
              result += JSON.stringify(nextArg());
              break;
            case "o":
              result += "0" + parseInt(nextArg(), 10).toString(8);
              break;
            case "s":
              result += nextArg();
              break;
            case "x":
              result += "0x" + parseInt(nextArg(), 10).toString(16);
              break;
            case "X":
              result += "0x" + parseInt(nextArg(), 10).toString(16).toUpperCase();
              break;
            default:
              result += c;
              break;
          }
        } else if (c === "%") {
          escaped = true;
        } else {
          result += c;
        }
      }
      return result;
    }
  })();
})(format);
var formatExports = format.exports;
var formatter = formatExports;
var fault$1 = create$9(Error);
var fault_1 = fault$1;
fault$1.eval = create$9(EvalError);
fault$1.range = create$9(RangeError);
fault$1.reference = create$9(ReferenceError);
fault$1.syntax = create$9(SyntaxError);
fault$1.type = create$9(TypeError);
fault$1.uri = create$9(URIError);
fault$1.create = create$9;
function create$9(EConstructor) {
  FormattedError.displayName = EConstructor.displayName || EConstructor.name;
  return FormattedError;
  function FormattedError(format2) {
    if (format2) {
      format2 = formatter.apply(null, arguments);
    }
    return new EConstructor(format2);
  }
}
var fault = fault_1;
var matters_1 = matters$1;
var own$6 = {}.hasOwnProperty;
var markers = {
  yaml: "-",
  toml: "+"
};
function matters$1(options2) {
  var results = [];
  var index2 = -1;
  var length;
  if (typeof options2 === "string" || !("length" in options2)) {
    options2 = [options2];
  }
  length = options2.length;
  while (++index2 < length) {
    results[index2] = matter(options2[index2]);
  }
  return results;
}
function matter(option2) {
  var result = option2;
  if (typeof result === "string") {
    if (!own$6.call(markers, result)) {
      throw fault("Missing matter definition for `%s`", result);
    }
    result = { type: result, marker: markers[result] };
  } else if (typeof result !== "object") {
    throw fault("Expected matter to be an object, not `%j`", result);
  }
  if (!own$6.call(result, "type")) {
    throw fault("Missing `type` in matter `%j`", result);
  }
  if (!own$6.call(result, "fence") && !own$6.call(result, "marker")) {
    throw fault("Missing `marker` or `fence` in matter `%j`", result);
  }
  return result;
}
var fence_1 = fence$2;
function fence$2(matter2, prop3) {
  var marker2;
  if (matter2.marker) {
    marker2 = pick(matter2.marker, prop3);
    return marker2 + marker2 + marker2;
  }
  return pick(matter2.fence, prop3);
}
function pick(schema2, prop3) {
  return typeof schema2 === "string" ? schema2 : schema2[prop3];
}
var fence$1 = fence_1;
var parse$3 = create$8;
function create$8(matter2) {
  var name2 = matter2.type + "FrontMatter";
  var open2 = fence$1(matter2, "open");
  var close2 = fence$1(matter2, "close");
  var newline3 = "\n";
  var anywhere = matter2.anywhere;
  frontmatter2.displayName = name2;
  frontmatter2.onlyAtStart = typeof anywhere === "boolean" ? !anywhere : true;
  return [name2, frontmatter2];
  function frontmatter2(eat2, value, silent) {
    var index2 = open2.length;
    var offset2;
    if (value.slice(0, index2) !== open2 || value.charAt(index2) !== newline3) {
      return;
    }
    offset2 = value.indexOf(close2, index2);
    while (offset2 !== -1 && value.charAt(offset2 - 1) !== newline3) {
      index2 = offset2 + close2.length;
      offset2 = value.indexOf(close2, index2);
    }
    if (offset2 !== -1) {
      if (silent) {
        return true;
      }
      return eat2(value.slice(0, offset2 + close2.length))({
        type: matter2.type,
        value: value.slice(open2.length + 1, offset2 - 1)
      });
    }
  }
}
var fence = fence_1;
var compile$1 = create$7;
function create$7(matter2) {
  var type2 = matter2.type;
  var open2 = fence(matter2, "open");
  var close2 = fence(matter2, "close");
  frontmatter2.displayName = type2 + "FrontMatter";
  return [type2, frontmatter2];
  function frontmatter2(node) {
    return open2 + (node.value ? "\n" + node.value : "") + "\n" + close2;
  }
}
var matters = matters_1;
var parse$2 = parse$3;
var compile = compile$1;
var remarkFrontmatter = frontmatter;
function frontmatter(options2) {
  var parser2 = this.Parser;
  var compiler2 = this.Compiler;
  var config = matters(options2 || ["yaml"]);
  if (isRemarkParser(parser2)) {
    attachParser(parser2, config);
  }
  if (isRemarkCompiler(compiler2)) {
    attachCompiler(compiler2, config);
  }
}
function attachParser(parser2, matters2) {
  var proto2 = parser2.prototype;
  var tokenizers = wrap$6(parse$2, matters2);
  var names = [];
  var key2;
  for (key2 in tokenizers) {
    names.push(key2);
  }
  proto2.blockMethods = names.concat(proto2.blockMethods);
  proto2.blockTokenizers = Object.assign({}, tokenizers, proto2.blockTokenizers);
}
function attachCompiler(compiler2, matters2) {
  var proto2 = compiler2.prototype;
  proto2.visitors = Object.assign({}, wrap$6(compile, matters2), proto2.visitors);
}
function wrap$6(func, matters2) {
  var result = {};
  var length = matters2.length;
  var index2 = -1;
  var tuple;
  while (++index2 < length) {
    tuple = func(matters2[index2]);
    result[tuple[0]] = tuple[1];
  }
  return result;
}
function isRemarkParser(parser2) {
  return Boolean(parser2 && parser2.prototype && parser2.prototype.blockTokenizers);
}
function isRemarkCompiler(compiler2) {
  return Boolean(compiler2 && compiler2.prototype && compiler2.prototype.visitors);
}
var extract_frontmatter = getDefaultExportFromCjs(remarkFrontmatter);
var unistBuilder = u$b;
function u$b(type2, props, value) {
  var node;
  if ((value === null || value === void 0) && (typeof props !== "object" || Array.isArray(props))) {
    value = props;
    props = {};
  }
  node = Object.assign({ type: String(type2) }, props);
  if (Array.isArray(value)) {
    node.children = value;
  } else if (value !== null && value !== void 0) {
    node.value = String(value);
  }
  return node;
}
var start = factory$1("start");
var end = factory$1("end");
var unistUtilPosition = position$2;
position$2.start = start;
position$2.end = end;
function position$2(node) {
  return { start: start(node), end: end(node) };
}
function factory$1(type2) {
  point2.displayName = type2;
  return point2;
  function point2(node) {
    var point3 = node && node.position && node.position[type2] || {};
    return {
      line: point3.line || null,
      column: point3.column || null,
      offset: isNaN(point3.offset) ? null : point3.offset
    };
  }
}
var unistUtilGenerated = generated$1;
function generated$1(node) {
  return !node || !node.position || !node.position.start || !node.position.start.line || !node.position.start.column || !node.position.end || !node.position.end.line || !node.position.end.column;
}
var visit$2 = unistUtilVisit;
var mdastUtilDefinitions = getDefinitionFactory;
var own$5 = {}.hasOwnProperty;
function getDefinitionFactory(node, options2) {
  return getterFactory(gather(node, options2));
}
function gather(node, options2) {
  var cache2 = {};
  if (!node || !node.type) {
    throw new Error("mdast-util-definitions expected node");
  }
  visit$2(node, "definition", options2 && options2.commonmark ? commonmark : normal);
  return cache2;
  function commonmark(definition) {
    var id2 = normalise(definition.identifier);
    if (!own$5.call(cache2, id2)) {
      cache2[id2] = definition;
    }
  }
  function normal(definition) {
    cache2[normalise(definition.identifier)] = definition;
  }
}
function getterFactory(cache2) {
  return getter;
  function getter(identifier) {
    var id2 = identifier && normalise(identifier);
    return id2 && own$5.call(cache2, id2) ? cache2[id2] : null;
  }
}
function normalise(identifier) {
  return identifier.toUpperCase();
}
var all_1$1;
var hasRequiredAll$1;
function requireAll$1() {
  if (hasRequiredAll$1) return all_1$1;
  hasRequiredAll$1 = 1;
  all_1$1 = all2;
  var one2 = requireOne$1();
  function all2(h, parent) {
    var nodes = parent.children || [];
    var length = nodes.length;
    var values = [];
    var index2 = -1;
    var result;
    var head2;
    while (++index2 < length) {
      result = one2(h, nodes[index2], parent);
      if (result) {
        if (index2 && nodes[index2 - 1].type === "break") {
          if (result.value) {
            result.value = result.value.replace(/^\s+/, "");
          }
          head2 = result.children && result.children[0];
          if (head2 && head2.value) {
            head2.value = head2.value.replace(/^\s+/, "");
          }
        }
        values = values.concat(result);
      }
    }
    return values;
  }
  return all_1$1;
}
var one_1$1;
var hasRequiredOne$1;
function requireOne$1() {
  if (hasRequiredOne$1) return one_1$1;
  hasRequiredOne$1 = 1;
  one_1$1 = one2;
  var u2 = unistBuilder;
  var all2 = requireAll$1();
  var own2 = {}.hasOwnProperty;
  function unknown(h, node) {
    if (text3(node)) {
      return h.augment(node, u2("text", node.value));
    }
    return h(node, "div", all2(h, node));
  }
  function one2(h, node, parent) {
    var type2 = node && node.type;
    var fn = own2.call(h.handlers, type2) ? h.handlers[type2] : h.unknownHandler;
    if (!type2) {
      throw new Error("Expected node, got `" + node + "`");
    }
    return (typeof fn === "function" ? fn : unknown)(h, node, parent);
  }
  function text3(node) {
    var data3 = node.data || {};
    if (own2.call(data3, "hName") || own2.call(data3, "hProperties") || own2.call(data3, "hChildren")) {
      return false;
    }
    return "value" in node;
  }
  return one_1$1;
}
var thematicBreak_1 = thematicBreak$1;
function thematicBreak$1(h, node) {
  return h(node, "hr");
}
var wrap_1 = wrap$5;
var u$a = unistBuilder;
function wrap$5(nodes, loose) {
  var result = [];
  var index2 = -1;
  var length = nodes.length;
  if (loose) {
    result.push(u$a("text", "\n"));
  }
  while (++index2 < length) {
    if (index2) {
      result.push(u$a("text", "\n"));
    }
    result.push(nodes[index2]);
  }
  if (loose && nodes.length !== 0) {
    result.push(u$a("text", "\n"));
  }
  return result;
}
var list_1 = list$1;
var wrap$4 = wrap_1;
var all$d = requireAll$1();
function list$1(h, node) {
  var props = {};
  var name2 = node.ordered ? "ol" : "ul";
  var items;
  var index2 = -1;
  var length;
  if (typeof node.start === "number" && node.start !== 1) {
    props.start = node.start;
  }
  items = all$d(h, node);
  length = items.length;
  while (++index2 < length) {
    if (items[index2].properties.className && items[index2].properties.className.indexOf("task-list-item") !== -1) {
      props.className = ["contains-task-list"];
      break;
    }
  }
  return h(node, name2, props, wrap$4(items, true));
}
var footer$1 = generateFootnotes;
var thematicBreak = thematicBreak_1;
var list3 = list_1;
var wrap$3 = wrap_1;
function generateFootnotes(h) {
  var footnoteById = h.footnoteById;
  var footnoteOrder = h.footnoteOrder;
  var length = footnoteOrder.length;
  var index2 = -1;
  var listItems = [];
  var def;
  var backReference;
  var content;
  var tail;
  while (++index2 < length) {
    def = footnoteById[footnoteOrder[index2].toUpperCase()];
    if (!def) {
      continue;
    }
    content = def.children.concat();
    tail = content[content.length - 1];
    backReference = {
      type: "link",
      url: "#fnref-" + def.identifier,
      data: { hProperties: { className: ["footnote-backref"] } },
      children: [{ type: "text", value: "" }]
    };
    if (!tail || tail.type !== "paragraph") {
      tail = { type: "paragraph", children: [] };
      content.push(tail);
    }
    tail.children.push(backReference);
    listItems.push({
      type: "listItem",
      data: { hProperties: { id: "fn-" + def.identifier } },
      children: content,
      position: def.position
    });
  }
  if (listItems.length === 0) {
    return null;
  }
  return h(
    null,
    "div",
    { className: ["footnotes"] },
    wrap$3(
      [
        thematicBreak(h),
        list3(h, { type: "list", ordered: true, children: listItems })
      ],
      true
    )
  );
}
var blockquote_1 = blockquote;
var wrap$2 = wrap_1;
var all$c = requireAll$1();
function blockquote(h, node) {
  return h(node, "blockquote", wrap$2(all$c(h, node), true));
}
var _break = hardBreak;
var u$9 = unistBuilder;
function hardBreak(h, node) {
  return [h(node, "br"), u$9("text", "\n")];
}
var code_1 = code;
var u$8 = unistBuilder;
function code(h, node) {
  var value = node.value ? node.value + "\n" : "";
  var lang2 = node.lang && node.lang.match(/^[^ \t]+(?=[ \t]|$)/);
  var props = {};
  if (lang2) {
    props.className = ["language-" + lang2];
  }
  return h(node.position, "pre", [h(node, "code", props, [u$8("text", value)])]);
}
var _delete = strikethrough;
var all$b = requireAll$1();
function strikethrough(h, node) {
  return h(node, "del", all$b(h, node));
}
var emphasis_1 = emphasis;
var all$a = requireAll$1();
function emphasis(h, node) {
  return h(node, "em", all$a(h, node));
}
var footnoteReference_1 = footnoteReference$1;
var u$7 = unistBuilder;
function footnoteReference$1(h, node) {
  var footnoteOrder = h.footnoteOrder;
  var identifier = String(node.identifier);
  if (footnoteOrder.indexOf(identifier) === -1) {
    footnoteOrder.push(identifier);
  }
  return h(node.position, "sup", { id: "fnref-" + identifier }, [
    h(node, "a", { href: "#fn-" + identifier, className: ["footnote-ref"] }, [
      u$7("text", node.label || identifier)
    ])
  ]);
}
var footnote_1 = footnote;
var footnoteReference = footnoteReference_1;
function footnote(h, node) {
  var footnoteById = h.footnoteById;
  var footnoteOrder = h.footnoteOrder;
  var identifier = 1;
  while (identifier in footnoteById) {
    identifier++;
  }
  identifier = String(identifier);
  footnoteOrder.push(identifier);
  footnoteById[identifier] = {
    type: "footnoteDefinition",
    identifier,
    children: [{ type: "paragraph", children: node.children }],
    position: node.position
  };
  return footnoteReference(h, {
    type: "footnoteReference",
    identifier,
    position: node.position
  });
}
var heading_1 = heading;
var all$9 = requireAll$1();
function heading(h, node) {
  return h(node, "h" + node.depth, all$9(h, node));
}
var html_1$1 = html$5;
var u$6 = unistBuilder;
function html$5(h, node) {
  return h.dangerous ? h.augment(node, u$6("raw", node.value)) : null;
}
var encodeCache = {};
function getEncodeCache(exclude) {
  var i, ch, cache2 = encodeCache[exclude];
  if (cache2) {
    return cache2;
  }
  cache2 = encodeCache[exclude] = [];
  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);
    if (/^[0-9a-z]$/i.test(ch)) {
      cache2.push(ch);
    } else {
      cache2.push("%" + ("0" + i.toString(16).toUpperCase()).slice(-2));
    }
  }
  for (i = 0; i < exclude.length; i++) {
    cache2[exclude.charCodeAt(i)] = exclude[i];
  }
  return cache2;
}
function encode$1(string2, exclude, keepEscaped) {
  var i, l2, code2, nextCode, cache2, result = "";
  if (typeof exclude !== "string") {
    keepEscaped = exclude;
    exclude = encode$1.defaultChars;
  }
  if (typeof keepEscaped === "undefined") {
    keepEscaped = true;
  }
  cache2 = getEncodeCache(exclude);
  for (i = 0, l2 = string2.length; i < l2; i++) {
    code2 = string2.charCodeAt(i);
    if (keepEscaped && code2 === 37 && i + 2 < l2) {
      if (/^[0-9a-f]{2}$/i.test(string2.slice(i + 1, i + 3))) {
        result += string2.slice(i, i + 3);
        i += 2;
        continue;
      }
    }
    if (code2 < 128) {
      result += cache2[code2];
      continue;
    }
    if (code2 >= 55296 && code2 <= 57343) {
      if (code2 >= 55296 && code2 <= 56319 && i + 1 < l2) {
        nextCode = string2.charCodeAt(i + 1);
        if (nextCode >= 56320 && nextCode <= 57343) {
          result += encodeURIComponent(string2[i] + string2[i + 1]);
          i++;
          continue;
        }
      }
      result += "%EF%BF%BD";
      continue;
    }
    result += encodeURIComponent(string2[i]);
  }
  return result;
}
encode$1.defaultChars = ";/?:@&=+$,-_.!~*'()#";
encode$1.componentChars = "-_.!~*'()";
var encode_1 = encode$1;
var revert_1 = revert$2;
var u$5 = unistBuilder;
var all$8 = requireAll$1();
function revert$2(h, node) {
  var subtype = node.referenceType;
  var suffix = "]";
  var contents;
  var head2;
  var tail;
  if (subtype === "collapsed") {
    suffix += "[]";
  } else if (subtype === "full") {
    suffix += "[" + (node.label || node.identifier) + "]";
  }
  if (node.type === "imageReference") {
    return u$5("text", "![" + node.alt + suffix);
  }
  contents = all$8(h, node);
  head2 = contents[0];
  if (head2 && head2.type === "text") {
    head2.value = "[" + head2.value;
  } else {
    contents.unshift(u$5("text", "["));
  }
  tail = contents[contents.length - 1];
  if (tail && tail.type === "text") {
    tail.value += suffix;
  } else {
    contents.push(u$5("text", suffix));
  }
  return contents;
}
var imageReference_1 = imageReference;
var normalize$6 = encode_1;
var revert$1 = revert_1;
function imageReference(h, node) {
  var def = h.definition(node.identifier);
  var props;
  if (!def) {
    return revert$1(h, node);
  }
  props = { src: normalize$6(def.url || ""), alt: node.alt };
  if (def.title !== null && def.title !== void 0) {
    props.title = def.title;
  }
  return h(node, "img", props);
}
var normalize$5 = encode_1;
var image_1 = image$1;
function image$1(h, node) {
  var props = { src: normalize$5(node.url), alt: node.alt };
  if (node.title !== null && node.title !== void 0) {
    props.title = node.title;
  }
  return h(node, "img", props);
}
var inlineCode_1 = inlineCode;
var u$4 = unistBuilder;
function inlineCode(h, node) {
  var value = node.value.replace(/\r?\n|\r/g, " ");
  return h(node, "code", [u$4("text", value)]);
}
var linkReference_1 = linkReference;
var normalize$4 = encode_1;
var revert = revert_1;
var all$7 = requireAll$1();
function linkReference(h, node) {
  var def = h.definition(node.identifier);
  var props;
  if (!def) {
    return revert(h, node);
  }
  props = { href: normalize$4(def.url || "") };
  if (def.title !== null && def.title !== void 0) {
    props.title = def.title;
  }
  return h(node, "a", props, all$7(h, node));
}
var normalize$3 = encode_1;
var all$6 = requireAll$1();
var link_1 = link;
function link(h, node) {
  var props = { href: normalize$3(node.url) };
  if (node.title !== null && node.title !== void 0) {
    props.title = node.title;
  }
  return h(node, "a", props, all$6(h, node));
}
var listItem_1 = listItem$1;
var u$3 = unistBuilder;
var all$5 = requireAll$1();
function listItem$1(h, node, parent) {
  var result = all$5(h, node);
  var head2 = result[0];
  var loose = parent ? listLoose(parent) : listItemLoose(node);
  var props = {};
  var wrapped = [];
  var length;
  var index2;
  var child;
  if (typeof node.checked === "boolean") {
    if (!head2 || head2.tagName !== "p") {
      head2 = h(null, "p", []);
      result.unshift(head2);
    }
    if (head2.children.length !== 0) {
      head2.children.unshift(u$3("text", " "));
    }
    head2.children.unshift(
      h(null, "input", {
        type: "checkbox",
        checked: node.checked,
        disabled: true
      })
    );
    props.className = ["task-list-item"];
  }
  length = result.length;
  index2 = -1;
  while (++index2 < length) {
    child = result[index2];
    if (loose || index2 !== 0 || child.tagName !== "p") {
      wrapped.push(u$3("text", "\n"));
    }
    if (child.tagName === "p" && !loose) {
      wrapped = wrapped.concat(child.children);
    } else {
      wrapped.push(child);
    }
  }
  if (length && (loose || child.tagName !== "p")) {
    wrapped.push(u$3("text", "\n"));
  }
  return h(node, "li", props, wrapped);
}
function listLoose(node) {
  var loose = node.spread;
  var children = node.children;
  var length = children.length;
  var index2 = -1;
  while (!loose && ++index2 < length) {
    loose = listItemLoose(children[index2]);
  }
  return loose;
}
function listItemLoose(node) {
  var spread2 = node.spread;
  return spread2 === void 0 || spread2 === null ? node.children.length > 1 : spread2;
}
var paragraph_1 = paragraph;
var all$4 = requireAll$1();
function paragraph(h, node) {
  return h(node, "p", all$4(h, node));
}
var root_1 = root;
var u$2 = unistBuilder;
var wrap$1 = wrap_1;
var all$3 = requireAll$1();
function root(h, node) {
  return h.augment(node, u$2("root", wrap$1(all$3(h, node))));
}
var strong_1 = strong;
var all$2 = requireAll$1();
function strong(h, node) {
  return h(node, "strong", all$2(h, node));
}
var table_1 = table;
var position$1 = unistUtilPosition;
var wrap = wrap_1;
var all$1 = requireAll$1();
function table(h, node) {
  var rows = node.children;
  var index2 = rows.length;
  var align = node.align || [];
  var alignLength = align.length;
  var result = [];
  var pos;
  var row;
  var out;
  var name2;
  var cell;
  while (index2--) {
    row = rows[index2].children;
    name2 = index2 === 0 ? "th" : "td";
    pos = alignLength || row.length;
    out = [];
    while (pos--) {
      cell = row[pos];
      out[pos] = h(cell, name2, { align: align[pos] }, cell ? all$1(h, cell) : []);
    }
    result[index2] = h(rows[index2], "tr", wrap(out, true));
  }
  return h(
    node,
    "table",
    wrap(
      [h(result[0].position, "thead", wrap([result[0]], true))].concat(
        result[1] ? h(
          {
            start: position$1.start(result[1]),
            end: position$1.end(result[result.length - 1])
          },
          "tbody",
          wrap(result.slice(1), true)
        ) : []
      ),
      true
    )
  );
}
var text_1$1 = text$1;
var u$1 = unistBuilder;
function text$1(h, node) {
  return h.augment(
    node,
    u$1("text", String(node.value).replace(/[ \t]*(\r?\n|\r)[ \t]*/g, "$1"))
  );
}
var handlers$1 = {
  blockquote: blockquote_1,
  break: _break,
  code: code_1,
  delete: _delete,
  emphasis: emphasis_1,
  footnoteReference: footnoteReference_1,
  footnote: footnote_1,
  heading: heading_1,
  html: html_1$1,
  imageReference: imageReference_1,
  image: image_1,
  inlineCode: inlineCode_1,
  linkReference: linkReference_1,
  link: link_1,
  listItem: listItem_1,
  list: list_1,
  paragraph: paragraph_1,
  root: root_1,
  strong: strong_1,
  table: table_1,
  text: text_1$1,
  thematicBreak: thematicBreak_1,
  toml: ignore,
  yaml: ignore,
  definition: ignore,
  footnoteDefinition: ignore
};
function ignore() {
  return null;
}
var lib$2 = toHast;
var u = unistBuilder;
var visit$1 = unistUtilVisit;
var position = unistUtilPosition;
var generated = unistUtilGenerated;
var definitions = mdastUtilDefinitions;
var one$2 = requireOne$1();
var footer = footer$1;
var handlers = handlers$1;
var own$4 = {}.hasOwnProperty;
var deprecationWarningIssued = false;
function factory(tree, options2) {
  var settings = options2 || {};
  if (settings.allowDangerousHTML !== void 0 && !deprecationWarningIssued) {
    deprecationWarningIssued = true;
    console.warn(
      "mdast-util-to-hast: deprecation: `allowDangerousHTML` is nonstandard, use `allowDangerousHtml` instead"
    );
  }
  var dangerous2 = settings.allowDangerousHtml || settings.allowDangerousHTML;
  var footnoteById = {};
  h.dangerous = dangerous2;
  h.definition = definitions(tree, settings);
  h.footnoteById = footnoteById;
  h.footnoteOrder = [];
  h.augment = augment;
  h.handlers = Object.assign({}, handlers, settings.handlers);
  h.unknownHandler = settings.unknownHandler;
  visit$1(tree, "footnoteDefinition", onfootnotedefinition);
  return h;
  function augment(left, right) {
    var data3;
    var ctx;
    if (left && "data" in left) {
      data3 = left.data;
      if (right.type === "element" && data3.hName) {
        right.tagName = data3.hName;
      }
      if (right.type === "element" && data3.hProperties) {
        right.properties = Object.assign({}, right.properties, data3.hProperties);
      }
      if (right.children && data3.hChildren) {
        right.children = data3.hChildren;
      }
    }
    ctx = left && left.position ? left : { position: left };
    if (!generated(ctx)) {
      right.position = {
        start: position.start(ctx),
        end: position.end(ctx)
      };
    }
    return right;
  }
  function h(node, tagName, props, children) {
    if ((children === void 0 || children === null) && typeof props === "object" && "length" in props) {
      children = props;
      props = {};
    }
    return augment(node, {
      type: "element",
      tagName,
      properties: props || {},
      children: children || []
    });
  }
  function onfootnotedefinition(definition) {
    var id2 = String(definition.identifier).toUpperCase();
    if (!own$4.call(footnoteById, id2)) {
      footnoteById[id2] = definition;
    }
  }
}
function toHast(tree, options2) {
  var h = factory(tree, options2);
  var node = one$2(h, tree);
  var foot = footer(h);
  if (foot) {
    node.children = node.children.concat(u("text", "\n"), foot);
  }
  return node;
}
var mdastUtilToHast = lib$2;
var mdast2hast = mdastUtilToHast;
var remarkRehype = remark2rehype;
function remark2rehype(destination, options2) {
  if (destination && !destination.process) {
    options2 = destination;
    destination = null;
  }
  return destination ? bridge(destination, options2) : mutate(options2);
}
function bridge(destination, options2) {
  return transformer;
  function transformer(node, file, next2) {
    destination.run(mdast2hast(node, options2), file, done);
    function done(err) {
      next2(err);
    }
  }
}
function mutate(options2) {
  return transformer;
  function transformer(node) {
    return mdast2hast(node, options2);
  }
}
var remark2rehype$1 = getDefaultExportFromCjs(remarkRehype);
var schema$1 = Schema$8;
var proto$2 = Schema$8.prototype;
proto$2.space = null;
proto$2.normal = {};
proto$2.property = {};
function Schema$8(property, normal, space3) {
  this.property = property;
  this.normal = normal;
  if (space3) {
    this.space = space3;
  }
}
var xtend = immutable;
var Schema$7 = schema$1;
var merge_1 = merge$3;
function merge$3(definitions2) {
  var length = definitions2.length;
  var property = [];
  var normal = [];
  var index2 = -1;
  var info2;
  var space3;
  while (++index2 < length) {
    info2 = definitions2[index2];
    property.push(info2.property);
    normal.push(info2.normal);
    space3 = info2.space;
  }
  return new Schema$7(
    xtend.apply(null, property),
    xtend.apply(null, normal),
    space3
  );
}
var normalize_1 = normalize$2;
function normalize$2(value) {
  return value.toLowerCase();
}
var info = Info$2;
var proto$1 = Info$2.prototype;
proto$1.space = null;
proto$1.attribute = null;
proto$1.property = null;
proto$1.boolean = false;
proto$1.booleanish = false;
proto$1.overloadedBoolean = false;
proto$1.number = false;
proto$1.commaSeparated = false;
proto$1.spaceSeparated = false;
proto$1.commaOrSpaceSeparated = false;
proto$1.mustUseProperty = false;
proto$1.defined = false;
function Info$2(property, attribute2) {
  this.property = property;
  this.attribute = attribute2;
}
var types$4 = {};
var powers = 0;
types$4.boolean = increment();
types$4.booleanish = increment();
types$4.overloadedBoolean = increment();
types$4.number = increment();
types$4.spaceSeparated = increment();
types$4.commaSeparated = increment();
types$4.commaOrSpaceSeparated = increment();
function increment() {
  return Math.pow(2, ++powers);
}
var Info$1 = info;
var types$3 = types$4;
var definedInfo = DefinedInfo$2;
DefinedInfo$2.prototype = new Info$1();
DefinedInfo$2.prototype.defined = true;
var checks = [
  "boolean",
  "booleanish",
  "overloadedBoolean",
  "number",
  "commaSeparated",
  "spaceSeparated",
  "commaOrSpaceSeparated"
];
var checksLength = checks.length;
function DefinedInfo$2(property, attribute2, mask, space3) {
  var index2 = -1;
  var check2;
  mark$1(this, "space", space3);
  Info$1.call(this, property, attribute2);
  while (++index2 < checksLength) {
    check2 = checks[index2];
    mark$1(this, check2, (mask & types$3[check2]) === types$3[check2]);
  }
}
function mark$1(values, key2, value) {
  if (value) {
    values[key2] = value;
  }
}
var normalize$1 = normalize_1;
var Schema$6 = schema$1;
var DefinedInfo$1 = definedInfo;
var create_1 = create$6;
function create$6(definition) {
  var space3 = definition.space;
  var mustUseProperty = definition.mustUseProperty || [];
  var attributes = definition.attributes || {};
  var props = definition.properties;
  var transform2 = definition.transform;
  var property = {};
  var normal = {};
  var prop3;
  var info2;
  for (prop3 in props) {
    info2 = new DefinedInfo$1(
      prop3,
      transform2(attributes, prop3),
      props[prop3],
      space3
    );
    if (mustUseProperty.indexOf(prop3) !== -1) {
      info2.mustUseProperty = true;
    }
    property[prop3] = info2;
    normal[normalize$1(prop3)] = prop3;
    normal[normalize$1(info2.attribute)] = prop3;
  }
  return new Schema$6(property, normal, space3);
}
var create$5 = create_1;
var xlink$2 = create$5({
  space: "xlink",
  transform: xlinkTransform,
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
});
function xlinkTransform(_, prop3) {
  return "xlink:" + prop3.slice(5).toLowerCase();
}
var create$4 = create_1;
var xml$2 = create$4({
  space: "xml",
  transform: xmlTransform,
  properties: {
    xmlLang: null,
    xmlBase: null,
    xmlSpace: null
  }
});
function xmlTransform(_, prop3) {
  return "xml:" + prop3.slice(3).toLowerCase();
}
var caseSensitiveTransform_1 = caseSensitiveTransform$2;
function caseSensitiveTransform$2(attributes, attribute2) {
  return attribute2 in attributes ? attributes[attribute2] : attribute2;
}
var caseSensitiveTransform$1 = caseSensitiveTransform_1;
var caseInsensitiveTransform_1 = caseInsensitiveTransform$2;
function caseInsensitiveTransform$2(attributes, property) {
  return caseSensitiveTransform$1(attributes, property.toLowerCase());
}
var create$3 = create_1;
var caseInsensitiveTransform$1 = caseInsensitiveTransform_1;
var xmlns$2 = create$3({
  space: "xmlns",
  attributes: {
    xmlnsxlink: "xmlns:xlink"
  },
  transform: caseInsensitiveTransform$1,
  properties: {
    xmlns: null,
    xmlnsXLink: null
  }
});
var types$2 = types$4;
var create$2 = create_1;
var booleanish$1 = types$2.booleanish;
var number$2 = types$2.number;
var spaceSeparated$2 = types$2.spaceSeparated;
var aria$2 = create$2({
  transform: ariaTransform,
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: booleanish$1,
    ariaAutoComplete: null,
    ariaBusy: booleanish$1,
    ariaChecked: booleanish$1,
    ariaColCount: number$2,
    ariaColIndex: number$2,
    ariaColSpan: number$2,
    ariaControls: spaceSeparated$2,
    ariaCurrent: null,
    ariaDescribedBy: spaceSeparated$2,
    ariaDetails: null,
    ariaDisabled: booleanish$1,
    ariaDropEffect: spaceSeparated$2,
    ariaErrorMessage: null,
    ariaExpanded: booleanish$1,
    ariaFlowTo: spaceSeparated$2,
    ariaGrabbed: booleanish$1,
    ariaHasPopup: null,
    ariaHidden: booleanish$1,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: spaceSeparated$2,
    ariaLevel: number$2,
    ariaLive: null,
    ariaModal: booleanish$1,
    ariaMultiLine: booleanish$1,
    ariaMultiSelectable: booleanish$1,
    ariaOrientation: null,
    ariaOwns: spaceSeparated$2,
    ariaPlaceholder: null,
    ariaPosInSet: number$2,
    ariaPressed: booleanish$1,
    ariaReadOnly: booleanish$1,
    ariaRelevant: null,
    ariaRequired: booleanish$1,
    ariaRoleDescription: spaceSeparated$2,
    ariaRowCount: number$2,
    ariaRowIndex: number$2,
    ariaRowSpan: number$2,
    ariaSelected: booleanish$1,
    ariaSetSize: number$2,
    ariaSort: null,
    ariaValueMax: number$2,
    ariaValueMin: number$2,
    ariaValueNow: number$2,
    ariaValueText: null,
    role: null
  }
});
function ariaTransform(_, prop3) {
  return prop3 === "role" ? prop3 : "aria-" + prop3.slice(4).toLowerCase();
}
var types$12 = types$4;
var create$1 = create_1;
var caseInsensitiveTransform = caseInsensitiveTransform_1;
var boolean$1 = types$12.boolean;
var overloadedBoolean = types$12.overloadedBoolean;
var booleanish = types$12.booleanish;
var number$1 = types$12.number;
var spaceSeparated$1 = types$12.spaceSeparated;
var commaSeparated$1 = types$12.commaSeparated;
var html$4 = create$1({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: caseInsensitiveTransform,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: commaSeparated$1,
    acceptCharset: spaceSeparated$1,
    accessKey: spaceSeparated$1,
    action: null,
    allow: null,
    allowFullScreen: boolean$1,
    allowPaymentRequest: boolean$1,
    allowUserMedia: boolean$1,
    alt: null,
    as: null,
    async: boolean$1,
    autoCapitalize: null,
    autoComplete: spaceSeparated$1,
    autoFocus: boolean$1,
    autoPlay: boolean$1,
    capture: boolean$1,
    charSet: null,
    checked: boolean$1,
    cite: null,
    className: spaceSeparated$1,
    cols: number$1,
    colSpan: null,
    content: null,
    contentEditable: booleanish,
    controls: boolean$1,
    controlsList: spaceSeparated$1,
    coords: number$1 | commaSeparated$1,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: boolean$1,
    defer: boolean$1,
    dir: null,
    dirName: null,
    disabled: boolean$1,
    download: overloadedBoolean,
    draggable: booleanish,
    encType: null,
    enterKeyHint: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: boolean$1,
    formTarget: null,
    headers: spaceSeparated$1,
    height: number$1,
    hidden: boolean$1,
    high: number$1,
    href: null,
    hrefLang: null,
    htmlFor: spaceSeparated$1,
    httpEquiv: spaceSeparated$1,
    id: null,
    imageSizes: null,
    imageSrcSet: commaSeparated$1,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: boolean$1,
    itemId: null,
    itemProp: spaceSeparated$1,
    itemRef: spaceSeparated$1,
    itemScope: boolean$1,
    itemType: spaceSeparated$1,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loop: boolean$1,
    low: number$1,
    manifest: null,
    max: null,
    maxLength: number$1,
    media: null,
    method: null,
    min: null,
    minLength: number$1,
    multiple: boolean$1,
    muted: boolean$1,
    name: null,
    nonce: null,
    noModule: boolean$1,
    noValidate: boolean$1,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforePrint: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextMenu: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: boolean$1,
    optimum: number$1,
    pattern: null,
    ping: spaceSeparated$1,
    placeholder: null,
    playsInline: boolean$1,
    poster: null,
    preload: null,
    readOnly: boolean$1,
    referrerPolicy: null,
    rel: spaceSeparated$1,
    required: boolean$1,
    reversed: boolean$1,
    rows: number$1,
    rowSpan: number$1,
    sandbox: spaceSeparated$1,
    scope: null,
    scoped: boolean$1,
    seamless: boolean$1,
    selected: boolean$1,
    shape: null,
    size: number$1,
    sizes: null,
    slot: null,
    span: number$1,
    spellCheck: booleanish,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: commaSeparated$1,
    start: number$1,
    step: null,
    style: null,
    tabIndex: number$1,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: boolean$1,
    useMap: null,
    value: booleanish,
    width: number$1,
    wrap: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: spaceSeparated$1,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: number$1,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: number$1,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: boolean$1,
    // Lists. Use CSS to reduce space between items instead
    declare: boolean$1,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: number$1,
    // `<img>` and `<object>`
    leftMargin: number$1,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: number$1,
    // `<body>`
    marginWidth: number$1,
    // `<body>`
    noResize: boolean$1,
    // `<frame>`
    noHref: boolean$1,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: boolean$1,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: boolean$1,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: number$1,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: booleanish,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: number$1,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: number$1,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: boolean$1,
    disableRemotePlayback: boolean$1,
    prefix: null,
    property: null,
    results: number$1,
    security: null,
    unselectable: null
  }
});
var merge$2 = merge_1;
var xlink$1 = xlink$2;
var xml$1 = xml$2;
var xmlns$1 = xmlns$2;
var aria$1 = aria$2;
var html$3 = html$4;
var html_1 = merge$2([xml$1, xlink$1, xmlns$1, aria$1, html$3]);
var types2 = types$4;
var create = create_1;
var caseSensitiveTransform = caseSensitiveTransform_1;
var boolean2 = types2.boolean;
var number = types2.number;
var spaceSeparated = types2.spaceSeparated;
var commaSeparated = types2.commaSeparated;
var commaOrSpaceSeparated = types2.commaOrSpaceSeparated;
var svg$2 = create({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: caseSensitiveTransform,
  properties: {
    about: commaOrSpaceSeparated,
    accentHeight: number,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: number,
    amplitude: number,
    arabicForm: null,
    ascent: number,
    attributeName: null,
    attributeType: null,
    azimuth: number,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: number,
    by: null,
    calcMode: null,
    capHeight: number,
    className: spaceSeparated,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: number,
    diffuseConstant: number,
    direction: null,
    display: null,
    dur: null,
    divisor: number,
    dominantBaseline: null,
    download: boolean2,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: number,
    enableBackground: null,
    end: null,
    event: null,
    exponent: number,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: number,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: commaSeparated,
    g2: commaSeparated,
    glyphName: commaSeparated,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: number,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: number,
    horizOriginX: number,
    horizOriginY: number,
    id: null,
    ideographic: number,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: number,
    k: number,
    k1: number,
    k2: number,
    k3: number,
    k4: number,
    kernelMatrix: commaOrSpaceSeparated,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: number,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: number,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: number,
    overlineThickness: number,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: number,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: spaceSeparated,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: number,
    pointsAtY: number,
    pointsAtZ: number,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: commaOrSpaceSeparated,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: commaOrSpaceSeparated,
    rev: commaOrSpaceSeparated,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: commaOrSpaceSeparated,
    requiredFeatures: commaOrSpaceSeparated,
    requiredFonts: commaOrSpaceSeparated,
    requiredFormats: commaOrSpaceSeparated,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: number,
    specularExponent: number,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: number,
    strikethroughThickness: number,
    string: null,
    stroke: null,
    strokeDashArray: commaOrSpaceSeparated,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: number,
    strokeOpacity: number,
    strokeWidth: null,
    style: null,
    surfaceScale: number,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: commaOrSpaceSeparated,
    tabIndex: number,
    tableValues: null,
    target: null,
    targetX: number,
    targetY: number,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: commaOrSpaceSeparated,
    to: null,
    transform: null,
    u1: null,
    u2: null,
    underlinePosition: number,
    underlineThickness: number,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: number,
    values: null,
    vAlphabetic: number,
    vMathematical: number,
    vectorEffect: null,
    vHanging: number,
    vIdeographic: number,
    version: null,
    vertAdvY: number,
    vertOriginX: number,
    vertOriginY: number,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: number,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
});
var merge$1 = merge_1;
var xlink = xlink$2;
var xml = xml$2;
var xmlns = xmlns$2;
var aria2 = aria$2;
var svg$1 = svg$2;
var svg_1 = merge$1([xml, xlink, xmlns, aria2, svg$1]);
var require$$2 = [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "image",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "menuitem",
  "meta",
  "nextid",
  "param",
  "source",
  "track",
  "wbr"
];
var omission$4 = {};
var unistUtilIs = is$3;
function is$3(test, node, index2, parent, context2) {
  var hasParent = parent !== null && parent !== void 0;
  var hasIndex = index2 !== null && index2 !== void 0;
  var check2 = convert2(test);
  if (hasIndex && (typeof index2 !== "number" || index2 < 0 || index2 === Infinity)) {
    throw new Error("Expected positive finite index or child node");
  }
  if (hasParent && (!is$3(null, parent) || !parent.children)) {
    throw new Error("Expected parent node");
  }
  if (!node || !node.type || typeof node.type !== "string") {
    return false;
  }
  if (hasParent !== hasIndex) {
    throw new Error("Expected both parent and index");
  }
  return Boolean(check2.call(context2, node, index2, parent));
}
function convert2(test) {
  if (typeof test === "string") {
    return typeFactory(test);
  }
  if (test === null || test === void 0) {
    return ok;
  }
  if (typeof test === "object") {
    return ("length" in test ? anyFactory : matchesFactory)(test);
  }
  if (typeof test === "function") {
    return test;
  }
  throw new Error("Expected function, string, or object as test");
}
function convertAll(tests2) {
  var results = [];
  var length = tests2.length;
  var index2 = -1;
  while (++index2 < length) {
    results[index2] = convert2(tests2[index2]);
  }
  return results;
}
function matchesFactory(test) {
  return matches;
  function matches(node) {
    var key2;
    for (key2 in test) {
      if (node[key2] !== test[key2]) {
        return false;
      }
    }
    return true;
  }
}
function anyFactory(tests2) {
  var checks2 = convertAll(tests2);
  var length = checks2.length;
  return matches;
  function matches() {
    var index2 = -1;
    while (++index2 < length) {
      if (checks2[index2].apply(this, arguments)) {
        return true;
      }
    }
    return false;
  }
}
function typeFactory(test) {
  return type2;
  function type2(node) {
    return Boolean(node && node.type === test);
  }
}
function ok() {
  return true;
}
var hastUtilIsElement = isElement;
function isElement(node, tagNames) {
  var name2;
  if (!(tagNames === null || tagNames === void 0 || typeof tagNames === "string" || typeof tagNames === "object" && tagNames.length !== 0)) {
    throw new Error(
      "Expected `string` or `Array.<string>` for `tagNames`, not `" + tagNames + "`"
    );
  }
  if (!node || typeof node !== "object" || node.type !== "element" || typeof node.tagName !== "string") {
    return false;
  }
  if (tagNames === null || tagNames === void 0) {
    return true;
  }
  name2 = node.tagName;
  if (typeof tagNames === "string") {
    return name2 === tagNames;
  }
  return tagNames.indexOf(name2) !== -1;
}
var siblings$1 = {};
var hastUtilWhitespace = interElementWhiteSpace;
var re = /[ \t\n\f\r]/g;
function interElementWhiteSpace(node) {
  var value;
  if (node && typeof node === "object" && node.type === "text") {
    value = node.value || "";
  } else if (typeof node === "string") {
    value = node;
  } else {
    return false;
  }
  return value.replace(re, "") === "";
}
var whiteSpace$2 = hastUtilWhitespace;
siblings$1.before = siblings(-1);
siblings$1.after = siblings(1);
function siblings(increment2) {
  return sibling2;
  function sibling2(parent, index2, includeWhiteSpace) {
    var siblings2 = parent && parent.children;
    var next2;
    index2 += increment2;
    next2 = siblings2 && siblings2[index2];
    if (!includeWhiteSpace) {
      while (next2 && whiteSpace$2(next2)) {
        index2 += increment2;
        next2 = siblings2[index2];
      }
    }
    return next2;
  }
}
var after$1 = siblings$1.after;
var first_1 = first$1;
function first$1(parent, includeWhiteSpace) {
  return after$1(parent, -1, includeWhiteSpace);
}
var place_1 = place$1;
function place$1(parent, child) {
  return parent && parent.children && parent.children.indexOf(child);
}
var is$2 = unistUtilIs;
var whiteSpace$1 = hastUtilWhitespace;
var whiteSpaceLeft_1 = whiteSpaceLeft$2;
function whiteSpaceLeft$2(node) {
  return is$2("text", node) && whiteSpace$1(node.value.charAt(0));
}
var omission_1 = omission$3;
var own$3 = {}.hasOwnProperty;
function omission$3(handlers2) {
  return omit;
  function omit(node, index2, parent) {
    var name2 = node.tagName;
    var fn = own$3.call(handlers2, name2) ? handlers2[name2] : false;
    return fn ? fn(node, index2, parent) : false;
  }
}
var is$1 = unistUtilIs;
var element$1 = hastUtilIsElement;
var whiteSpaceLeft$1 = whiteSpaceLeft_1;
var after = siblings$1.after;
var omission$2 = omission_1;
var optionGroup = "optgroup";
var options = ["option"].concat(optionGroup);
var dataListItem = ["dt", "dd"];
var listItem = "li";
var menuContent = ["menuitem", "hr", "menu"];
var ruby = ["rp", "rt"];
var tableContainer = ["tbody", "tfoot"];
var tableRow$1 = "tr";
var tableCell = ["td", "th"];
var confusingParagraphParent = ["a", "audio", "del", "ins", "map", "noscript", "video"];
var clearParagraphSibling = [
  "address",
  "article",
  "aside",
  "blockquote",
  "details",
  "div",
  "dl",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "header",
  "hgroup",
  "hr",
  "main",
  "menu",
  "nav",
  "ol",
  "p",
  "pre",
  "section",
  "table",
  "ul"
];
var closing$1 = omission$2({
  html: html$2,
  head: headOrColgroupOrCaption,
  body: body$1,
  p,
  li,
  dt,
  dd,
  rt: rubyElement,
  rp: rubyElement,
  optgroup,
  option,
  menuitem,
  colgroup: headOrColgroupOrCaption,
  caption: headOrColgroupOrCaption,
  thead,
  tbody: tbody$1,
  tfoot,
  tr,
  td: cells,
  th: cells
});
function headOrColgroupOrCaption(node, index2, parent) {
  var next2 = after(parent, index2, true);
  return !next2 || !is$1("comment", next2) && !whiteSpaceLeft$1(next2);
}
function html$2(node, index2, parent) {
  var next2 = after(parent, index2);
  return !next2 || !is$1("comment", next2);
}
function body$1(node, index2, parent) {
  var next2 = after(parent, index2);
  return !next2 || !is$1("comment", next2);
}
function p(node, index2, parent) {
  var next2 = after(parent, index2);
  return next2 ? element$1(next2, clearParagraphSibling) : !parent || !element$1(parent, confusingParagraphParent);
}
function li(node, index2, parent) {
  var next2 = after(parent, index2);
  return !next2 || element$1(next2, listItem);
}
function dt(node, index2, parent) {
  var next2 = after(parent, index2);
  return next2 && element$1(next2, dataListItem);
}
function dd(node, index2, parent) {
  var next2 = after(parent, index2);
  return !next2 || element$1(next2, dataListItem);
}
function rubyElement(node, index2, parent) {
  var next2 = after(parent, index2);
  return !next2 || element$1(next2, ruby);
}
function optgroup(node, index2, parent) {
  var next2 = after(parent, index2);
  return !next2 || element$1(next2, optionGroup);
}
function option(node, index2, parent) {
  var next2 = after(parent, index2);
  return !next2 || element$1(next2, options);
}
function menuitem(node, index2, parent) {
  var next2 = after(parent, index2);
  return !next2 || element$1(next2, menuContent);
}
function thead(node, index2, parent) {
  var next2 = after(parent, index2);
  return next2 && element$1(next2, tableContainer);
}
function tbody$1(node, index2, parent) {
  var next2 = after(parent, index2);
  return !next2 || element$1(next2, tableContainer);
}
function tfoot(node, index2, parent) {
  return !after(parent, index2);
}
function tr(node, index2, parent) {
  var next2 = after(parent, index2);
  return !next2 || element$1(next2, tableRow$1);
}
function cells(node, index2, parent) {
  var next2 = after(parent, index2);
  return !next2 || element$1(next2, tableCell);
}
var is = unistUtilIs;
var element2 = hastUtilIsElement;
var before = siblings$1.before;
var first = first_1;
var place = place_1;
var whiteSpaceLeft = whiteSpaceLeft_1;
var closing = closing$1;
var omission$1 = omission_1;
var own$2 = {}.hasOwnProperty;
var uniqueHeadMetadata = ["title", "base"];
var meta = ["meta", "link", "script", "style", "template"];
var tableContainers = ["thead", "tbody"];
var tableRow = "tr";
var opening = omission$1({
  html: html$1,
  head,
  body,
  colgroup,
  tbody
});
function html$1(node) {
  var head2 = first(node);
  return !head2 || !is("comment", head2);
}
function head(node) {
  var children = node.children;
  var length = children.length;
  var map2 = {};
  var index2 = -1;
  var child;
  var name2;
  while (++index2 < length) {
    child = children[index2];
    name2 = child.tagName;
    if (element2(child, uniqueHeadMetadata)) {
      if (own$2.call(map2, name2)) {
        return false;
      }
      map2[name2] = true;
    }
  }
  return Boolean(length);
}
function body(node) {
  var head2 = first(node, true);
  return !head2 || !is("comment", head2) && !whiteSpaceLeft(head2) && !element2(head2, meta);
}
function colgroup(node, index2, parent) {
  var prev = before(parent, index2);
  var head2 = first(node, true);
  if (element2(prev, "colgroup") && closing(prev, place(parent, prev), parent)) {
    return false;
  }
  return head2 && element2(head2, "col");
}
function tbody(node, index2, parent) {
  var prev = before(parent, index2);
  var head2 = first(node);
  if (element2(prev, tableContainers) && closing(prev, place(parent, prev), parent)) {
    return false;
  }
  return head2 && element2(head2, tableRow);
}
omission$4.opening = opening;
omission$4.closing = closing$1;
var require$$1 = [
  "script",
  "style",
  "pre",
  "textarea"
];
var all_1;
var hasRequiredAll;
function requireAll() {
  if (hasRequiredAll) return all_1;
  hasRequiredAll = 1;
  var one2 = requireOne();
  var sensitive = require$$1;
  all_1 = all2;
  function all2(ctx, parent) {
    var children = parent && parent.children;
    var length = children && children.length;
    var index2 = -1;
    var results = [];
    let printWidthOffset = 0;
    let innerTextLength = 0;
    while (++index2 < length) {
      innerTextLength = getInnerTextLength(children[index2]);
      results[index2] = one2(ctx, children[index2], index2, parent, printWidthOffset, innerTextLength);
      printWidthOffset = results[index2].replace(/\n+/g, "").length;
    }
    return results.join("");
  }
  function getInnerTextLength(node) {
    if (sensitive.indexOf(node.tagName) !== -1) {
      return 0;
    }
    if (!node.children || !node.children.length) {
      return 0;
    }
    var child = node.children[0];
    if (child.type === "text" || child.type === "comment") {
      return child.value.split("\n")[0].length;
    }
    return 0;
  }
  return all_1;
}
var text_1 = text2;
function text2(ctx, node, index2, parent) {
  var value = node.value;
  return value;
}
var normalize = normalize_1;
var DefinedInfo = definedInfo;
var Info = info;
var data2 = "data";
var find_1 = find;
var valid = /^data[-\w.:]+$/i;
var dash = /-[a-z]/g;
var cap$1 = /[A-Z]/g;
function find(schema2, value) {
  var normal = normalize(value);
  var prop3 = value;
  var Type2 = Info;
  if (normal in schema2.normal) {
    return schema2.property[schema2.normal[normal]];
  }
  if (normal.length > 4 && normal.slice(0, 4) === data2 && valid.test(value)) {
    if (value.charAt(4) === "-") {
      prop3 = datasetToProperty(value);
    } else {
      value = datasetToAttribute(value);
    }
    Type2 = DefinedInfo;
  }
  return new Type2(prop3, value);
}
function datasetToProperty(attribute2) {
  var value = attribute2.slice(5).replace(dash, camelcase);
  return data2 + value.charAt(0).toUpperCase() + value.slice(1);
}
function datasetToAttribute(property) {
  var value = property.slice(4);
  if (dash.test(value)) {
    return property;
  }
  value = value.replace(cap$1, kebab);
  if (value.charAt(0) !== "-") {
    value = "-" + value;
  }
  return data2 + value;
}
function kebab($0) {
  return "-" + $0.toLowerCase();
}
function camelcase($0) {
  return $0.charAt(1).toUpperCase();
}
var commaSeparatedTokens = {};
commaSeparatedTokens.parse = parse$1;
commaSeparatedTokens.stringify = stringify$3;
var comma2 = ",";
var space$1 = " ";
var empty$12 = "";
function parse$1(value) {
  var values = [];
  var input = String(value || empty$12);
  var index2 = input.indexOf(comma2);
  var lastIndex = 0;
  var end2 = false;
  var val;
  while (!end2) {
    if (index2 === -1) {
      index2 = input.length;
      end2 = true;
    }
    val = input.slice(lastIndex, index2).trim();
    if (val || !end2) {
      values.push(val);
    }
    lastIndex = index2 + 1;
    index2 = input.indexOf(comma2, lastIndex);
  }
  return values;
}
function stringify$3(values, options2) {
  var settings = options2 || {};
  var left = settings.padLeft === false ? empty$12 : space$1;
  var right = settings.padRight ? space$1 : empty$12;
  if (values[values.length - 1] === empty$12) {
    values = values.concat(empty$12);
  }
  return values.join(right + comma2 + left).trim();
}
var nbsp = "";
var iexcl = "";
var cent = "";
var pound = "";
var curren = "";
var yen = "";
var brvbar = "";
var sect = "";
var uml = "";
var copy = "";
var ordf = "";
var laquo = "";
var not = "";
var shy = "";
var reg = "";
var macr = "";
var deg = "";
var plusmn = "";
var sup2 = "";
var sup3 = "";
var acute = "";
var micro = "";
var para = "";
var middot = "";
var cedil = "";
var sup1 = "";
var ordm = "";
var raquo = "";
var frac14 = "";
var frac12 = "";
var frac34 = "";
var iquest = "";
var Agrave = "";
var Aacute = "";
var Acirc = "";
var Atilde = "";
var Auml = "";
var Aring = "";
var AElig = "";
var Ccedil = "";
var Egrave = "";
var Eacute = "";
var Ecirc = "";
var Euml = "";
var Igrave = "";
var Iacute = "";
var Icirc = "";
var Iuml = "";
var ETH = "";
var Ntilde = "";
var Ograve = "";
var Oacute = "";
var Ocirc = "";
var Otilde = "";
var Ouml = "";
var times = "";
var Oslash = "";
var Ugrave = "";
var Uacute = "";
var Ucirc = "";
var Uuml = "";
var Yacute = "";
var THORN = "";
var szlig = "";
var agrave = "";
var aacute = "";
var acirc = "";
var atilde = "";
var auml = "";
var aring = "";
var aelig = "";
var ccedil = "";
var egrave = "";
var eacute = "";
var ecirc = "";
var euml = "";
var igrave = "";
var iacute = "";
var icirc = "";
var iuml = "";
var eth = "";
var ntilde = "";
var ograve = "";
var oacute = "";
var ocirc = "";
var otilde = "";
var ouml = "";
var divide = "";
var oslash = "";
var ugrave = "";
var uacute = "";
var ucirc = "";
var uuml = "";
var yacute = "";
var thorn = "";
var yuml = "";
var fnof = "";
var Alpha = "";
var Beta = "";
var Gamma = "";
var Delta = "";
var Epsilon = "";
var Zeta = "";
var Eta = "";
var Theta = "";
var Iota = "";
var Kappa = "";
var Lambda = "";
var Mu = "";
var Nu = "";
var Xi = "";
var Omicron = "";
var Pi = "";
var Rho = "";
var Sigma = "";
var Tau = "";
var Upsilon = "";
var Phi = "";
var Chi = "";
var Psi = "";
var Omega = "";
var alpha = "";
var beta = "";
var gamma = "";
var delta = "";
var epsilon = "";
var zeta = "";
var eta = "";
var theta = "";
var iota = "";
var kappa = "";
var lambda = "";
var mu = "";
var nu = "";
var xi = "";
var omicron = "";
var pi = "";
var rho = "";
var sigmaf = "";
var sigma = "";
var tau = "";
var upsilon = "";
var phi = "";
var chi = "";
var psi = "";
var omega = "";
var thetasym = "";
var upsih = "";
var piv = "";
var bull = "";
var hellip = "";
var prime = "";
var Prime = "";
var oline = "";
var frasl = "";
var weierp = "";
var image = "";
var real = "";
var trade = "";
var alefsym = "";
var larr = "";
var uarr = "";
var rarr = "";
var darr = "";
var harr = "";
var crarr = "";
var lArr = "";
var uArr = "";
var rArr = "";
var dArr = "";
var hArr = "";
var forall = "";
var part = "";
var exist = "";
var empty3 = "";
var nabla = "";
var isin = "";
var notin = "";
var ni = "";
var prod = "";
var sum = "";
var minus = "";
var lowast = "";
var radic = "";
var prop2 = "";
var infin = "";
var ang = "";
var and = "";
var or = "";
var cap = "";
var cup = "";
var int$1 = "";
var there4 = "";
var sim = "";
var cong = "";
var asymp = "";
var ne = "";
var equiv = "";
var le = "";
var ge = "";
var sub = "";
var sup = "";
var nsub = "";
var sube = "";
var supe = "";
var oplus = "";
var otimes = "";
var perp = "";
var sdot = "";
var lceil = "";
var rceil = "";
var lfloor = "";
var rfloor = "";
var lang = "";
var rang = "";
var loz = "";
var spades = "";
var clubs = "";
var hearts = "";
var diams = "";
var quot = '"';
var amp = "&";
var lt = "<";
var gt = ">";
var OElig = "";
var oelig = "";
var Scaron = "";
var scaron = "";
var Yuml = "";
var circ = "";
var tilde = "";
var ensp = "";
var emsp = "";
var thinsp = "";
var zwnj = "";
var zwj = "";
var lrm = "";
var rlm = "";
var ndash = "";
var mdash = "";
var lsquo = "";
var rsquo = "";
var sbquo = "";
var ldquo = "";
var rdquo = "";
var bdquo = "";
var dagger = "";
var Dagger = "";
var permil = "";
var lsaquo = "";
var rsaquo = "";
var euro = "";
var require$$0 = {
  nbsp,
  iexcl,
  cent,
  pound,
  curren,
  yen,
  brvbar,
  sect,
  uml,
  copy,
  ordf,
  laquo,
  not,
  shy,
  reg,
  macr,
  deg,
  plusmn,
  sup2,
  sup3,
  acute,
  micro,
  para,
  middot,
  cedil,
  sup1,
  ordm,
  raquo,
  frac14,
  frac12,
  frac34,
  iquest,
  Agrave,
  Aacute,
  Acirc,
  Atilde,
  Auml,
  Aring,
  AElig,
  Ccedil,
  Egrave,
  Eacute,
  Ecirc,
  Euml,
  Igrave,
  Iacute,
  Icirc,
  Iuml,
  ETH,
  Ntilde,
  Ograve,
  Oacute,
  Ocirc,
  Otilde,
  Ouml,
  times,
  Oslash,
  Ugrave,
  Uacute,
  Ucirc,
  Uuml,
  Yacute,
  THORN,
  szlig,
  agrave,
  aacute,
  acirc,
  atilde,
  auml,
  aring,
  aelig,
  ccedil,
  egrave,
  eacute,
  ecirc,
  euml,
  igrave,
  iacute,
  icirc,
  iuml,
  eth,
  ntilde,
  ograve,
  oacute,
  ocirc,
  otilde,
  ouml,
  divide,
  oslash,
  ugrave,
  uacute,
  ucirc,
  uuml,
  yacute,
  thorn,
  yuml,
  fnof,
  Alpha,
  Beta,
  Gamma,
  Delta,
  Epsilon,
  Zeta,
  Eta,
  Theta,
  Iota,
  Kappa,
  Lambda,
  Mu,
  Nu,
  Xi,
  Omicron,
  Pi,
  Rho,
  Sigma,
  Tau,
  Upsilon,
  Phi,
  Chi,
  Psi,
  Omega,
  alpha,
  beta,
  gamma,
  delta,
  epsilon,
  zeta,
  eta,
  theta,
  iota,
  kappa,
  lambda,
  mu,
  nu,
  xi,
  omicron,
  pi,
  rho,
  sigmaf,
  sigma,
  tau,
  upsilon,
  phi,
  chi,
  psi,
  omega,
  thetasym,
  upsih,
  piv,
  bull,
  hellip,
  prime,
  Prime,
  oline,
  frasl,
  weierp,
  image,
  real,
  trade,
  alefsym,
  larr,
  uarr,
  rarr,
  darr,
  harr,
  crarr,
  lArr,
  uArr,
  rArr,
  dArr,
  hArr,
  forall,
  part,
  exist,
  empty: empty3,
  nabla,
  isin,
  notin,
  ni,
  prod,
  sum,
  minus,
  lowast,
  radic,
  prop: prop2,
  infin,
  ang,
  and,
  or,
  cap,
  cup,
  int: int$1,
  there4,
  sim,
  cong,
  asymp,
  ne,
  equiv,
  le,
  ge,
  sub,
  sup,
  nsub,
  sube,
  supe,
  oplus,
  otimes,
  perp,
  sdot,
  lceil,
  rceil,
  lfloor,
  rfloor,
  lang,
  rang,
  loz,
  spades,
  clubs,
  hearts,
  diams,
  quot,
  amp,
  lt,
  gt,
  OElig,
  oelig,
  Scaron,
  scaron,
  Yuml,
  circ,
  tilde,
  ensp,
  emsp,
  thinsp,
  zwnj,
  zwj,
  lrm,
  rlm,
  ndash,
  mdash,
  lsquo,
  rsquo,
  sbquo,
  ldquo,
  rdquo,
  bdquo,
  dagger,
  Dagger,
  permil,
  lsaquo,
  rsaquo,
  euro
};
var require$$5 = [
  "cent",
  "copy",
  "divide",
  "gt",
  "lt",
  "not",
  "para",
  "times"
];
var entities = require$$0;
var legacy = require$$1$2;
var hexadecimal = isHexadecimal;
var decimal = requireIsDecimal();
var alphanumerical = isAlphanumerical;
var dangerous = require$$5;
var stringifyEntities = encode2;
encode2.escape = escape$1;
var own$1 = {}.hasOwnProperty;
var escapes = ['"', "'", "<", ">", "&", "`"];
var characters = construct();
var defaultEscapes = toExpression(escapes);
var surrogatePair = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
var bmp = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;
function encode2(value, options2) {
  var settings = options2 || {};
  var subset2 = settings.subset;
  var set3 = subset2 ? toExpression(subset2) : defaultEscapes;
  var escapeOnly = settings.escapeOnly;
  var omit = settings.omitOptionalSemicolons;
  value = value.replace(set3, replace2);
  if (subset2 || escapeOnly) {
    return value;
  }
  return value.replace(surrogatePair, replaceSurrogatePair).replace(bmp, replace2);
  function replaceSurrogatePair(pair, pos, val) {
    return toHexReference(
      (pair.charCodeAt(0) - 55296) * 1024 + pair.charCodeAt(1) - 56320 + 65536,
      val.charAt(pos + 2),
      omit
    );
  }
  function replace2(char, pos, val) {
    return one$1(char, val.charAt(pos + 1), settings);
  }
}
function escape$1(value) {
  return encode2(value, { escapeOnly: true, useNamedReferences: true });
}
function one$1(char, next2, options2) {
  var shortest = options2.useShortestReferences;
  var omit = options2.omitOptionalSemicolons;
  var named;
  var code2;
  var numeric;
  var decimal2;
  if ((shortest || options2.useNamedReferences) && own$1.call(characters, char)) {
    named = toNamed(characters[char], next2, omit, options2.attribute);
  }
  if (shortest || !named) {
    code2 = char.charCodeAt(0);
    numeric = toHexReference(code2, next2, omit);
    if (shortest) {
      decimal2 = toDecimalReference(code2, next2, omit);
      if (decimal2.length < numeric.length) {
        numeric = decimal2;
      }
    }
  }
  if (named && (!shortest || named.length < numeric.length)) {
    return named;
  }
  return numeric;
}
function toNamed(name2, next2, omit, attribute2) {
  var value = "&" + name2;
  if (omit && own$1.call(legacy, name2) && dangerous.indexOf(name2) === -1 && (!attribute2 || next2 && next2 !== "=" && !alphanumerical(next2))) {
    return value;
  }
  return value + ";";
}
function toHexReference(code2, next2, omit) {
  var value = "&#x" + code2.toString(16).toUpperCase();
  return omit && next2 && !hexadecimal(next2) ? value : value + ";";
}
function toDecimalReference(code2, next2, omit) {
  var value = "&#" + String(code2);
  return omit && next2 && !decimal(next2) ? value : value + ";";
}
function toExpression(characters2) {
  return new RegExp("[" + characters2.join("") + "]", "g");
}
function construct() {
  var chars2 = {};
  var name2;
  for (name2 in entities) {
    chars2[entities[name2]] = name2;
  }
  return chars2;
}
var NULL = "\0";
var AMP = "&";
var SP = " ";
var TB = "	";
var GR = "`";
var DQ$1 = '"';
var SQ$1 = "'";
var EQ = "=";
var LT = "<";
var GT = ">";
var SO = "/";
var LF = "\n";
var CR = "\r";
var FF = "\f";
var whitespace = [SP, TB, LF, CR, FF];
var name = whitespace.concat(AMP, SO, GT, EQ);
var unquoted$1 = whitespace.concat(AMP, GT);
var unquotedSafe = unquoted$1.concat(NULL, DQ$1, SQ$1, LT, EQ, GR);
var singleQuoted$1 = [AMP, SQ$1];
var doubleQuoted$1 = [AMP, DQ$1];
var constants = {
  name: [[name, name.concat(DQ$1, SQ$1, GR)], [name.concat(NULL, DQ$1, SQ$1, LT), name.concat(NULL, DQ$1, SQ$1, LT, GR)]],
  unquoted: [[unquoted$1, unquotedSafe], [unquotedSafe, unquotedSafe]],
  single: [
    [singleQuoted$1, singleQuoted$1.concat(DQ$1, GR)],
    [singleQuoted$1.concat(NULL), singleQuoted$1.concat(NULL, DQ$1, GR)]
  ],
  double: [
    [doubleQuoted$1, doubleQuoted$1.concat(SQ$1, GR)],
    [doubleQuoted$1.concat(NULL), doubleQuoted$1.concat(NULL, SQ$1, GR)]
  ]
};
var element_1;
var hasRequiredElement;
function requireElement() {
  if (hasRequiredElement) return element_1;
  hasRequiredElement = 1;
  var xtend2 = immutable;
  var svg2 = svg_1;
  var find2 = find_1;
  var spaces = spaceSeparatedTokens.stringify;
  var commas = commaSeparatedTokens.stringify;
  var entities2 = stringifyEntities;
  var all2 = requireAll();
  var constants$1 = constants;
  const repeat2 = repeatString;
  element_1 = element3;
  var emptyString = "";
  var space3 = " ";
  var quotationMark = '"';
  var apostrophe2 = "'";
  var equalsTo2 = "=";
  var lessThan2 = "<";
  var greaterThan = ">";
  var slash = "/";
  var newLine = "\n";
  function element3(ctx, node, index2, parent, printWidthOffset, innerTextLength) {
    var parentSchema = ctx.schema;
    var name2 = node.tagName;
    var value = "";
    var selfClosing;
    var close2;
    var omit;
    var root2 = node;
    var content;
    var attrs2;
    var indentLevel = getNodeData(node, "indentLevel", 0);
    var printContext = {
      offset: printWidthOffset,
      wrapAttributes: false,
      indentLevel
    };
    var isVoid = ctx.voids.indexOf(name2) !== -1;
    var ignoreAttrCollapsing = getNodeData(node, "ignore", false) || getNodeData(node, "preserveAttrWrapping", false);
    if (parentSchema.space === "html" && name2 === "svg") {
      ctx.schema = svg2;
    }
    if (ctx.schema.space === "svg") {
      omit = false;
      close2 = true;
      selfClosing = ctx.closeEmpty;
    } else {
      omit = ctx.omit;
      close2 = ctx.close;
      selfClosing = isVoid;
    }
    if (selfClosing === false) {
      selfClosing = getNodeData(node, "selfClosing", false);
    }
    printContext.offset += lessThan2.length;
    printContext.offset += node.tagName.length;
    if (selfClosing && !isVoid) {
      printContext.offset += slash.length;
    }
    printContext.offset += greaterThan.length;
    const propertyCount = Object.keys(node.properties).length;
    if (propertyCount > 1 && ctx.wrapAttributes) {
      printContext.wrapAttributes = true;
    }
    if (propertyCount) {
      printContext.offset += propertyCount * space3.length;
    }
    printContext.offset += innerTextLength;
    attrs2 = attributes(ctx, node.properties, printContext, ignoreAttrCollapsing);
    const shouldCollapse = ignoreAttrCollapsing === false && printContext.wrapAttributes;
    content = all2(ctx, root2);
    selfClosing = content ? false : selfClosing;
    if (attrs2 || !omit || !omit.opening(node, index2, parent)) {
      value = lessThan2 + name2;
      if (attrs2) {
        if (shouldCollapse) {
          value += attrs2;
        } else {
          value += space3 + attrs2;
        }
      }
      let selfClosed = false;
      if (selfClosing && close2) {
        if ((!ctx.tightClose || attrs2.charAt(attrs2.length - 1) === slash) && !shouldCollapse) {
          value += space3;
        }
        if (shouldCollapse) {
          value += newLine + repeat2(ctx.tabWidth, printContext.indentLevel);
        }
        selfClosed = true;
        value += slash;
      } else if (selfClosing && !isVoid) {
        if (shouldCollapse) {
          value += newLine + repeat2(ctx.tabWidth, printContext.indentLevel);
        }
        selfClosed = true;
        value += slash;
      }
      if (shouldCollapse && !selfClosed) {
        value += newLine + repeat2(ctx.tabWidth, printContext.indentLevel);
      }
      value += greaterThan;
    }
    value += content;
    if (!selfClosing && (!omit || !omit.closing(node, index2, parent))) {
      value += lessThan2 + slash + name2 + greaterThan;
    }
    ctx.schema = parentSchema;
    return value;
  }
  function attributes(ctx, props, printContext, ignoreIndent) {
    var values = [];
    var key2;
    var value;
    var result;
    var length;
    var index2;
    var last;
    for (key2 in props) {
      value = props[key2];
      if (value == null) {
        continue;
      }
      result = attribute2(ctx, key2, value);
      printContext.offset += result.length;
      if (ignoreIndent === false && printContext.offset > ctx.printWidth) {
        printContext.wrapAttributes = true;
      }
      if (result) {
        values.push(result);
      }
    }
    length = values.length;
    index2 = -1;
    while (++index2 < length) {
      result = values[index2];
      last = null;
      if (last !== quotationMark && last !== apostrophe2) {
        if (printContext.wrapAttributes) {
          values[index2] = newLine + repeat2(ctx.tabWidth, printContext.indentLevel + 1) + result;
        } else if (index2 !== length - 1) {
          values[index2] = result + space3;
        } else {
          values[index2] = result;
        }
      }
    }
    return values.join(emptyString);
  }
  function attribute2(ctx, key2, value) {
    var schema2 = ctx.schema;
    var info2 = find2(schema2, key2);
    var name2 = info2.attribute;
    if (value == null || typeof value === "number" && isNaN(value) || value === false && info2.boolean) {
      return emptyString;
    }
    name2 = attributeName2(ctx, name2);
    if (value === true && info2.boolean || value === true && info2.overloadedBoolean) {
      return name2;
    }
    return name2 + attributeValue2(ctx, key2, value, info2);
  }
  function attributeName2(ctx, name2) {
    var valid2 = ctx.schema.space === "html" ? ctx.valid : 1;
    var subset2 = constants$1.name[valid2][ctx.safe];
    return entities2(name2, xtend2(ctx.entities, { subset: subset2 }));
  }
  function attributeValue2(ctx, key2, value, info2) {
    var quote = ctx.quote;
    if (typeof value === "object" && "length" in value) {
      value = (info2.commaSeparated ? commas : spaces)(value, {
        padLeft: !ctx.tightLists
      });
    }
    value = String(value);
    if (value === "") {
      return value;
    } else {
      value = equalsTo2 + quote + value + quote;
    }
    return value;
  }
  function getNodeData(node, key2, defaultValue) {
    let data3 = node.data || {};
    return data3[key2] || defaultValue;
  }
  return element_1;
}
var doctype_1 = doctype;
function doctype(ctx, node) {
  var sep = ctx.tightDoctype ? "" : " ";
  var name2 = node.name;
  var pub = node.public;
  var sys = node.system;
  var val = ["<!doctype"];
  if (name2) {
    val.push(sep, name2);
    if (pub != null) {
      val.push(" public", sep, smart(pub));
    } else if (sys != null) {
      val.push(" system");
    }
    if (sys != null) {
      val.push(sep, smart(sys));
    }
  }
  return val.join("") + ">";
}
function smart(value) {
  var quote = value.indexOf('"') === -1 ? '"' : "'";
  return quote + value + quote;
}
var comment_1 = comment;
function comment(ctx, node) {
  return "<!--" + node.value + "-->";
}
var raw_1 = raw;
function raw(ctx, node) {
  return node.value;
}
var one_1;
var hasRequiredOne;
function requireOne() {
  if (hasRequiredOne) return one_1;
  hasRequiredOne = 1;
  one_1 = one2;
  var own2 = {}.hasOwnProperty;
  var handlers2 = {};
  handlers2.root = requireAll();
  handlers2.text = text_1;
  handlers2.element = requireElement();
  handlers2.doctype = doctype_1;
  handlers2.comment = comment_1;
  handlers2.raw = raw_1;
  function one2(ctx, node, index2, parent, printWidthOffset, innerTextLength) {
    var type2 = node && node.type;
    if (!type2) {
      throw new Error("Expected node, not `" + node + "`");
    }
    if (!own2.call(handlers2, type2)) {
      throw new Error("Cannot compile unknown node `" + type2 + "`");
    }
    return handlers2[type2](ctx, node, index2, parent, printWidthOffset, innerTextLength);
  }
  return one_1;
}
var html = html_1;
var svg = svg_1;
var voids = require$$2;
var omission = omission$4;
var one = requireOne();
var repeat$1 = repeatString;
var lib$1 = toHTML;
var DQ = '"';
var SQ = "'";
function toHTML(node, options2) {
  var settings = options2 || {};
  var quote = settings.singleQuote ? SQ : DQ;
  var printWidth = settings.printWidth === void 0 ? 80 : settings.printWidth;
  var useTabs = settings.useTabs;
  var tabWidth = settings.tabWidth || 2;
  var wrapAttributes = settings.wrapAttributes;
  if (useTabs) {
    tabWidth = "	";
  } else if (typeof tabWidth === "number") {
    tabWidth = repeat$1(" ", tabWidth);
  }
  return one(
    {
      valid: settings.allowParseErrors ? 0 : 1,
      safe: settings.allowDangerousCharacters ? 0 : 1,
      schema: settings.space === "svg" ? svg : html,
      omit: settings.omitOptionalTags && omission,
      quote,
      printWidth,
      tabWidth,
      wrapAttributes,
      tightDoctype: Boolean(settings.tightDoctype),
      tightLists: settings.tightCommaSeparatedLists,
      voids: settings.voids || voids.concat(),
      entities: settings.entities || {},
      close: settings.closeSelfClosing,
      tightClose: settings.tightSelfClosing,
      closeEmpty: settings.closeEmptyElements
    },
    node
  );
}
var prettyhtmlHastToHtml = lib$1;
var hast_to_html = getDefaultExportFromCjs(prettyhtmlHastToHtml);
var void_els = [
  "area",
  "base",
  "br",
  "col",
  "embed",
  "hr",
  "img",
  "input",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];
var RE_SVELTE_TAG = /^<svelte:([a-z]*)[\s\S]*(?:(?:svelte:[a-z]*)|(?:\/))>$/;
var RE_SVELTE_TAG_START = /(^\s*)<([\\/\s])*svelte:/;
function parse_svelte_tag(eat2, value, silent) {
  const is_svelte_tag = RE_SVELTE_TAG_START.exec(value);
  if (is_svelte_tag) {
    if (silent) return true;
    const trimmed_value = value.trim();
    let cbPos = 0;
    let pos = 1;
    let current_tag = "";
    let in_tag_name = false;
    while (cbPos > -1) {
      if (!trimmed_value[pos]) {
        break;
      }
      if (trimmed_value[pos].match(/</)) {
        cbPos++;
        current_tag = "";
        in_tag_name = true;
      }
      if (in_tag_name && trimmed_value[pos].match(/\s/)) {
        in_tag_name = false;
      }
      if (in_tag_name && !trimmed_value[pos].match(/</)) {
        current_tag += trimmed_value[pos];
      }
      const is_void2 = void_els.includes(current_tag);
      if (is_void2 && trimmed_value[pos].match(/>/) || (trimmed_value[pos - 1] + trimmed_value[pos]).match(/\/>/)) {
        cbPos--;
      }
      if ((trimmed_value[pos - 1] + trimmed_value[pos]).match(/<\//)) {
        let inner_indent = 0;
        while (inner_indent > -1) {
          if (trimmed_value[pos].match(/>/)) {
            pos++;
            inner_indent -= 1;
            cbPos -= 2;
          } else {
            pos++;
          }
        }
      }
      pos++;
    }
    const match = RE_SVELTE_TAG.exec(trimmed_value.substring(0, pos).trim());
    if (!match) return;
    return eat2(is_svelte_tag[1] + match[0])({
      type: "svelteTag",
      value: match[0],
      name: match[1]
    });
  }
}
var RE_SVELTE_BLOCK_START = /(^\s*){[#:/@]/;
var RE_SVELTE_BLOCK = /^{[#:/@](else if|[a-z]+).*}$/;
function parse_svelte_block(eat2, value, silent) {
  const is_svelte_block = RE_SVELTE_BLOCK_START.exec(value);
  if (is_svelte_block) {
    if (silent) return true;
    const trimmed_value = value.trim();
    let cbPos = 0;
    let pos = 1;
    while (cbPos > -1) {
      if (trimmed_value[pos].match(/{/)) cbPos++;
      if (trimmed_value[pos].match(/}/)) cbPos--;
      pos++;
    }
    const match = RE_SVELTE_BLOCK.exec(trimmed_value.substring(0, pos));
    if (!match) return;
    return eat2(is_svelte_block[1] + match[0])({
      type: "svelteBlock",
      value: `${is_svelte_block[1]}${match[0]}`,
      name: match[1]
    });
  }
}
var dotAllPolyfill = "[\0-]";
var attributeName = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
var unquoted = "[^\"'=<>`\\u0000-\\u0020]+";
var singleQuoted = "'[^']*'";
var doubleQuoted = '"[^"]*"';
var jsProps = "{.*}".replace(".", dotAllPolyfill);
var attributeValue = "(?:" + unquoted + "|" + singleQuoted + "|" + doubleQuoted + "|" + jsProps + ")";
var attribute = "(?:\\s+" + attributeName + "(?:\\s*=\\s*" + attributeValue + ")?)";
var openTag = "<[A-Za-z]*[A-Za-z0-9\\.\\-]*" + attribute + "*\\s*\\/?>";
var closeTag = "<\\/[A-Za-z][A-Za-z0-9\\.\\-]*\\s*>";
var openCloseTag = new RegExp("^(?:" + openTag + "|" + closeTag + ")");
var tab = "	";
var space2 = " ";
var lineFeed = "\n";
var lessThan = "<";
var rawOpenExpression = /^<(script|pre|style)(?=(\s|>|$))/i;
var rawCloseExpression = /<\/(script|pre|style)>/i;
var commentOpenExpression = /^<!--/;
var commentCloseExpression = /-->/;
var instructionOpenExpression = /^<\?/;
var instructionCloseExpression = /\?>/;
var directiveOpenExpression = /^<![A-Za-z]/;
var directiveCloseExpression = />/;
var cdataOpenExpression = /^<!\[CDATA\[/;
var cdataCloseExpression = /\]\]>/;
var elementCloseExpression = /^$/;
var otherElementOpenExpression = new RegExp(openCloseTag.source + "\\s*$");
var fragmentOpenExpression = /^<>/;
function blockHtml(eat2, value, silent) {
  const blocks = "[a-z\\.]*(\\.){0,1}[a-z][a-z0-9\\.]*";
  const elementOpenExpression = new RegExp(
    "^</?(" + blocks + ")(?=(\\s|/?>|$))",
    "i"
  );
  const length = value.length;
  let index2 = 0;
  let next2;
  let line;
  let offset2;
  let character;
  let sequence2;
  const sequences = [
    [rawOpenExpression, rawCloseExpression, true],
    [commentOpenExpression, commentCloseExpression, true],
    [instructionOpenExpression, instructionCloseExpression, true],
    [directiveOpenExpression, directiveCloseExpression, true],
    [cdataOpenExpression, cdataCloseExpression, true],
    [elementOpenExpression, elementCloseExpression, true],
    [fragmentOpenExpression, elementCloseExpression, true],
    [otherElementOpenExpression, elementCloseExpression, false]
  ];
  while (index2 < length) {
    character = value.charAt(index2);
    if (character !== tab && character !== space2) {
      break;
    }
    index2++;
  }
  if (value.charAt(index2) !== lessThan) {
    return;
  }
  next2 = value.indexOf(lineFeed, index2 + 1);
  next2 = next2 === -1 ? length : next2;
  line = value.slice(index2, next2);
  offset2 = -1;
  const count = sequences.length;
  while (++offset2 < count) {
    if (sequences[offset2][0].test(line)) {
      sequence2 = sequences[offset2];
      break;
    }
  }
  if (!sequence2) {
    return;
  }
  if (silent) {
    return sequence2[2];
  }
  index2 = next2;
  if (!sequence2[1].test(line)) {
    while (index2 < length) {
      next2 = value.indexOf(lineFeed, index2 + 1);
      next2 = next2 === -1 ? length : next2;
      line = value.slice(index2 + 1, next2);
      if (sequence2[1].test(line)) {
        if (line) {
          index2 = next2;
        }
        break;
      }
      index2 = next2;
    }
  }
  const subvalue = value.slice(0, index2);
  return eat2(subvalue)({ type: "html", value: subvalue });
}
function mdsvex_parser() {
  const Parser5 = this.Parser;
  const block_tokenizers = Parser5.prototype.blockTokenizers;
  const methods = Parser5.prototype.blockMethods;
  block_tokenizers.svelteBlock = parse_svelte_block;
  block_tokenizers.svelteTag = parse_svelte_tag;
  block_tokenizers.html = blockHtml;
  block_tokenizers.indentedCode = indentedCode;
  methods.splice(methods.indexOf("html"), 0, "svelteBlock");
  methods.splice(methods.indexOf("html"), 0, "svelteTag");
}
function indentedCode() {
  return true;
}
var extend$1 = extend$5;
var bail = bail_1;
var vfile = vfile$2;
var trough = trough_1;
var plain = isPlainObj;
var unified_1 = unified$1().freeze();
var slice = [].slice;
var own = {}.hasOwnProperty;
var pipeline = trough().use(pipelineParse).use(pipelineRun).use(pipelineStringify);
function pipelineParse(p2, ctx) {
  ctx.tree = p2.parse(ctx.file);
}
function pipelineRun(p2, ctx, next2) {
  p2.run(ctx.tree, ctx.file, done);
  function done(err, tree, file) {
    if (err) {
      next2(err);
    } else {
      ctx.tree = tree;
      ctx.file = file;
      next2();
    }
  }
}
function pipelineStringify(p2, ctx) {
  ctx.file.contents = p2.stringify(ctx.tree, ctx.file);
}
function unified$1() {
  var attachers = [];
  var transformers = trough();
  var namespace = {};
  var frozen = false;
  var freezeIndex = -1;
  processor.data = data3;
  processor.freeze = freeze;
  processor.attachers = attachers;
  processor.use = use;
  processor.parse = parse8;
  processor.stringify = stringify2;
  processor.run = run2;
  processor.runSync = runSync;
  processor.process = process2;
  processor.processSync = processSync;
  return processor;
  function processor() {
    var destination = unified$1();
    var length = attachers.length;
    var index2 = -1;
    while (++index2 < length) {
      destination.use.apply(null, attachers[index2]);
    }
    destination.data(extend$1(true, {}, namespace));
    return destination;
  }
  function freeze() {
    var values;
    var plugin;
    var options2;
    var transformer;
    if (frozen) {
      return processor;
    }
    while (++freezeIndex < attachers.length) {
      values = attachers[freezeIndex];
      plugin = values[0];
      options2 = values[1];
      transformer = null;
      if (options2 === false) {
        continue;
      }
      if (options2 === true) {
        values[1] = void 0;
      }
      transformer = plugin.apply(processor, values.slice(1));
      if (typeof transformer === "function") {
        transformers.use(transformer);
      }
    }
    frozen = true;
    freezeIndex = Infinity;
    return processor;
  }
  function data3(key2, value) {
    if (typeof key2 === "string") {
      if (arguments.length === 2) {
        assertUnfrozen("data", frozen);
        namespace[key2] = value;
        return processor;
      }
      return own.call(namespace, key2) && namespace[key2] || null;
    }
    if (key2) {
      assertUnfrozen("data", frozen);
      namespace = key2;
      return processor;
    }
    return namespace;
  }
  function use(value) {
    var settings;
    assertUnfrozen("use", frozen);
    if (value === null || value === void 0) ;
    else if (typeof value === "function") {
      addPlugin.apply(null, arguments);
    } else if (typeof value === "object") {
      if ("length" in value) {
        addList(value);
      } else {
        addPreset(value);
      }
    } else {
      throw new Error("Expected usable value, not `" + value + "`");
    }
    if (settings) {
      namespace.settings = extend$1(namespace.settings || {}, settings);
    }
    return processor;
    function addPreset(result) {
      addList(result.plugins);
      if (result.settings) {
        settings = extend$1(settings || {}, result.settings);
      }
    }
    function add(value2) {
      if (typeof value2 === "function") {
        addPlugin(value2);
      } else if (typeof value2 === "object") {
        if ("length" in value2) {
          addPlugin.apply(null, value2);
        } else {
          addPreset(value2);
        }
      } else {
        throw new Error("Expected usable value, not `" + value2 + "`");
      }
    }
    function addList(plugins) {
      var length;
      var index2;
      if (plugins === null || plugins === void 0) ;
      else if (typeof plugins === "object" && "length" in plugins) {
        length = plugins.length;
        index2 = -1;
        while (++index2 < length) {
          add(plugins[index2]);
        }
      } else {
        throw new Error("Expected a list of plugins, not `" + plugins + "`");
      }
    }
    function addPlugin(plugin, value2) {
      var entry = find2(plugin);
      if (entry) {
        if (plain(entry[1]) && plain(value2)) {
          value2 = extend$1(entry[1], value2);
        }
        entry[1] = value2;
      } else {
        attachers.push(slice.call(arguments));
      }
    }
  }
  function find2(plugin) {
    var length = attachers.length;
    var index2 = -1;
    var entry;
    while (++index2 < length) {
      entry = attachers[index2];
      if (entry[0] === plugin) {
        return entry;
      }
    }
  }
  function parse8(doc) {
    var file = vfile(doc);
    var Parser5;
    freeze();
    Parser5 = processor.Parser;
    assertParser("parse", Parser5);
    if (newable(Parser5, "parse")) {
      return new Parser5(String(file), file).parse();
    }
    return Parser5(String(file), file);
  }
  function run2(node, file, cb) {
    assertNode(node);
    freeze();
    if (!cb && typeof file === "function") {
      cb = file;
      file = null;
    }
    if (!cb) {
      return new Promise(executor);
    }
    executor(null, cb);
    function executor(resolve, reject) {
      transformers.run(node, vfile(file), done);
      function done(err, tree, file2) {
        tree = tree || node;
        if (err) {
          reject(err);
        } else if (resolve) {
          resolve(tree);
        } else {
          cb(null, tree, file2);
        }
      }
    }
  }
  function runSync(node, file) {
    var complete = false;
    var result;
    run2(node, file, done);
    assertDone("runSync", "run", complete);
    return result;
    function done(err, tree) {
      complete = true;
      bail(err);
      result = tree;
    }
  }
  function stringify2(node, doc) {
    var file = vfile(doc);
    var Compiler;
    freeze();
    Compiler = processor.Compiler;
    assertCompiler("stringify", Compiler);
    assertNode(node);
    if (newable(Compiler, "compile")) {
      return new Compiler(node, file).compile();
    }
    return Compiler(node, file);
  }
  function process2(doc, cb) {
    freeze();
    assertParser("process", processor.Parser);
    assertCompiler("process", processor.Compiler);
    if (!cb) {
      return new Promise(executor);
    }
    executor(null, cb);
    function executor(resolve, reject) {
      var file = vfile(doc);
      pipeline.run(processor, { file }, done);
      function done(err) {
        if (err) {
          reject(err);
        } else if (resolve) {
          resolve(file);
        } else {
          cb(null, file);
        }
      }
    }
  }
  function processSync(doc) {
    var complete = false;
    var file;
    freeze();
    assertParser("processSync", processor.Parser);
    assertCompiler("processSync", processor.Compiler);
    file = vfile(doc);
    process2(file, done);
    assertDone("processSync", "process", complete);
    return file;
    function done(err) {
      complete = true;
      bail(err);
    }
  }
}
function newable(value, name2) {
  return typeof value === "function" && value.prototype && // A function with keys in its prototype is probably a constructor.
  // Classes prototype methods are not enumerable, so we check if some value
  // exists in the prototype.
  (keys(value.prototype) || name2 in value.prototype);
}
function keys(value) {
  var key2;
  for (key2 in value) {
    return true;
  }
  return false;
}
function assertParser(name2, Parser5) {
  if (typeof Parser5 !== "function") {
    throw new Error("Cannot `" + name2 + "` without `Parser`");
  }
}
function assertCompiler(name2, Compiler) {
  if (typeof Compiler !== "function") {
    throw new Error("Cannot `" + name2 + "` without `Compiler`");
  }
}
function assertUnfrozen(name2, frozen) {
  if (frozen) {
    throw new Error(
      "Cannot invoke `" + name2 + "` on a frozen processor.\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`."
    );
  }
}
function assertNode(node) {
  if (!node || typeof node.type !== "string") {
    throw new Error("Expected node, got `" + node + "`");
  }
}
function assertDone(name2, asyncName, complete) {
  if (!complete) {
    throw new Error(
      "`" + name2 + "` finished async. Use `" + asyncName + "` instead"
    );
  }
}
var nlcstToString_1 = nlcstToString;
function nlcstToString(node, separator) {
  var sep = separator || "";
  var values;
  var length;
  var children;
  if (!node || !("length" in node) && !node.type) {
    throw new Error("Expected node, not `" + node + "`");
  }
  if (typeof node.value === "string") {
    return node.value;
  }
  children = "length" in node ? node : node.children;
  length = children.length;
  if (length === 1 && "value" in children[0]) {
    return children[0].value;
  }
  values = [];
  while (length--) {
    values[length] = nlcstToString(children[length], sep);
  }
  return values.join(sep);
}
var toString$2 = nlcstToString_1;
var tokenizer$1 = tokenizerFactory;
function tokenizerFactory(childType, expression) {
  return tokenizer4;
  function tokenizer4(node) {
    var children = [];
    var tokens = node.children;
    var type2 = node.type;
    var length = tokens.length;
    var index2 = -1;
    var lastIndex = length - 1;
    var start2 = 0;
    var first2;
    var last;
    var parent;
    while (++index2 < length) {
      if (index2 === lastIndex || tokens[index2].type === childType && expression.test(toString$2(tokens[index2]))) {
        first2 = tokens[start2];
        last = tokens[index2];
        parent = {
          type: type2,
          children: tokens.slice(start2, index2 + 1)
        };
        if (first2.position && last.position) {
          parent.position = {
            start: first2.position.start,
            end: last.position.end
          };
        }
        children.push(parent);
        start2 = index2 + 1;
      }
    }
    return children;
  }
}
var tokenizer3 = tokenizer$1;
var parser = parserFactory;
function parserFactory(options2) {
  var type2 = options2.type;
  var tokenizerProperty = options2.tokenizer;
  var delimiter = options2.delimiter;
  var tokenize2 = delimiter && tokenizer3(options2.delimiterType, delimiter);
  return parser2;
  function parser2(value) {
    var children = this[tokenizerProperty](value);
    return {
      type: type2,
      children: tokenize2 ? tokenize2(children) : children
    };
  }
}
var expressions$1 = {
  affixSymbol: /^([\)\]\}\u0F3B\u0F3D\u169C\u2046\u207E\u208E\u2309\u230B\u232A\u2769\u276B\u276D\u276F\u2771\u2773\u2775\u27C6\u27E7\u27E9\u27EB\u27ED\u27EF\u2984\u2986\u2988\u298A\u298C\u298E\u2990\u2992\u2994\u2996\u2998\u29D9\u29DB\u29FD\u2E23\u2E25\u2E27\u2E29\u3009\u300B\u300D\u300F\u3011\u3015\u3017\u3019\u301B\u301E\u301F\uFD3E\uFE18\uFE36\uFE38\uFE3A\uFE3C\uFE3E\uFE40\uFE42\uFE44\uFE48\uFE5A\uFE5C\uFE5E\uFF09\uFF3D\uFF5D\uFF60\uFF63]|["'\xBB\u2019\u201D\u203A\u2E03\u2E05\u2E0A\u2E0D\u2E1D\u2E21]|[!\.\?\u2026\u203D])\1*$/,
  newLine: /^[ \t]*((\r?\n|\r)[\t ]*)+$/,
  newLineMulti: /^[ \t]*((\r?\n|\r)[\t ]*){2,}$/,
  terminalMarker: /^((?:[!\.\?\u2026\u203D])+)$/,
  wordSymbolInner: /^((?:[&'\x2D\.:=\?@\xAD\xB7\u2010\u2011\u2019\u2027])|(?:_)+)$/,
  numerical: /^(?:[0-9\xB2\xB3\xB9\xBC-\xBE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D58-\u0D5E\u0D66-\u0D78\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]|\uD800[\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDEE1-\uDEFB\uDF20-\uDF23\uDF41\uDF4A\uDFD1-\uDFD5]|\uD801[\uDCA0-\uDCA9]|\uD802[\uDC58-\uDC5F\uDC79-\uDC7F\uDCA7-\uDCAF\uDCFB-\uDCFF\uDD16-\uDD1B\uDDBC\uDDBD\uDDC0-\uDDCF\uDDD2-\uDDFF\uDE40-\uDE48\uDE7D\uDE7E\uDE9D-\uDE9F\uDEEB-\uDEEF\uDF58-\uDF5F\uDF78-\uDF7F\uDFA9-\uDFAF]|\uD803[\uDCFA-\uDCFF\uDD30-\uDD39\uDE60-\uDE7E\uDF1D-\uDF26\uDF51-\uDF54]|\uD804[\uDC52-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDDE1-\uDDF4\uDEF0-\uDEF9]|\uD805[\uDC50-\uDC59\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF3B]|\uD806[\uDCE0-\uDCF2]|\uD807[\uDC50-\uDC6C\uDD50-\uDD59\uDDA0-\uDDA9\uDFC0-\uDFD4]|\uD809[\uDC00-\uDC6E]|\uD81A[\uDE60-\uDE69\uDF50-\uDF59\uDF5B-\uDF61]|\uD81B[\uDE80-\uDE96]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDFCE-\uDFFF]|\uD838[\uDD40-\uDD49\uDEF0-\uDEF9]|\uD83A[\uDCC7-\uDCCF\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D]|\uD83C[\uDD00-\uDD0C])+$/,
  digitStart: /^\d/,
  lowerInitial: /^(?:[a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0560-\u0588\u10D0-\u10FA\u10FD-\u10FF\u13F8-\u13FD\u1C80-\u1C88\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7AF\uA7B5\uA7B7\uA7B9\uA7BB\uA7BD\uA7BF\uA7C3\uA7FA\uAB30-\uAB5A\uAB60-\uAB67\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A]|\uD801[\uDC28-\uDC4F\uDCD8-\uDCFB]|\uD803[\uDCC0-\uDCF2]|\uD806[\uDCC0-\uDCDF]|\uD81B[\uDE60-\uDE7F]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD83A[\uDD22-\uDD43])/,
  surrogates: /[\uD800-\uDFFF]/,
  punctuation: /[!"'-\),-\/:;\?\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u201F\u2022-\u2027\u2032-\u203A\u203C-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDFFF]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/,
  word: /[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xBC-\xBE\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u052F\u0531-\u0556\u0559\u0560-\u0588\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05EF-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u07FD\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D3-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09F4-\u09F9\u09FC\u09FE\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71-\u0B77\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BF2\u0C00-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C78-\u0C7E\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D63\u0D66-\u0D78\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F33\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u17F0-\u17F9\u180B-\u180D\u1810-\u1819\u1820-\u1878\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABE\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CD0-\u1CD2\u1CD4-\u1CFA\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u20D0-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2CFD\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3192-\u3195\u31A0-\u31BA\u31F0-\u31FF\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u3400-\u4DB5\u4E00-\u9FEF\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA672\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7C6\uA7F7-\uA827\uA830-\uA835\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB67\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0-\uDEFB\uDF00-\uDF23\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC58-\uDC76\uDC79-\uDC9E\uDCA7-\uDCAF\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDD1B\uDD20-\uDD39\uDD80-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE38-\uDE3A\uDE3F-\uDE48\uDE60-\uDE7E\uDE80-\uDE9F\uDEC0-\uDEC7\uDEC9-\uDEE6\uDEEB-\uDEEF\uDF00-\uDF35\uDF40-\uDF55\uDF58-\uDF72\uDF78-\uDF91\uDFA9-\uDFAF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDD27\uDD30-\uDD39\uDE60-\uDE7E\uDF00-\uDF27\uDF30-\uDF54\uDFE0-\uDFF6]|\uD804[\uDC00-\uDC46\uDC52-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD44-\uDD46\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDC9-\uDDCC\uDDD0-\uDDDA\uDDDC\uDDE1-\uDDF4\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3B-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC5E\uDC5F\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF1D-\uDF2B\uDF30-\uDF3B]|\uD806[\uDC00-\uDC3A\uDCA0-\uDCF2\uDCFF\uDDA0-\uDDA7\uDDAA-\uDDD7\uDDDA-\uDDE1\uDDE3\uDDE4\uDE00-\uDE3E\uDE47\uDE50-\uDE99\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC6C\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD8E\uDD90\uDD91\uDD93-\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF6\uDFC0-\uDFD4]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE96\uDF00-\uDF4A\uDF4F-\uDF87\uDF8F-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD00-\uDD2C\uDD30-\uDD3D\uDD40-\uDD49\uDD4E\uDEC0-\uDEF9]|\uD83A[\uDC00-\uDCC4\uDCC7-\uDCD6\uDD00-\uDD4B\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD00-\uDD0C]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/,
  whiteSpace: /[\t-\r \x85\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/
};
var arrayIterate;
var hasRequiredArrayIterate;
function requireArrayIterate() {
  if (hasRequiredArrayIterate) return arrayIterate;
  hasRequiredArrayIterate = 1;
  arrayIterate = iterate;
  var own2 = {}.hasOwnProperty;
  function iterate(values, callback, context2) {
    var index2 = -1;
    var result;
    if (!values) {
      throw new Error("Iterate requires that |this| not be " + values);
    }
    if (!own2.call(values, "length")) {
      throw new Error("Iterate requires that |this| has a `length`");
    }
    if (typeof callback !== "function") {
      throw new Error("`callback` must be a function");
    }
    while (++index2 < values.length) {
      if (!(index2 in values)) {
        continue;
      }
      result = callback.call(context2, values[index2], index2, values);
      if (typeof result === "number") {
        if (result < 0) {
          index2 = 0;
        }
        index2 = result - 1;
      }
    }
  }
  return arrayIterate;
}
var unistUtilModifyChildren;
var hasRequiredUnistUtilModifyChildren;
function requireUnistUtilModifyChildren() {
  if (hasRequiredUnistUtilModifyChildren) return unistUtilModifyChildren;
  hasRequiredUnistUtilModifyChildren = 1;
  var iterate = requireArrayIterate();
  unistUtilModifyChildren = modifierFactory;
  function modifierFactory(callback) {
    return iteratorFactory(wrapperFactory(callback));
  }
  function iteratorFactory(callback) {
    return iterator;
    function iterator(parent) {
      var children = parent && parent.children;
      if (!children) {
        throw new Error("Missing children in `parent` for `modifier`");
      }
      return iterate(children, callback, parent);
    }
  }
  function wrapperFactory(callback) {
    return wrapper;
    function wrapper(value, index2) {
      return callback(value, index2, this);
    }
  }
  return unistUtilModifyChildren;
}
var mergeInitialWordSymbol_1;
var hasRequiredMergeInitialWordSymbol;
function requireMergeInitialWordSymbol() {
  if (hasRequiredMergeInitialWordSymbol) return mergeInitialWordSymbol_1;
  hasRequiredMergeInitialWordSymbol = 1;
  var toString5 = nlcstToString_1;
  var modifyChildren = requireUnistUtilModifyChildren();
  mergeInitialWordSymbol_1 = modifyChildren(mergeInitialWordSymbol);
  function mergeInitialWordSymbol(child, index2, parent) {
    var children;
    var next2;
    if (child.type !== "SymbolNode" && child.type !== "PunctuationNode" || toString5(child) !== "&") {
      return;
    }
    children = parent.children;
    next2 = children[index2 + 1];
    if (index2 !== 0 && children[index2 - 1].type === "WordNode" || !(next2 && next2.type === "WordNode")) {
      return;
    }
    children.splice(index2, 1);
    next2.children.unshift(child);
    if (next2.position && child.position) {
      next2.position.start = child.position.start;
    }
    return index2 - 1;
  }
  return mergeInitialWordSymbol_1;
}
var mergeFinalWordSymbol_1;
var hasRequiredMergeFinalWordSymbol;
function requireMergeFinalWordSymbol() {
  if (hasRequiredMergeFinalWordSymbol) return mergeFinalWordSymbol_1;
  hasRequiredMergeFinalWordSymbol = 1;
  var toString5 = nlcstToString_1;
  var modifyChildren = requireUnistUtilModifyChildren();
  mergeFinalWordSymbol_1 = modifyChildren(mergeFinalWordSymbol);
  function mergeFinalWordSymbol(child, index2, parent) {
    var children;
    var prev;
    var next2;
    if (index2 !== 0 && (child.type === "SymbolNode" || child.type === "PunctuationNode") && toString5(child) === "-") {
      children = parent.children;
      prev = children[index2 - 1];
      next2 = children[index2 + 1];
      if ((!next2 || next2.type !== "WordNode") && prev && prev.type === "WordNode") {
        children.splice(index2, 1);
        prev.children.push(child);
        if (prev.position && child.position) {
          prev.position.end = child.position.end;
        }
        return index2;
      }
    }
  }
  return mergeFinalWordSymbol_1;
}
var mergeInnerWordSymbol_1;
var hasRequiredMergeInnerWordSymbol;
function requireMergeInnerWordSymbol() {
  if (hasRequiredMergeInnerWordSymbol) return mergeInnerWordSymbol_1;
  hasRequiredMergeInnerWordSymbol = 1;
  var toString5 = nlcstToString_1;
  var modifyChildren = requireUnistUtilModifyChildren();
  var expressions2 = expressions$1;
  mergeInnerWordSymbol_1 = modifyChildren(mergeInnerWordSymbol);
  var wordSymbolInner = expressions2.wordSymbolInner;
  function mergeInnerWordSymbol(child, index2, parent) {
    var siblings2;
    var sibling2;
    var prev;
    var last;
    var position2;
    var tokens;
    var queue;
    if (index2 !== 0 && (child.type === "SymbolNode" || child.type === "PunctuationNode")) {
      siblings2 = parent.children;
      prev = siblings2[index2 - 1];
      if (prev && prev.type === "WordNode") {
        position2 = index2 - 1;
        tokens = [];
        queue = [];
        while (siblings2[++position2]) {
          sibling2 = siblings2[position2];
          if (sibling2.type === "WordNode") {
            tokens = tokens.concat(queue, sibling2.children);
            queue = [];
          } else if ((sibling2.type === "SymbolNode" || sibling2.type === "PunctuationNode") && wordSymbolInner.test(toString5(sibling2))) {
            queue.push(sibling2);
          } else {
            break;
          }
        }
        if (tokens.length !== 0) {
          if (queue.length !== 0) {
            position2 -= queue.length;
          }
          siblings2.splice(index2, position2 - index2);
          prev.children = prev.children.concat(tokens);
          last = tokens[tokens.length - 1];
          if (prev.position && last.position) {
            prev.position.end = last.position.end;
          }
          return index2;
        }
      }
    }
  }
  return mergeInnerWordSymbol_1;
}
var mergeInnerWordSlash_1;
var hasRequiredMergeInnerWordSlash;
function requireMergeInnerWordSlash() {
  if (hasRequiredMergeInnerWordSlash) return mergeInnerWordSlash_1;
  hasRequiredMergeInnerWordSlash = 1;
  var toString5 = nlcstToString_1;
  var modifyChildren = requireUnistUtilModifyChildren();
  mergeInnerWordSlash_1 = modifyChildren(mergeInnerWordSlash);
  var slash = "/";
  function mergeInnerWordSlash(child, index2, parent) {
    var siblings2 = parent.children;
    var prev;
    var next2;
    var prevValue;
    var nextValue;
    var queue;
    var tail;
    var count;
    prev = siblings2[index2 - 1];
    next2 = siblings2[index2 + 1];
    if (prev && prev.type === "WordNode" && (child.type === "SymbolNode" || child.type === "PunctuationNode") && toString5(child) === slash) {
      prevValue = toString5(prev);
      tail = child;
      queue = [child];
      count = 1;
      if (next2 && next2.type === "WordNode") {
        nextValue = toString5(next2);
        tail = next2;
        queue = queue.concat(next2.children);
        count++;
      }
      if (prevValue.length < 3 && (!nextValue || nextValue.length < 3)) {
        prev.children = prev.children.concat(queue);
        siblings2.splice(index2, count);
        if (prev.position && tail.position) {
          prev.position.end = tail.position.end;
        }
        return index2;
      }
    }
  }
  return mergeInnerWordSlash_1;
}
var mergeInitialisms_1;
var hasRequiredMergeInitialisms;
function requireMergeInitialisms() {
  if (hasRequiredMergeInitialisms) return mergeInitialisms_1;
  hasRequiredMergeInitialisms = 1;
  var toString5 = nlcstToString_1;
  var modifyChildren = requireUnistUtilModifyChildren();
  var expressions2 = expressions$1;
  mergeInitialisms_1 = modifyChildren(mergeInitialisms);
  var numerical = expressions2.numerical;
  function mergeInitialisms(child, index2, parent) {
    var siblings2;
    var prev;
    var children;
    var length;
    var position2;
    var otherChild;
    var isAllDigits;
    var value;
    if (index2 !== 0 && toString5(child) === ".") {
      siblings2 = parent.children;
      prev = siblings2[index2 - 1];
      children = prev.children;
      length = children && children.length;
      if (prev.type === "WordNode" && length !== 1 && length % 2 !== 0) {
        position2 = length;
        isAllDigits = true;
        while (children[--position2]) {
          otherChild = children[position2];
          value = toString5(otherChild);
          if (position2 % 2 === 0) {
            if (value.length > 1) {
              return;
            }
            if (!numerical.test(value)) {
              isAllDigits = false;
            }
          } else if (value !== ".") {
            if (position2 < length - 2) {
              break;
            } else {
              return;
            }
          }
        }
        if (!isAllDigits) {
          siblings2.splice(index2, 1);
          children.push(child);
          if (prev.position && child.position) {
            prev.position.end = child.position.end;
          }
          return index2;
        }
      }
    }
  }
  return mergeInitialisms_1;
}
var mergeWords;
var hasRequiredMergeWords;
function requireMergeWords() {
  if (hasRequiredMergeWords) return mergeWords;
  hasRequiredMergeWords = 1;
  var modifyChildren = requireUnistUtilModifyChildren();
  mergeWords = modifyChildren(mergeFinalWordSymbol);
  function mergeFinalWordSymbol(child, index2, parent) {
    var siblings2 = parent.children;
    var next2;
    if (child.type === "WordNode") {
      next2 = siblings2[index2 + 1];
      if (next2 && next2.type === "WordNode") {
        siblings2.splice(index2 + 1, 1);
        child.children = child.children.concat(next2.children);
        if (next2.position && child.position) {
          child.position.end = next2.position.end;
        }
        return index2;
      }
    }
  }
  return mergeWords;
}
var unistUtilVisitChildren;
var hasRequiredUnistUtilVisitChildren;
function requireUnistUtilVisitChildren() {
  if (hasRequiredUnistUtilVisitChildren) return unistUtilVisitChildren;
  hasRequiredUnistUtilVisitChildren = 1;
  unistUtilVisitChildren = visitChildren;
  function visitChildren(callback) {
    return visitor;
    function visitor(parent) {
      var index2 = -1;
      var children = parent && parent.children;
      if (!children) {
        throw new Error("Missing children in `parent` for `visitor`");
      }
      while (++index2 in children) {
        callback(children[index2], index2, parent);
      }
    }
  }
  return unistUtilVisitChildren;
}
var patchPosition_1;
var hasRequiredPatchPosition;
function requirePatchPosition() {
  if (hasRequiredPatchPosition) return patchPosition_1;
  hasRequiredPatchPosition = 1;
  var visitChildren = requireUnistUtilVisitChildren();
  patchPosition_1 = visitChildren(patchPosition);
  function patchPosition(child, index2, node) {
    var siblings2 = node.children;
    if (!child.position) {
      return;
    }
    if (index2 === 0 && (!node.position || /* istanbul ignore next */
    !node.position.start)) {
      patch(node);
      node.position.start = child.position.start;
    }
    if (index2 === siblings2.length - 1 && (!node.position || !node.position.end)) {
      patch(node);
      node.position.end = child.position.end;
    }
  }
  function patch(node) {
    if (!node.position) {
      node.position = {};
    }
  }
  return patchPosition_1;
}
var mergeNonWordSentences_1;
var hasRequiredMergeNonWordSentences;
function requireMergeNonWordSentences() {
  if (hasRequiredMergeNonWordSentences) return mergeNonWordSentences_1;
  hasRequiredMergeNonWordSentences = 1;
  var modifyChildren = requireUnistUtilModifyChildren();
  mergeNonWordSentences_1 = modifyChildren(mergeNonWordSentences);
  function mergeNonWordSentences(child, index2, parent) {
    var children = child.children;
    var position2 = -1;
    var prev;
    var next2;
    while (children[++position2]) {
      if (children[position2].type === "WordNode") {
        return;
      }
    }
    prev = parent.children[index2 - 1];
    if (prev) {
      prev.children = prev.children.concat(children);
      parent.children.splice(index2, 1);
      if (prev.position && child.position) {
        prev.position.end = child.position.end;
      }
      return index2;
    }
    next2 = parent.children[index2 + 1];
    if (next2) {
      next2.children = children.concat(next2.children);
      if (next2.position && child.position) {
        next2.position.start = child.position.start;
      }
      parent.children.splice(index2, 1);
    }
  }
  return mergeNonWordSentences_1;
}
var mergeAffixSymbol_1;
var hasRequiredMergeAffixSymbol;
function requireMergeAffixSymbol() {
  if (hasRequiredMergeAffixSymbol) return mergeAffixSymbol_1;
  hasRequiredMergeAffixSymbol = 1;
  var toString5 = nlcstToString_1;
  var modifyChildren = requireUnistUtilModifyChildren();
  var expressions2 = expressions$1;
  mergeAffixSymbol_1 = modifyChildren(mergeAffixSymbol);
  var affixSymbol = expressions2.affixSymbol;
  function mergeAffixSymbol(child, index2, parent) {
    var children = child.children;
    var first2;
    var second;
    var prev;
    if (children && children.length !== 0 && index2 !== 0) {
      first2 = children[0];
      second = children[1];
      prev = parent.children[index2 - 1];
      if ((first2.type === "SymbolNode" || first2.type === "PunctuationNode") && affixSymbol.test(toString5(first2))) {
        prev.children.push(children.shift());
        if (first2.position && prev.position) {
          prev.position.end = first2.position.end;
        }
        if (second && second.position && child.position) {
          child.position.start = second.position.start;
        }
        return index2 - 1;
      }
    }
  }
  return mergeAffixSymbol_1;
}
var mergeInitialLowerCaseLetterSentences_1;
var hasRequiredMergeInitialLowerCaseLetterSentences;
function requireMergeInitialLowerCaseLetterSentences() {
  if (hasRequiredMergeInitialLowerCaseLetterSentences) return mergeInitialLowerCaseLetterSentences_1;
  hasRequiredMergeInitialLowerCaseLetterSentences = 1;
  var toString5 = nlcstToString_1;
  var modifyChildren = requireUnistUtilModifyChildren();
  var expressions2 = expressions$1;
  mergeInitialLowerCaseLetterSentences_1 = modifyChildren(mergeInitialLowerCaseLetterSentences);
  var lowerInitial = expressions2.lowerInitial;
  function mergeInitialLowerCaseLetterSentences(child, index2, parent) {
    var children = child.children;
    var position2;
    var node;
    var siblings2;
    var prev;
    if (children && children.length !== 0 && index2 !== 0) {
      position2 = -1;
      while (children[++position2]) {
        node = children[position2];
        if (node.type === "WordNode") {
          if (!lowerInitial.test(toString5(node))) {
            return;
          }
          siblings2 = parent.children;
          prev = siblings2[index2 - 1];
          prev.children = prev.children.concat(children);
          siblings2.splice(index2, 1);
          if (prev.position && child.position) {
            prev.position.end = child.position.end;
          }
          return index2;
        }
        if (node.type === "SymbolNode" || node.type === "PunctuationNode") {
          return;
        }
      }
    }
  }
  return mergeInitialLowerCaseLetterSentences_1;
}
var mergeInitialDigitSentences_1;
var hasRequiredMergeInitialDigitSentences;
function requireMergeInitialDigitSentences() {
  if (hasRequiredMergeInitialDigitSentences) return mergeInitialDigitSentences_1;
  hasRequiredMergeInitialDigitSentences = 1;
  var toString5 = nlcstToString_1;
  var modifyChildren = requireUnistUtilModifyChildren();
  var expressions2 = expressions$1;
  mergeInitialDigitSentences_1 = modifyChildren(mergeInitialDigitSentences);
  var digit = expressions2.digitStart;
  function mergeInitialDigitSentences(child, index2, parent) {
    var children = child.children;
    var siblings2 = parent.children;
    var prev = siblings2[index2 - 1];
    var head2 = children[0];
    if (prev && head2 && head2.type === "WordNode" && digit.test(toString5(head2))) {
      prev.children = prev.children.concat(children);
      siblings2.splice(index2, 1);
      if (prev.position && child.position) {
        prev.position.end = child.position.end;
      }
      return index2;
    }
  }
  return mergeInitialDigitSentences_1;
}
var mergePrefixExceptions_1;
var hasRequiredMergePrefixExceptions;
function requireMergePrefixExceptions() {
  if (hasRequiredMergePrefixExceptions) return mergePrefixExceptions_1;
  hasRequiredMergePrefixExceptions = 1;
  var toString5 = nlcstToString_1;
  var modifyChildren = requireUnistUtilModifyChildren();
  mergePrefixExceptions_1 = modifyChildren(mergePrefixExceptions);
  var abbreviationPrefix = new RegExp(
    "^([0-9]{1,3}|[a-z]|al|ca|cap|cca|cent|cf|cit|con|cp|cwt|ead|etc|ff|fl|ibid|id|nem|op|pro|seq|sic|stat|tem|viz)$"
  );
  function mergePrefixExceptions(child, index2, parent) {
    var children = child.children;
    var period2;
    var node;
    var next2;
    if (children && children.length > 1) {
      period2 = children[children.length - 1];
      if (period2 && toString5(period2) === ".") {
        node = children[children.length - 2];
        if (node && node.type === "WordNode" && abbreviationPrefix.test(toString5(node).toLowerCase())) {
          node.children.push(period2);
          children.pop();
          if (period2.position && node.position) {
            node.position.end = period2.position.end;
          }
          next2 = parent.children[index2 + 1];
          if (next2) {
            child.children = children.concat(next2.children);
            parent.children.splice(index2 + 1, 1);
            if (next2.position && child.position) {
              child.position.end = next2.position.end;
            }
            return index2 - 1;
          }
        }
      }
    }
  }
  return mergePrefixExceptions_1;
}
var mergeAffixExceptions_1;
var hasRequiredMergeAffixExceptions;
function requireMergeAffixExceptions() {
  if (hasRequiredMergeAffixExceptions) return mergeAffixExceptions_1;
  hasRequiredMergeAffixExceptions = 1;
  var toString5 = nlcstToString_1;
  var modifyChildren = requireUnistUtilModifyChildren();
  mergeAffixExceptions_1 = modifyChildren(mergeAffixExceptions);
  function mergeAffixExceptions(child, index2, parent) {
    var children = child.children;
    var node;
    var position2;
    var value;
    var previousChild;
    if (!children || children.length === 0 || index2 === 0) {
      return;
    }
    position2 = -1;
    while (children[++position2]) {
      node = children[position2];
      if (node.type === "WordNode") {
        return;
      }
      if (node.type === "SymbolNode" || node.type === "PunctuationNode") {
        value = toString5(node);
        if (value !== "," && value !== ";") {
          return;
        }
        previousChild = parent.children[index2 - 1];
        previousChild.children = previousChild.children.concat(children);
        if (previousChild.position && child.position) {
          previousChild.position.end = child.position.end;
        }
        parent.children.splice(index2, 1);
        return index2;
      }
    }
  }
  return mergeAffixExceptions_1;
}
var mergeRemainingFullStops_1;
var hasRequiredMergeRemainingFullStops;
function requireMergeRemainingFullStops() {
  if (hasRequiredMergeRemainingFullStops) return mergeRemainingFullStops_1;
  hasRequiredMergeRemainingFullStops = 1;
  var toString5 = nlcstToString_1;
  var visitChildren = requireUnistUtilVisitChildren();
  var expressions2 = expressions$1;
  mergeRemainingFullStops_1 = visitChildren(mergeRemainingFullStops);
  var terminalMarker = expressions2.terminalMarker;
  function mergeRemainingFullStops(child) {
    var children = child.children;
    var position2 = children.length;
    var hasFoundDelimiter = false;
    var grandchild;
    var prev;
    var next2;
    var nextNext;
    while (children[--position2]) {
      grandchild = children[position2];
      if (grandchild.type !== "SymbolNode" && grandchild.type !== "PunctuationNode") {
        if (grandchild.type === "WordNode") {
          hasFoundDelimiter = true;
        }
        continue;
      }
      if (!terminalMarker.test(toString5(grandchild))) {
        continue;
      }
      if (!hasFoundDelimiter) {
        hasFoundDelimiter = true;
        continue;
      }
      if (toString5(grandchild) !== ".") {
        continue;
      }
      prev = children[position2 - 1];
      next2 = children[position2 + 1];
      if (prev && prev.type === "WordNode") {
        nextNext = children[position2 + 2];
        if (next2 && nextNext && next2.type === "WhiteSpaceNode" && toString5(nextNext) === ".") {
          continue;
        }
        children.splice(position2, 1);
        prev.children.push(grandchild);
        if (grandchild.position && prev.position) {
          prev.position.end = grandchild.position.end;
        }
        position2--;
      } else if (next2 && next2.type === "WordNode") {
        children.splice(position2, 1);
        next2.children.unshift(grandchild);
        if (grandchild.position && next2.position) {
          next2.position.start = grandchild.position.start;
        }
      }
    }
  }
  return mergeRemainingFullStops_1;
}
var makeInitialWhiteSpaceSiblings_1;
var hasRequiredMakeInitialWhiteSpaceSiblings;
function requireMakeInitialWhiteSpaceSiblings() {
  if (hasRequiredMakeInitialWhiteSpaceSiblings) return makeInitialWhiteSpaceSiblings_1;
  hasRequiredMakeInitialWhiteSpaceSiblings = 1;
  var visitChildren = requireUnistUtilVisitChildren();
  makeInitialWhiteSpaceSiblings_1 = visitChildren(makeInitialWhiteSpaceSiblings);
  function makeInitialWhiteSpaceSiblings(child, index2, parent) {
    var children = child.children;
    var next2;
    if (children && children.length !== 0 && children[0].type === "WhiteSpaceNode") {
      parent.children.splice(index2, 0, children.shift());
      next2 = children[0];
      if (next2 && next2.position && child.position) {
        child.position.start = next2.position.start;
      }
    }
  }
  return makeInitialWhiteSpaceSiblings_1;
}
var makeFinalWhiteSpaceSiblings_1;
var hasRequiredMakeFinalWhiteSpaceSiblings;
function requireMakeFinalWhiteSpaceSiblings() {
  if (hasRequiredMakeFinalWhiteSpaceSiblings) return makeFinalWhiteSpaceSiblings_1;
  hasRequiredMakeFinalWhiteSpaceSiblings = 1;
  var modifyChildren = requireUnistUtilModifyChildren();
  makeFinalWhiteSpaceSiblings_1 = modifyChildren(makeFinalWhiteSpaceSiblings);
  function makeFinalWhiteSpaceSiblings(child, index2, parent) {
    var children = child.children;
    var prev;
    if (children && children.length !== 0 && children[children.length - 1].type === "WhiteSpaceNode") {
      parent.children.splice(index2 + 1, 0, child.children.pop());
      prev = children[children.length - 1];
      if (prev && prev.position && child.position) {
        child.position.end = prev.position.end;
      }
      return index2;
    }
  }
  return makeFinalWhiteSpaceSiblings_1;
}
var breakImplicitSentences_1;
var hasRequiredBreakImplicitSentences;
function requireBreakImplicitSentences() {
  if (hasRequiredBreakImplicitSentences) return breakImplicitSentences_1;
  hasRequiredBreakImplicitSentences = 1;
  var toString5 = nlcstToString_1;
  var modifyChildren = requireUnistUtilModifyChildren();
  var expressions2 = expressions$1;
  breakImplicitSentences_1 = modifyChildren(breakImplicitSentences);
  var multiNewLine = expressions2.newLineMulti;
  function breakImplicitSentences(child, index2, parent) {
    var children;
    var position2;
    var length;
    var tail;
    var head2;
    var end2;
    var insertion;
    var node;
    if (child.type !== "SentenceNode") {
      return;
    }
    children = child.children;
    length = children.length - 1;
    position2 = 0;
    while (++position2 < length) {
      node = children[position2];
      if (node.type !== "WhiteSpaceNode" || !multiNewLine.test(toString5(node))) {
        continue;
      }
      child.children = children.slice(0, position2);
      insertion = {
        type: "SentenceNode",
        children: children.slice(position2 + 1)
      };
      tail = children[position2 - 1];
      head2 = children[position2 + 1];
      parent.children.splice(index2 + 1, 0, node, insertion);
      if (child.position && tail.position && head2.position) {
        end2 = child.position.end;
        child.position.end = tail.position.end;
        insertion.position = {
          start: head2.position.start,
          end: end2
        };
      }
      return index2 + 1;
    }
  }
  return breakImplicitSentences_1;
}
var removeEmptyNodes_1;
var hasRequiredRemoveEmptyNodes;
function requireRemoveEmptyNodes() {
  if (hasRequiredRemoveEmptyNodes) return removeEmptyNodes_1;
  hasRequiredRemoveEmptyNodes = 1;
  var modifyChildren = requireUnistUtilModifyChildren();
  removeEmptyNodes_1 = modifyChildren(removeEmptyNodes);
  function removeEmptyNodes(child, index2, parent) {
    if ("children" in child && child.children.length === 0) {
      parent.children.splice(index2, 1);
      return index2;
    }
  }
  return removeEmptyNodes_1;
}
var createParser = parser;
var expressions = expressions$1;
var lib = ParseLatin;
function ParseLatin(doc, file) {
  var value = file || doc;
  if (!(this instanceof ParseLatin)) {
    return new ParseLatin(doc, file);
  }
  this.doc = value ? String(value) : null;
}
var proto = ParseLatin.prototype;
proto.position = true;
proto.tokenizeSymbol = createTextFactory("Symbol");
proto.tokenizeWhiteSpace = createTextFactory("WhiteSpace");
proto.tokenizePunctuation = createTextFactory("Punctuation");
proto.tokenizeSource = createTextFactory("Source");
proto.tokenizeText = createTextFactory("Text");
proto.run = run;
proto.use = useFactory(function(context2, key2, plugins) {
  context2[key2] = context2[key2].concat(plugins);
});
proto.useFirst = useFactory(function(context2, key2, plugins) {
  context2[key2] = plugins.concat(context2[key2]);
});
proto.parse = function(value) {
  return this.tokenizeRoot(value || this.doc);
};
proto.tokenize = function(value) {
  return tokenize(this, value);
};
pluggable(ParseLatin, "tokenizeWord", function(value, eat2) {
  var add = (eat2 || noopEat)("");
  var parent = { type: "WordNode", children: [] };
  this.tokenizeText(value, eat2, parent);
  return add(parent);
});
pluggable(
  ParseLatin,
  "tokenizeSentence",
  createParser({
    type: "SentenceNode",
    tokenizer: "tokenize"
  })
);
pluggable(
  ParseLatin,
  "tokenizeParagraph",
  createParser({
    type: "ParagraphNode",
    delimiter: expressions.terminalMarker,
    delimiterType: "PunctuationNode",
    tokenizer: "tokenizeSentence"
  })
);
pluggable(
  ParseLatin,
  "tokenizeRoot",
  createParser({
    type: "RootNode",
    delimiter: expressions.newLine,
    delimiterType: "WhiteSpaceNode",
    tokenizer: "tokenizeParagraph"
  })
);
proto.use("tokenizeSentence", [
  requireMergeInitialWordSymbol(),
  requireMergeFinalWordSymbol(),
  requireMergeInnerWordSymbol(),
  requireMergeInnerWordSlash(),
  requireMergeInitialisms(),
  requireMergeWords(),
  requirePatchPosition()
]);
proto.use("tokenizeParagraph", [
  requireMergeNonWordSentences(),
  requireMergeAffixSymbol(),
  requireMergeInitialLowerCaseLetterSentences(),
  requireMergeInitialDigitSentences(),
  requireMergePrefixExceptions(),
  requireMergeAffixExceptions(),
  requireMergeRemainingFullStops(),
  requireMakeInitialWhiteSpaceSiblings(),
  requireMakeFinalWhiteSpaceSiblings(),
  requireBreakImplicitSentences(),
  requireRemoveEmptyNodes(),
  requirePatchPosition()
]);
proto.use("tokenizeRoot", [
  requireMakeInitialWhiteSpaceSiblings(),
  requireMakeFinalWhiteSpaceSiblings(),
  requireRemoveEmptyNodes(),
  requirePatchPosition()
]);
function createTextFactory(type2) {
  type2 += "Node";
  return createText;
  function createText(value, eat2, parent) {
    if (value === null || value === void 0) {
      value = "";
    }
    return (eat2 || noopEat)(value)(
      {
        type: type2,
        value: String(value)
      },
      parent
    );
  }
}
function run(key2, nodes) {
  var wareKey = key2 + "Plugins";
  var plugins = this[wareKey];
  var index2 = -1;
  if (plugins) {
    while (plugins[++index2]) {
      plugins[index2](nodes);
    }
  }
  return nodes;
}
function pluggable(Constructor, key2, callback) {
  Constructor.prototype[key2] = function() {
    return this.run(key2, callback.apply(this, arguments));
  };
}
function useFactory(callback) {
  return use;
  function use(key2, plugins) {
    var self2 = this;
    var wareKey;
    if (!(key2 in self2)) {
      throw new Error(
        "Illegal Invocation: Unsupported `key` for `use(key, plugins)`. Make sure `key` is a supported function"
      );
    }
    if (!plugins) {
      return;
    }
    wareKey = key2 + "Plugins";
    if (typeof plugins === "function") {
      plugins = [plugins];
    } else {
      plugins = plugins.concat();
    }
    if (!self2[wareKey]) {
      self2[wareKey] = [];
    }
    callback(self2, wareKey, plugins);
  }
}
var wordRe = expressions.word;
var surrogatesRe = expressions.surrogates;
var punctuationRe = expressions.punctuation;
var whiteSpaceRe = expressions.whiteSpace;
function tokenize(parser2, value) {
  var tokens;
  var offset2;
  var line;
  var column;
  var index2;
  var length;
  var character;
  var queue;
  var prev;
  var left;
  var right;
  var eater;
  if (value === null || value === void 0) {
    value = "";
  } else if (value instanceof String) {
    value = value.toString();
  }
  if (typeof value !== "string") {
    if ("length" in value && (!value[0] || value[0].type)) {
      return value;
    }
    throw new Error(
      "Illegal invocation: '" + value + "' is not a valid argument for 'ParseLatin'"
    );
  }
  tokens = [];
  if (!value) {
    return tokens;
  }
  index2 = 0;
  offset2 = 0;
  line = 1;
  column = 1;
  eater = parser2.position ? eat2 : noPositionEat;
  length = value.length;
  prev = "";
  queue = "";
  while (index2 < length) {
    character = value.charAt(index2);
    if (whiteSpaceRe.test(character)) {
      right = "WhiteSpace";
    } else if (punctuationRe.test(character)) {
      right = "Punctuation";
    } else if (wordRe.test(character)) {
      right = "Word";
    } else {
      right = "Symbol";
    }
    tick();
    prev = character;
    character = "";
    left = right;
    right = null;
    index2++;
  }
  tick();
  return tokens;
  function tick() {
    if (left === right && (left === "Word" || left === "WhiteSpace" || character === prev || surrogatesRe.test(character))) {
      queue += character;
    } else {
      if (queue) {
        parser2["tokenize" + left](queue, eater);
      }
      queue = character;
    }
  }
  function eat2(subvalue) {
    var pos = position2();
    update2(subvalue);
    return apply;
    function apply() {
      return pos(add.apply(null, arguments));
    }
  }
  function noPositionEat() {
    return apply;
    function apply() {
      return add.apply(null, arguments);
    }
  }
  function add(node, parent) {
    if (parent) {
      parent.children.push(node);
    } else {
      tokens.push(node);
    }
    return node;
  }
  function position2() {
    var before2 = now();
    function patch(node) {
      node.position = new Position3(before2);
      return node;
    }
    return patch;
  }
  function update2(subvalue) {
    var subvalueLength = subvalue.length;
    var character2 = -1;
    var lastIndex = -1;
    offset2 += subvalueLength;
    while (++character2 < subvalueLength) {
      if (subvalue.charAt(character2) === "\n") {
        lastIndex = character2;
        line++;
      }
    }
    if (lastIndex === -1) {
      column += subvalueLength;
    } else {
      column = subvalueLength - lastIndex;
    }
  }
  function Position3(start2) {
    this.start = start2;
    this.end = now();
  }
  function now() {
    return {
      line,
      column,
      offset: offset2
    };
  }
}
function noopAdd(node, parent) {
  if (parent) {
    parent.children.push(node);
  }
  return node;
}
function noopEat() {
  return noopAdd;
}
var parseLatin = lib;
var unherit = unherit_1;
var Latin = parseLatin;
var retextLatin = parse7;
parse7.Parser = Latin;
function parse7() {
  this.Parser = unherit(Latin);
}
var toString$1 = nlcstToString_1;
var retextStringify = stringify$2;
function stringify$2() {
  this.Compiler = compiler;
}
function compiler(tree) {
  return toString$1(tree);
}
var unified = unified_1;
var latin = retextLatin;
var stringify$1 = retextStringify;
var retext = unified().use(latin).use(stringify$1).freeze();
var retext$1 = getDefaultExportFromCjs(retext);
var visit = unistUtilVisit;
var toString2 = nlcstToString_1;
var retextSmartypants = smartypants;
var punctuation = "PunctuationNode";
var symbol = "SymbolNode";
var word = "WordNode";
var whiteSpace = "WhiteSpaceNode";
var decadeExpression = /^\d\ds$/;
var threeFullStopsExpression = /^\.{3,}$/;
var fullStopsExpression = /^\.+$/;
var threeDashes = "---";
var twoDashes = "--";
var emDash = "";
var enDash = "";
var ellipsis = "";
var twoBackticks = "``";
var backtick = "`";
var twoSingleQuotes = "''";
var singleQuote = "'";
var apostrophe = "";
var doubleQuote = '"';
var openingDoubleQuote = "";
var closingDoubleQuote = "";
var openingSingleQuote = "";
var closingSingleQuote = "";
var closingQuotes = {};
var openingQuotes = {};
openingQuotes[doubleQuote] = openingDoubleQuote;
closingQuotes[doubleQuote] = closingDoubleQuote;
openingQuotes[singleQuote] = openingSingleQuote;
closingQuotes[singleQuote] = closingSingleQuote;
var educators = {};
educators.dashes = {
  true: dashes,
  oldschool,
  inverted
};
educators.backticks = {
  true: backticks,
  all
};
educators.ellipses = {
  true: ellipses
};
educators.quotes = {
  true: quotes
};
function smartypants(options2) {
  var methods = [];
  var quotes2;
  var ellipses2;
  var backticks2;
  var dashes2;
  if (!options2) {
    options2 = {};
  }
  if ("quotes" in options2) {
    quotes2 = options2.quotes;
    if (quotes2 !== Boolean(quotes2)) {
      throw new TypeError(
        "Illegal invocation: `" + quotes2 + "` is not a valid value for `quotes` in `smartypants`"
      );
    }
  } else {
    quotes2 = true;
  }
  if ("ellipses" in options2) {
    ellipses2 = options2.ellipses;
    if (ellipses2 !== Boolean(ellipses2)) {
      throw new TypeError(
        "Illegal invocation: `" + ellipses2 + "` is not a valid value for `ellipses` in `smartypants`"
      );
    }
  } else {
    ellipses2 = true;
  }
  if ("backticks" in options2) {
    backticks2 = options2.backticks;
    if (backticks2 !== Boolean(backticks2) && backticks2 !== "all") {
      throw new TypeError(
        "Illegal invocation: `" + backticks2 + "` is not a valid value for `backticks` in `smartypants`"
      );
    }
    if (backticks2 === "all" && quotes2 === true) {
      throw new TypeError(
        "Illegal invocation: `backticks: " + backticks2 + "` is not a valid value when `quotes: " + quotes2 + "` in `smartypants`"
      );
    }
  } else {
    backticks2 = true;
  }
  if ("dashes" in options2) {
    dashes2 = options2.dashes;
    if (dashes2 !== Boolean(dashes2) && dashes2 !== "oldschool" && dashes2 !== "inverted") {
      throw new TypeError(
        "Illegal invocation: `" + dashes2 + "` is not a valid value for `dahes` in `smartypants`"
      );
    }
  } else {
    dashes2 = true;
  }
  if (quotes2 !== false) {
    methods.push(educators.quotes[quotes2]);
  }
  if (ellipses2 !== false) {
    methods.push(educators.ellipses[ellipses2]);
  }
  if (backticks2 !== false) {
    methods.push(educators.backticks[backticks2]);
  }
  if (dashes2 !== false) {
    methods.push(educators.dashes[dashes2]);
  }
  return transformFactory(methods);
}
function transformFactory(methods) {
  var length = methods.length;
  return transformer;
  function transformer(tree) {
    visit(tree, visitor);
  }
  function visitor(node, position2, parent) {
    var index2 = -1;
    if (node.type === punctuation || node.type === symbol) {
      while (++index2 < length) {
        methods[index2](node, position2, parent);
      }
    }
  }
}
function oldschool(node) {
  if (node.value === threeDashes) {
    node.value = emDash;
  } else if (node.value === twoDashes) {
    node.value = enDash;
  }
}
function dashes(node) {
  if (node.value === twoDashes) {
    node.value = emDash;
  }
}
function inverted(node) {
  if (node.value === threeDashes) {
    node.value = enDash;
  } else if (node.value === twoDashes) {
    node.value = emDash;
  }
}
function backticks(node) {
  if (node.value === twoBackticks) {
    node.value = openingDoubleQuote;
  } else if (node.value === twoSingleQuotes) {
    node.value = closingDoubleQuote;
  }
}
function all(node) {
  backticks(node);
  if (node.value === backtick) {
    node.value = openingSingleQuote;
  } else if (node.value === singleQuote) {
    node.value = closingSingleQuote;
  }
}
function ellipses(node, index2, parent) {
  var value = node.value;
  var siblings2 = parent.children;
  var position2;
  var nodes;
  var sibling2;
  var type2;
  var count;
  var queue;
  if (threeFullStopsExpression.test(node.value)) {
    node.value = ellipsis;
    return;
  }
  if (!fullStopsExpression.test(value)) {
    return;
  }
  nodes = [];
  position2 = index2;
  count = 1;
  while (--position2 > 0) {
    sibling2 = siblings2[position2];
    if (sibling2.type !== whiteSpace) {
      break;
    }
    queue = sibling2;
    sibling2 = siblings2[--position2];
    type2 = sibling2 && sibling2.type;
    if (sibling2 && (type2 === punctuation || type2 === symbol) && fullStopsExpression.test(sibling2.value)) {
      nodes.push(queue, sibling2);
      count++;
      continue;
    }
    break;
  }
  if (count < 3) {
    return;
  }
  siblings2.splice(index2 - nodes.length, nodes.length);
  node.value = ellipsis;
}
function quotes(node, index2, parent) {
  var siblings2 = parent.children;
  var value = node.value;
  var next2;
  var nextNext;
  var prev;
  var nextValue;
  if (value !== doubleQuote && value !== singleQuote) {
    return;
  }
  prev = siblings2[index2 - 1];
  next2 = siblings2[index2 + 1];
  nextNext = siblings2[index2 + 2];
  nextValue = next2 && toString2(next2);
  if (next2 && nextNext && (next2.type === punctuation || next2.type === symbol) && nextNext.type !== word) {
    node.value = closingQuotes[value];
  } else if (nextNext && (nextValue === doubleQuote || nextValue === singleQuote) && nextNext.type === word) {
    node.value = openingQuotes[value];
    next2.value = openingQuotes[nextValue];
  } else if (next2 && decadeExpression.test(nextValue)) {
    node.value = closingQuotes[value];
  } else if (prev && next2 && (prev.type === whiteSpace || prev.type === punctuation || prev.type === symbol) && next2.type === word) {
    node.value = openingQuotes[value];
  } else if (prev && prev.type !== whiteSpace && prev.type !== symbol && prev.type !== punctuation) {
    node.value = closingQuotes[value];
  } else if (!next2 || next2.type === whiteSpace || (value === singleQuote || value === apostrophe) && nextValue === "s") {
    node.value = closingQuotes[value];
  } else {
    node.value = openingQuotes[value];
  }
}
var smartypants$1 = getDefaultExportFromCjs(retextSmartypants);
var jsYaml$1 = {};
var loader$1 = {};
var common$6 = {};
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray(sequence2) {
  if (Array.isArray(sequence2)) return sequence2;
  else if (isNothing(sequence2)) return [];
  return [sequence2];
}
function extend3(target2, source2) {
  var index2, length, key2, sourceKeys;
  if (source2) {
    sourceKeys = Object.keys(source2);
    for (index2 = 0, length = sourceKeys.length; index2 < length; index2 += 1) {
      key2 = sourceKeys[index2];
      target2[key2] = source2[key2];
    }
  }
  return target2;
}
function repeat(string2, count) {
  var result = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1) {
    result += string2;
  }
  return result;
}
function isNegativeZero(number2) {
  return number2 === 0 && Number.NEGATIVE_INFINITY === 1 / number2;
}
common$6.isNothing = isNothing;
common$6.isObject = isObject;
common$6.toArray = toArray;
common$6.repeat = repeat;
common$6.isNegativeZero = isNegativeZero;
common$6.extend = extend3;
function YAMLException$4(reason, mark2) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark2;
  this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : "");
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
YAMLException$4.prototype = Object.create(Error.prototype);
YAMLException$4.prototype.constructor = YAMLException$4;
YAMLException$4.prototype.toString = function toString3(compact) {
  var result = this.name + ": ";
  result += this.reason || "(unknown reason)";
  if (!compact && this.mark) {
    result += " " + this.mark.toString();
  }
  return result;
};
var exception = YAMLException$4;
var common$5 = common$6;
function Mark$1(name2, buffer2, position2, line, column) {
  this.name = name2;
  this.buffer = buffer2;
  this.position = position2;
  this.line = line;
  this.column = column;
}
Mark$1.prototype.getSnippet = function getSnippet(indent2, maxLength) {
  var head2, start2, tail, end2, snippet;
  if (!this.buffer) return null;
  indent2 = indent2 || 4;
  maxLength = maxLength || 75;
  head2 = "";
  start2 = this.position;
  while (start2 > 0 && "\0\r\n\u2028\u2029".indexOf(this.buffer.charAt(start2 - 1)) === -1) {
    start2 -= 1;
    if (this.position - start2 > maxLength / 2 - 1) {
      head2 = " ... ";
      start2 += 5;
      break;
    }
  }
  tail = "";
  end2 = this.position;
  while (end2 < this.buffer.length && "\0\r\n\u2028\u2029".indexOf(this.buffer.charAt(end2)) === -1) {
    end2 += 1;
    if (end2 - this.position > maxLength / 2 - 1) {
      tail = " ... ";
      end2 -= 5;
      break;
    }
  }
  snippet = this.buffer.slice(start2, end2);
  return common$5.repeat(" ", indent2) + head2 + snippet + tail + "\n" + common$5.repeat(" ", indent2 + this.position - start2 + head2.length) + "^";
};
Mark$1.prototype.toString = function toString4(compact) {
  var snippet, where = "";
  if (this.name) {
    where += 'in "' + this.name + '" ';
  }
  where += "at line " + (this.line + 1) + ", column " + (this.column + 1);
  if (!compact) {
    snippet = this.getSnippet();
    if (snippet) {
      where += ":\n" + snippet;
    }
  }
  return where;
};
var mark = Mark$1;
var YAMLException$3 = exception;
var TYPE_CONSTRUCTOR_OPTIONS = [
  "kind",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "defaultStyle",
  "styleAliases"
];
var YAML_NODE_KINDS = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases(map2) {
  var result = {};
  if (map2 !== null) {
    Object.keys(map2).forEach(function(style) {
      map2[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    });
  }
  return result;
}
function Type$h(tag3, options2) {
  options2 = options2 || {};
  Object.keys(options2).forEach(function(name2) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name2) === -1) {
      throw new YAMLException$3('Unknown option "' + name2 + '" is met in definition of "' + tag3 + '" YAML type.');
    }
  });
  this.tag = tag3;
  this.kind = options2["kind"] || null;
  this.resolve = options2["resolve"] || function() {
    return true;
  };
  this.construct = options2["construct"] || function(data3) {
    return data3;
  };
  this.instanceOf = options2["instanceOf"] || null;
  this.predicate = options2["predicate"] || null;
  this.represent = options2["represent"] || null;
  this.defaultStyle = options2["defaultStyle"] || null;
  this.styleAliases = compileStyleAliases(options2["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new YAMLException$3('Unknown kind "' + this.kind + '" is specified for "' + tag3 + '" YAML type.');
  }
}
var type = Type$h;
var common$4 = common$6;
var YAMLException$2 = exception;
var Type$g = type;
function compileList(schema2, name2, result) {
  var exclude = [];
  schema2.include.forEach(function(includedSchema) {
    result = compileList(includedSchema, name2, result);
  });
  schema2[name2].forEach(function(currentType) {
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
        exclude.push(previousIndex);
      }
    });
    result.push(currentType);
  });
  return result.filter(function(type2, index2) {
    return exclude.indexOf(index2) === -1;
  });
}
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {}
  }, index2, length;
  function collectType(type2) {
    result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
  }
  for (index2 = 0, length = arguments.length; index2 < length; index2 += 1) {
    arguments[index2].forEach(collectType);
  }
  return result;
}
function Schema$5(definition) {
  this.include = definition.include || [];
  this.implicit = definition.implicit || [];
  this.explicit = definition.explicit || [];
  this.implicit.forEach(function(type2) {
    if (type2.loadKind && type2.loadKind !== "scalar") {
      throw new YAMLException$2("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }
  });
  this.compiledImplicit = compileList(this, "implicit", []);
  this.compiledExplicit = compileList(this, "explicit", []);
  this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
}
Schema$5.DEFAULT = null;
Schema$5.create = function createSchema() {
  var schemas, types3;
  switch (arguments.length) {
    case 1:
      schemas = Schema$5.DEFAULT;
      types3 = arguments[0];
      break;
    case 2:
      schemas = arguments[0];
      types3 = arguments[1];
      break;
    default:
      throw new YAMLException$2("Wrong number of arguments for Schema.create function");
  }
  schemas = common$4.toArray(schemas);
  types3 = common$4.toArray(types3);
  if (!schemas.every(function(schema2) {
    return schema2 instanceof Schema$5;
  })) {
    throw new YAMLException$2("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
  }
  if (!types3.every(function(type2) {
    return type2 instanceof Type$g;
  })) {
    throw new YAMLException$2("Specified list of YAML types (or a single Type object) contains a non-Type object.");
  }
  return new Schema$5({
    include: schemas,
    explicit: types3
  });
};
var schema = Schema$5;
var Type$f = type;
var str = new Type$f("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data3) {
    return data3 !== null ? data3 : "";
  }
});
var Type$e = type;
var seq = new Type$e("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data3) {
    return data3 !== null ? data3 : [];
  }
});
var Type$d = type;
var map = new Type$d("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data3) {
    return data3 !== null ? data3 : {};
  }
});
var Schema$4 = schema;
var failsafe = new Schema$4({
  explicit: [
    str,
    seq,
    map
  ]
});
var Type$c = type;
function resolveYamlNull(data3) {
  if (data3 === null) return true;
  var max = data3.length;
  return max === 1 && data3 === "~" || max === 4 && (data3 === "null" || data3 === "Null" || data3 === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object4) {
  return object4 === null;
}
var _null = new Type$c("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    }
  },
  defaultStyle: "lowercase"
});
var Type$b = type;
function resolveYamlBoolean(data3) {
  if (data3 === null) return false;
  var max = data3.length;
  return max === 4 && (data3 === "true" || data3 === "True" || data3 === "TRUE") || max === 5 && (data3 === "false" || data3 === "False" || data3 === "FALSE");
}
function constructYamlBoolean(data3) {
  return data3 === "true" || data3 === "True" || data3 === "TRUE";
}
function isBoolean(object4) {
  return Object.prototype.toString.call(object4) === "[object Boolean]";
}
var bool = new Type$b("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function(object4) {
      return object4 ? "true" : "false";
    },
    uppercase: function(object4) {
      return object4 ? "TRUE" : "FALSE";
    },
    camelcase: function(object4) {
      return object4 ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
var common$3 = common$6;
var Type$a = type;
function isHexCode(c) {
  return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
}
function isOctCode(c) {
  return 48 <= c && c <= 55;
}
function isDecCode(c) {
  return 48 <= c && c <= 57;
}
function resolveYamlInteger(data3) {
  if (data3 === null) return false;
  var max = data3.length, index2 = 0, hasDigits = false, ch;
  if (!max) return false;
  ch = data3[index2];
  if (ch === "-" || ch === "+") {
    ch = data3[++index2];
  }
  if (ch === "0") {
    if (index2 + 1 === max) return true;
    ch = data3[++index2];
    if (ch === "b") {
      index2++;
      for (; index2 < max; index2++) {
        ch = data3[index2];
        if (ch === "_") continue;
        if (ch !== "0" && ch !== "1") return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index2++;
      for (; index2 < max; index2++) {
        ch = data3[index2];
        if (ch === "_") continue;
        if (!isHexCode(data3.charCodeAt(index2))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    for (; index2 < max; index2++) {
      ch = data3[index2];
      if (ch === "_") continue;
      if (!isOctCode(data3.charCodeAt(index2))) return false;
      hasDigits = true;
    }
    return hasDigits && ch !== "_";
  }
  if (ch === "_") return false;
  for (; index2 < max; index2++) {
    ch = data3[index2];
    if (ch === "_") continue;
    if (ch === ":") break;
    if (!isDecCode(data3.charCodeAt(index2))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_") return false;
  if (ch !== ":") return true;
  return /^(:[0-5]?[0-9])+$/.test(data3.slice(index2));
}
function constructYamlInteger(data3) {
  var value = data3, sign = 1, ch, base, digits = [];
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-") sign = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0") return 0;
  if (ch === "0") {
    if (value[1] === "b") return sign * parseInt(value.slice(2), 2);
    if (value[1] === "x") return sign * parseInt(value, 16);
    return sign * parseInt(value, 8);
  }
  if (value.indexOf(":") !== -1) {
    value.split(":").forEach(function(v) {
      digits.unshift(parseInt(v, 10));
    });
    value = 0;
    base = 1;
    digits.forEach(function(d) {
      value += d * base;
      base *= 60;
    });
    return sign * value;
  }
  return sign * parseInt(value, 10);
}
function isInteger(object4) {
  return Object.prototype.toString.call(object4) === "[object Number]" && (object4 % 1 === 0 && !common$3.isNegativeZero(object4));
}
var int = new Type$a("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0" + obj.toString(8) : "-0" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
});
var common$2 = common$6;
var Type$9 = type;
var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function resolveYamlFloat(data3) {
  if (data3 === null) return false;
  if (!YAML_FLOAT_PATTERN.test(data3) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data3[data3.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data3) {
  var value, sign, base, digits;
  value = data3.replace(/_/g, "").toLowerCase();
  sign = value[0] === "-" ? -1 : 1;
  digits = [];
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  } else if (value.indexOf(":") >= 0) {
    value.split(":").forEach(function(v) {
      digits.unshift(parseFloat(v, 10));
    });
    value = 0;
    base = 1;
    digits.forEach(function(d) {
      value += d * base;
      base *= 60;
    });
    return sign * value;
  }
  return sign * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object4, style) {
  var res2;
  if (isNaN(object4)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object4) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object4) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common$2.isNegativeZero(object4)) {
    return "-0.0";
  }
  res2 = object4.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res2) ? res2.replace("e", ".e") : res2;
}
function isFloat(object4) {
  return Object.prototype.toString.call(object4) === "[object Number]" && (object4 % 1 !== 0 || common$2.isNegativeZero(object4));
}
var float = new Type$9("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
});
var Schema$3 = schema;
var json = new Schema$3({
  include: [
    failsafe
  ],
  implicit: [
    _null,
    bool,
    int,
    float
  ]
});
var Schema$2 = schema;
var core = new Schema$2({
  include: [
    json
  ]
});
var Type$8 = type;
var YAML_DATE_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
);
var YAML_TIMESTAMP_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function resolveYamlTimestamp(data3) {
  if (data3 === null) return false;
  if (YAML_DATE_REGEXP.exec(data3) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data3) !== null) return true;
  return false;
}
function constructYamlTimestamp(data3) {
  var match, year, month, day, hour, minute, second, fraction = 0, delta2 = null, tz_hour, tz_minute, date;
  match = YAML_DATE_REGEXP.exec(data3);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data3);
  if (match === null) throw new Error("Date resolve error");
  year = +match[1];
  month = +match[2] - 1;
  day = +match[3];
  if (!match[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match[4];
  minute = +match[5];
  second = +match[6];
  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta2 = (tz_hour * 60 + tz_minute) * 6e4;
    if (match[9] === "-") delta2 = -delta2;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta2) date.setTime(date.getTime() - delta2);
  return date;
}
function representYamlTimestamp(object4) {
  return object4.toISOString();
}
var timestamp = new Type$8("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
var Type$7 = type;
function resolveYamlMerge(data3) {
  return data3 === "<<" || data3 === null;
}
var merge = new Type$7("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});
function commonjsRequire(path2) {
  throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var NodeBuffer;
try {
  _require$1 = commonjsRequire;
  NodeBuffer = _require$1("buffer").Buffer;
} catch (__) {
}
var _require$1;
var Type$6 = type;
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data3) {
  if (data3 === null) return false;
  var code2, idx, bitlen = 0, max = data3.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    code2 = map2.indexOf(data3.charAt(idx));
    if (code2 > 64) continue;
    if (code2 < 0) return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data3) {
  var idx, tailbits, input = data3.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map2.indexOf(input.charAt(idx));
  }
  tailbits = max % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  if (NodeBuffer) {
    return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
  }
  return result;
}
function representYamlBinary(object4) {
  var result = "", bits = 0, idx, tail, max = object4.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map2[bits >> 18 & 63];
      result += map2[bits >> 12 & 63];
      result += map2[bits >> 6 & 63];
      result += map2[bits & 63];
    }
    bits = (bits << 8) + object4[idx];
  }
  tail = max % 3;
  if (tail === 0) {
    result += map2[bits >> 18 & 63];
    result += map2[bits >> 12 & 63];
    result += map2[bits >> 6 & 63];
    result += map2[bits & 63];
  } else if (tail === 2) {
    result += map2[bits >> 10 & 63];
    result += map2[bits >> 4 & 63];
    result += map2[bits << 2 & 63];
    result += map2[64];
  } else if (tail === 1) {
    result += map2[bits >> 2 & 63];
    result += map2[bits << 4 & 63];
    result += map2[64];
    result += map2[64];
  }
  return result;
}
function isBinary(object4) {
  return NodeBuffer && NodeBuffer.isBuffer(object4);
}
var binary2 = new Type$6("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
var Type$5 = type;
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data3) {
  if (data3 === null) return true;
  var objectKeys = [], index2, length, pair, pairKey, pairHasKey, object4 = data3;
  for (index2 = 0, length = object4.length; index2 < length; index2 += 1) {
    pair = object4[index2];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]") return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }
    if (!pairHasKey) return false;
    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }
  return true;
}
function constructYamlOmap(data3) {
  return data3 !== null ? data3 : [];
}
var omap = new Type$5("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
var Type$4 = type;
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data3) {
  if (data3 === null) return true;
  var index2, length, pair, keys2, result, object4 = data3;
  result = new Array(object4.length);
  for (index2 = 0, length = object4.length; index2 < length; index2 += 1) {
    pair = object4[index2];
    if (_toString$1.call(pair) !== "[object Object]") return false;
    keys2 = Object.keys(pair);
    if (keys2.length !== 1) return false;
    result[index2] = [keys2[0], pair[keys2[0]]];
  }
  return true;
}
function constructYamlPairs(data3) {
  if (data3 === null) return [];
  var index2, length, pair, keys2, result, object4 = data3;
  result = new Array(object4.length);
  for (index2 = 0, length = object4.length; index2 < length; index2 += 1) {
    pair = object4[index2];
    keys2 = Object.keys(pair);
    result[index2] = [keys2[0], pair[keys2[0]]];
  }
  return result;
}
var pairs = new Type$4("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
var Type$3 = type;
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data3) {
  if (data3 === null) return true;
  var key2, object4 = data3;
  for (key2 in object4) {
    if (_hasOwnProperty$2.call(object4, key2)) {
      if (object4[key2] !== null) return false;
    }
  }
  return true;
}
function constructYamlSet(data3) {
  return data3 !== null ? data3 : {};
}
var set2 = new Type$3("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
});
var Schema$1 = schema;
var default_safe = new Schema$1({
  include: [
    core
  ],
  implicit: [
    timestamp,
    merge
  ],
  explicit: [
    binary2,
    omap,
    pairs,
    set2
  ]
});
var Type$2 = type;
function resolveJavascriptUndefined() {
  return true;
}
function constructJavascriptUndefined() {
  return void 0;
}
function representJavascriptUndefined() {
  return "";
}
function isUndefined(object4) {
  return typeof object4 === "undefined";
}
var _undefined = new Type$2("tag:yaml.org,2002:js/undefined", {
  kind: "scalar",
  resolve: resolveJavascriptUndefined,
  construct: constructJavascriptUndefined,
  predicate: isUndefined,
  represent: representJavascriptUndefined
});
var Type$1 = type;
function resolveJavascriptRegExp(data3) {
  if (data3 === null) return false;
  if (data3.length === 0) return false;
  var regexp2 = data3, tail = /\/([gim]*)$/.exec(data3), modifiers = "";
  if (regexp2[0] === "/") {
    if (tail) modifiers = tail[1];
    if (modifiers.length > 3) return false;
    if (regexp2[regexp2.length - modifiers.length - 1] !== "/") return false;
  }
  return true;
}
function constructJavascriptRegExp(data3) {
  var regexp2 = data3, tail = /\/([gim]*)$/.exec(data3), modifiers = "";
  if (regexp2[0] === "/") {
    if (tail) modifiers = tail[1];
    regexp2 = regexp2.slice(1, regexp2.length - modifiers.length - 1);
  }
  return new RegExp(regexp2, modifiers);
}
function representJavascriptRegExp(object4) {
  var result = "/" + object4.source + "/";
  if (object4.global) result += "g";
  if (object4.multiline) result += "m";
  if (object4.ignoreCase) result += "i";
  return result;
}
function isRegExp(object4) {
  return Object.prototype.toString.call(object4) === "[object RegExp]";
}
var regexp = new Type$1("tag:yaml.org,2002:js/regexp", {
  kind: "scalar",
  resolve: resolveJavascriptRegExp,
  construct: constructJavascriptRegExp,
  predicate: isRegExp,
  represent: representJavascriptRegExp
});
var esprima;
try {
  _require = commonjsRequire;
  esprima = _require("esprima");
} catch (_) {
  if (typeof window !== "undefined") esprima = window.esprima;
}
var _require;
var Type = type;
function resolveJavascriptFunction(data3) {
  if (data3 === null) return false;
  try {
    var source2 = "(" + data3 + ")", ast2 = esprima.parse(source2, { range: true });
    if (ast2.type !== "Program" || ast2.body.length !== 1 || ast2.body[0].type !== "ExpressionStatement" || ast2.body[0].expression.type !== "ArrowFunctionExpression" && ast2.body[0].expression.type !== "FunctionExpression") {
      return false;
    }
    return true;
  } catch (err) {
    return false;
  }
}
function constructJavascriptFunction(data3) {
  var source2 = "(" + data3 + ")", ast2 = esprima.parse(source2, { range: true }), params = [], body2;
  if (ast2.type !== "Program" || ast2.body.length !== 1 || ast2.body[0].type !== "ExpressionStatement" || ast2.body[0].expression.type !== "ArrowFunctionExpression" && ast2.body[0].expression.type !== "FunctionExpression") {
    throw new Error("Failed to resolve function");
  }
  ast2.body[0].expression.params.forEach(function(param) {
    params.push(param.name);
  });
  body2 = ast2.body[0].expression.body.range;
  if (ast2.body[0].expression.body.type === "BlockStatement") {
    return new Function(params, source2.slice(body2[0] + 1, body2[1] - 1));
  }
  return new Function(params, "return " + source2.slice(body2[0], body2[1]));
}
function representJavascriptFunction(object4) {
  return object4.toString();
}
function isFunction(object4) {
  return Object.prototype.toString.call(object4) === "[object Function]";
}
var _function = new Type("tag:yaml.org,2002:js/function", {
  kind: "scalar",
  resolve: resolveJavascriptFunction,
  construct: constructJavascriptFunction,
  predicate: isFunction,
  represent: representJavascriptFunction
});
var Schema = schema;
var default_full = Schema.DEFAULT = new Schema({
  include: [
    default_safe
  ],
  explicit: [
    _undefined,
    regexp,
    _function
  ]
});
var common$1 = common$6;
var YAMLException$1 = exception;
var Mark = mark;
var DEFAULT_SAFE_SCHEMA$1 = default_safe;
var DEFAULT_FULL_SCHEMA$1 = default_full;
var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c) {
  return c === 10 || c === 13;
}
function is_WHITE_SPACE(c) {
  return c === 9 || c === 32;
}
function is_WS_OR_EOL(c) {
  return c === 9 || c === 32 || c === 10 || c === 13;
}
function is_FLOW_INDICATOR(c) {
  return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
}
function fromHexCode(c) {
  var lc;
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  lc = c | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c) {
  if (c === 120) {
    return 2;
  }
  if (c === 117) {
    return 4;
  }
  if (c === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c) {
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  return -1;
}
function simpleEscapeSequence(c) {
  return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "" : c === 95 ? "" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
}
function charFromCodepoint(c) {
  if (c <= 65535) {
    return String.fromCharCode(c);
  }
  return String.fromCharCode(
    (c - 65536 >> 10) + 55296,
    (c - 65536 & 1023) + 56320
  );
}
var simpleEscapeCheck = new Array(256);
var simpleEscapeMap = new Array(256);
for (i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}
var i;
function State$1(input, options2) {
  this.input = input;
  this.filename = options2["filename"] || null;
  this.schema = options2["schema"] || DEFAULT_FULL_SCHEMA$1;
  this.onWarning = options2["onWarning"] || null;
  this.legacy = options2["legacy"] || false;
  this.json = options2["json"] || false;
  this.listener = options2["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.documents = [];
}
function generateError(state, message2) {
  return new YAMLException$1(
    message2,
    new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart)
  );
}
function throwError(state, message2) {
  throw generateError(state, message2);
}
function throwWarning(state, message2) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message2));
  }
}
var directiveHandlers = {
  YAML: function handleYamlDirective(state, name2, args) {
    var match, major, minor;
    if (state.version !== null) {
      throwError(state, "duplication of %YAML directive");
    }
    if (args.length !== 1) {
      throwError(state, "YAML directive accepts exactly one argument");
    }
    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
    if (match === null) {
      throwError(state, "ill-formed argument of the YAML directive");
    }
    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);
    if (major !== 1) {
      throwError(state, "unacceptable YAML version of the document");
    }
    state.version = args[0];
    state.checkLineBreaks = minor < 2;
    if (minor !== 1 && minor !== 2) {
      throwWarning(state, "unsupported YAML version of the document");
    }
  },
  TAG: function handleTagDirective(state, name2, args) {
    var handle, prefix;
    if (args.length !== 2) {
      throwError(state, "TAG directive accepts exactly two arguments");
    }
    handle = args[0];
    prefix = args[1];
    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
    }
    if (_hasOwnProperty$1.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }
    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
    }
    state.tagMap[handle] = prefix;
  }
};
function captureSegment(state, start2, end2, checkJson) {
  var _position, _length, _character, _result;
  if (start2 < end2) {
    _result = state.input.slice(start2, end2);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, "the stream contains non-printable characters");
    }
    state.result += _result;
  }
}
function mergeMappings(state, destination, source2, overridableKeys) {
  var sourceKeys, key2, index2, quantity;
  if (!common$1.isObject(source2)) {
    throwError(state, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source2);
  for (index2 = 0, quantity = sourceKeys.length; index2 < quantity; index2 += 1) {
    key2 = sourceKeys[index2];
    if (!_hasOwnProperty$1.call(destination, key2)) {
      destination[key2] = source2[key2];
      overridableKeys[key2] = true;
    }
  }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
  var index2, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index2 = 0, quantity = keyNode.length; index2 < quantity; index2 += 1) {
      if (Array.isArray(keyNode[index2])) {
        throwError(state, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index2]) === "[object Object]") {
        keyNode[index2] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index2 = 0, quantity = valueNode.length; index2 < quantity; index2 += 1) {
        mergeMappings(state, _result, valueNode[index2], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.position = startPos || state.position;
      throwError(state, "duplicated mapping key");
    }
    _result[keyNode] = valueNode;
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 10) {
    state.position++;
  } else if (ch === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10) {
      state.position++;
    }
  } else {
    throwError(state, "a line break is expected");
  }
  state.line += 1;
  state.lineStart = state.position;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state) {
  var _position = state.position, ch;
  ch = state.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += " ";
  } else if (count > 1) {
    state.result += common$1.repeat("\n", count - 1);
  }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
  ch = state.input.charCodeAt(state.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state.kind = "scalar";
  state.result = "";
  captureStart = captureEnd = state.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state.input.charCodeAt(state.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }
    ch = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = _kind;
  state.result = _result;
  return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 39) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (ch === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a single quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 34) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state, "expected hexadecimal character");
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        throwError(state, "unknown escape sequence");
      }
      captureStart = captureEnd = state.position;
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a double quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
  var readNext = true, _line, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = {}, keyNode, keyTag, valueNode, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(++state.position);
  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, "missed comma between flow collection entries");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === _line) && ch === 58) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === 44) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common$1.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common$1.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common$1.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += " ";
        }
      } else {
        state.result += common$1.repeat("\n", emptyLines);
      }
    } else {
      state.result += common$1.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (ch !== 45) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a sequence entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "sequence";
    state.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _pos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = {}, keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line;
    _pos = state.position;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state.position += 1;
      ch = following;
    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 58) {
          ch = state.input.charCodeAt(++state.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          throwError(state, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true;
      }
    } else {
      break;
    }
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }
    if (state.lineIndent > nodeIndent && ch !== 0) {
      throwError(state, "bad indentation of a mapping entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "mapping";
    state.result = _result;
  }
  return detected;
}
function readTagProperty(state) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 33) return false;
  if (state.tag !== null) {
    throwError(state, "duplication of a tag property");
  }
  ch = state.input.charCodeAt(++state.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = "!";
  }
  _position = state.position;
  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(_position, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, "tag name cannot contain such characters: " + tagName);
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state) {
  var _position, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 38) return false;
  if (state.anchor !== null) {
    throwError(state, "duplication of an anchor property");
  }
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an anchor node must contain at least one character");
  }
  state.anchor = state.input.slice(_position, state.position);
  return true;
}
function readAlias(state) {
  var _position, alias, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 42) return false;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an alias node must contain at least one character");
  }
  alias = state.input.slice(_position, state.position);
  if (!state.anchorMap.hasOwnProperty(alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }
  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, type2, flowIndent, blockIndent;
  if (state.listener !== null) {
    state.listener("open", state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            throwError(state, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = "?";
          }
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag !== null && state.tag !== "!") {
    if (state.tag === "?") {
      if (state.result !== null && state.kind !== "scalar") {
        throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
      }
      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
        type2 = state.implicitTypes[typeIndex];
        if (type2.resolve(state.result)) {
          state.result = type2.construct(state.result);
          state.tag = type2.tag;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
      type2 = state.typeMap[state.kind || "fallback"][state.tag];
      if (state.result !== null && type2.kind !== state.kind) {
        throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
      }
      if (!type2.resolve(state.result)) {
        throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
      } else {
        state.result = type2.construct(state.result);
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else {
      throwError(state, "unknown tag !<" + state.tag + ">");
    }
  }
  if (state.listener !== null) {
    state.listener("close", state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = {};
  state.anchorMap = {};
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch)) break;
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    if (ch !== 0) readLineBreak(state);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    throwError(state, "directives end mark is expected");
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, "non-ASCII line breaks are interpreted as content");
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    throwError(state, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options2) {
  input = String(input);
  options2 = options2 || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state = new State$1(input, options2);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, "null byte is not allowed in input");
  }
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
function loadAll(input, iterator, options2) {
  if (iterator !== null && typeof iterator === "object" && typeof options2 === "undefined") {
    options2 = iterator;
    iterator = null;
  }
  var documents = loadDocuments(input, options2);
  if (typeof iterator !== "function") {
    return documents;
  }
  for (var index2 = 0, length = documents.length; index2 < length; index2 += 1) {
    iterator(documents[index2]);
  }
}
function load(input, options2) {
  var documents = loadDocuments(input, options2);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new YAMLException$1("expected a single document in the stream, but found more");
}
function safeLoadAll(input, iterator, options2) {
  if (typeof iterator === "object" && iterator !== null && typeof options2 === "undefined") {
    options2 = iterator;
    iterator = null;
  }
  return loadAll(input, iterator, common$1.extend({ schema: DEFAULT_SAFE_SCHEMA$1 }, options2));
}
function safeLoad(input, options2) {
  return load(input, common$1.extend({ schema: DEFAULT_SAFE_SCHEMA$1 }, options2));
}
loader$1.loadAll = loadAll;
loader$1.load = load;
loader$1.safeLoadAll = safeLoadAll;
loader$1.safeLoad = safeLoad;
var dumper$1 = {};
var common = common$6;
var YAMLException = exception;
var DEFAULT_FULL_SCHEMA = default_full;
var DEFAULT_SAFE_SCHEMA = default_safe;
var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_TAB = 9;
var CHAR_LINE_FEED = 10;
var CHAR_CARRIAGE_RETURN = 13;
var CHAR_SPACE = 32;
var CHAR_EXCLAMATION = 33;
var CHAR_DOUBLE_QUOTE = 34;
var CHAR_SHARP = 35;
var CHAR_PERCENT = 37;
var CHAR_AMPERSAND = 38;
var CHAR_SINGLE_QUOTE = 39;
var CHAR_ASTERISK = 42;
var CHAR_COMMA = 44;
var CHAR_MINUS = 45;
var CHAR_COLON = 58;
var CHAR_EQUALS = 61;
var CHAR_GREATER_THAN = 62;
var CHAR_QUESTION = 63;
var CHAR_COMMERCIAL_AT = 64;
var CHAR_LEFT_SQUARE_BRACKET = 91;
var CHAR_RIGHT_SQUARE_BRACKET = 93;
var CHAR_GRAVE_ACCENT = 96;
var CHAR_LEFT_CURLY_BRACKET = 123;
var CHAR_VERTICAL_LINE = 124;
var CHAR_RIGHT_CURLY_BRACKET = 125;
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0] = "\\0";
ESCAPE_SEQUENCES[7] = "\\a";
ESCAPE_SEQUENCES[8] = "\\b";
ESCAPE_SEQUENCES[9] = "\\t";
ESCAPE_SEQUENCES[10] = "\\n";
ESCAPE_SEQUENCES[11] = "\\v";
ESCAPE_SEQUENCES[12] = "\\f";
ESCAPE_SEQUENCES[13] = "\\r";
ESCAPE_SEQUENCES[27] = "\\e";
ESCAPE_SEQUENCES[34] = '\\"';
ESCAPE_SEQUENCES[92] = "\\\\";
ESCAPE_SEQUENCES[133] = "\\N";
ESCAPE_SEQUENCES[160] = "\\_";
ESCAPE_SEQUENCES[8232] = "\\L";
ESCAPE_SEQUENCES[8233] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
function compileStyleMap(schema2, map2) {
  var result, keys2, index2, length, tag3, style, type2;
  if (map2 === null) return {};
  result = {};
  keys2 = Object.keys(map2);
  for (index2 = 0, length = keys2.length; index2 < length; index2 += 1) {
    tag3 = keys2[index2];
    style = String(map2[tag3]);
    if (tag3.slice(0, 2) === "!!") {
      tag3 = "tag:yaml.org,2002:" + tag3.slice(2);
    }
    type2 = schema2.compiledTypeMap["fallback"][tag3];
    if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
      style = type2.styleAliases[style];
    }
    result[tag3] = style;
  }
  return result;
}
function encodeHex(character) {
  var string2, handle, length;
  string2 = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle = "x";
    length = 2;
  } else if (character <= 65535) {
    handle = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle = "U";
    length = 8;
  } else {
    throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle + common.repeat("0", length - string2.length) + string2;
}
function State(options2) {
  this.schema = options2["schema"] || DEFAULT_FULL_SCHEMA;
  this.indent = Math.max(1, options2["indent"] || 2);
  this.noArrayIndent = options2["noArrayIndent"] || false;
  this.skipInvalid = options2["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options2["flowLevel"]) ? -1 : options2["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options2["styles"] || null);
  this.sortKeys = options2["sortKeys"] || false;
  this.lineWidth = options2["lineWidth"] || 80;
  this.noRefs = options2["noRefs"] || false;
  this.noCompatMode = options2["noCompatMode"] || false;
  this.condenseFlow = options2["condenseFlow"] || false;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString(string2, spaces) {
  var ind = common.repeat(" ", spaces), position2 = 0, next2 = -1, result = "", line, length = string2.length;
  while (position2 < length) {
    next2 = string2.indexOf("\n", position2);
    if (next2 === -1) {
      line = string2.slice(position2);
      position2 = length;
    } else {
      line = string2.slice(position2, next2 + 1);
      position2 = next2 + 1;
    }
    if (line.length && line !== "\n") result += ind;
    result += line;
  }
  return result;
}
function generateNextLine(state, level) {
  return "\n" + common.repeat(" ", state.indent * level);
}
function testImplicitResolving(state, str2) {
  var index2, length, type2;
  for (index2 = 0, length = state.implicitTypes.length; index2 < length; index2 += 1) {
    type2 = state.implicitTypes[index2];
    if (type2.resolve(str2)) {
      return true;
    }
  }
  return false;
}
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}
function isPrintable(c) {
  return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== 65279 || 65536 <= c && c <= 1114111;
}
function isNsChar(c) {
  return isPrintable(c) && !isWhitespace(c) && c !== 65279 && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
}
function isPlainSafe(c, prev) {
  return isPrintable(c) && c !== 65279 && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_COLON && (c !== CHAR_SHARP || prev && isNsChar(prev));
}
function isPlainSafeFirst(c) {
  return isPrintable(c) && c !== 65279 && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
}
function needIndentIndicator(string2) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string2);
}
var STYLE_PLAIN = 1;
var STYLE_SINGLE = 2;
var STYLE_LITERAL = 3;
var STYLE_FOLDED = 4;
var STYLE_DOUBLE = 5;
function chooseScalarStyle(string2, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
  var i;
  var char, prev_char;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain2 = isPlainSafeFirst(string2.charCodeAt(0)) && !isWhitespace(string2.charCodeAt(string2.length - 1));
  if (singleLineOnly) {
    for (i = 0; i < string2.length; i++) {
      char = string2.charCodeAt(i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      prev_char = i > 0 ? string2.charCodeAt(i - 1) : null;
      plain2 = plain2 && isPlainSafe(char, prev_char);
    }
  } else {
    for (i = 0; i < string2.length; i++) {
      char = string2.charCodeAt(i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i - previousLineBreak - 1 > lineWidth && string2[previousLineBreak + 1] !== " ";
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      prev_char = i > 0 ? string2.charCodeAt(i - 1) : null;
      plain2 = plain2 && isPlainSafe(char, prev_char);
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string2[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    return plain2 && !testAmbiguousType(string2) ? STYLE_PLAIN : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string2)) {
    return STYLE_DOUBLE;
  }
  return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
}
function writeScalar(state, string2, level, iskey) {
  state.dump = (function() {
    if (string2.length === 0) {
      return "''";
    }
    if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string2) !== -1) {
      return "'" + string2 + "'";
    }
    var indent2 = state.indent * Math.max(1, level);
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent2);
    var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string3) {
      return testImplicitResolving(state, string3);
    }
    switch (chooseScalarStyle(string2, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
      case STYLE_PLAIN:
        return string2;
      case STYLE_SINGLE:
        return "'" + string2.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string2, state.indent) + dropEndingNewline(indentString(string2, indent2));
      case STYLE_FOLDED:
        return ">" + blockHeader(string2, state.indent) + dropEndingNewline(indentString(foldString(string2, lineWidth), indent2));
      case STYLE_DOUBLE:
        return '"' + escapeString(string2) + '"';
      default:
        throw new YAMLException("impossible error: invalid scalar style");
    }
  })();
}
function blockHeader(string2, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string2) ? String(indentPerLevel) : "";
  var clip = string2[string2.length - 1] === "\n";
  var keep = clip && (string2[string2.length - 2] === "\n" || string2 === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function dropEndingNewline(string2) {
  return string2[string2.length - 1] === "\n" ? string2.slice(0, -1) : string2;
}
function foldString(string2, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = (function() {
    var nextLF = string2.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string2.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string2.slice(0, nextLF), width);
  })();
  var prevMoreIndented = string2[0] === "\n" || string2[0] === " ";
  var moreIndented;
  var match;
  while (match = lineRe.exec(string2)) {
    var prefix = match[1], line = match[2];
    moreIndented = line[0] === " ";
    result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }
  return result;
}
function foldLine(line, width) {
  if (line === "" || line[0] === " ") return line;
  var breakRe = / [^ ]/g;
  var match;
  var start2 = 0, end2, curr = 0, next2 = 0;
  var result = "";
  while (match = breakRe.exec(line)) {
    next2 = match.index;
    if (next2 - start2 > width) {
      end2 = curr > start2 ? curr : next2;
      result += "\n" + line.slice(start2, end2);
      start2 = end2 + 1;
    }
    curr = next2;
  }
  result += "\n";
  if (line.length - start2 > width && curr > start2) {
    result += line.slice(start2, curr) + "\n" + line.slice(curr + 1);
  } else {
    result += line.slice(start2);
  }
  return result.slice(1);
}
function escapeString(string2) {
  var result = "";
  var char, nextChar;
  var escapeSeq;
  for (var i = 0; i < string2.length; i++) {
    char = string2.charCodeAt(i);
    if (char >= 55296 && char <= 56319) {
      nextChar = string2.charCodeAt(i + 1);
      if (nextChar >= 56320 && nextChar <= 57343) {
        result += encodeHex((char - 55296) * 1024 + nextChar - 56320 + 65536);
        i++;
        continue;
      }
    }
    escapeSeq = ESCAPE_SEQUENCES[char];
    result += !escapeSeq && isPrintable(char) ? string2[i] : escapeSeq || encodeHex(char);
  }
  return result;
}
function writeFlowSequence(state, level, object4) {
  var _result = "", _tag = state.tag, index2, length;
  for (index2 = 0, length = object4.length; index2 < length; index2 += 1) {
    if (writeNode(state, level, object4[index2], false, false)) {
      if (index2 !== 0) _result += "," + (!state.condenseFlow ? " " : "");
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = "[" + _result + "]";
}
function writeBlockSequence(state, level, object4, compact) {
  var _result = "", _tag = state.tag, index2, length;
  for (index2 = 0, length = object4.length; index2 < length; index2 += 1) {
    if (writeNode(state, level + 1, object4[index2], true, true)) {
      if (!compact || index2 !== 0) {
        _result += generateNextLine(state, level);
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = _result || "[]";
}
function writeFlowMapping(state, level, object4) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object4), index2, length, objectKey, objectValue, pairBuffer;
  for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
    pairBuffer = "";
    if (index2 !== 0) pairBuffer += ", ";
    if (state.condenseFlow) pairBuffer += '"';
    objectKey = objectKeyList[index2];
    objectValue = object4[objectKey];
    if (!writeNode(state, level, objectKey, false, false)) {
      continue;
    }
    if (state.dump.length > 1024) pairBuffer += "? ";
    pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
    if (!writeNode(state, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = "{" + _result + "}";
}
function writeBlockMapping(state, level, object4, compact) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object4), index2, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state.sortKeys === "function") {
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    throw new YAMLException("sortKeys must be a boolean or a function");
  }
  for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
    pairBuffer = "";
    if (!compact || index2 !== 0) {
      pairBuffer += generateNextLine(state, level);
    }
    objectKey = objectKeyList[index2];
    objectValue = object4[objectKey];
    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }
    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = _result || "{}";
}
function detectType(state, object4, explicit) {
  var _result, typeList, index2, length, type2, style;
  typeList = explicit ? state.explicitTypes : state.implicitTypes;
  for (index2 = 0, length = typeList.length; index2 < length; index2 += 1) {
    type2 = typeList[index2];
    if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object4 === "object" && object4 instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object4))) {
      state.tag = explicit ? type2.tag : "?";
      if (type2.represent) {
        style = state.styleMap[type2.tag] || type2.defaultStyle;
        if (_toString.call(type2.represent) === "[object Function]") {
          _result = type2.represent(object4, style);
        } else if (_hasOwnProperty.call(type2.represent, style)) {
          _result = type2.represent[style](object4, style);
        } else {
          throw new YAMLException("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state, level, object4, block3, compact, iskey) {
  state.tag = null;
  state.dump = object4;
  if (!detectType(state, object4, false)) {
    detectType(state, object4, true);
  }
  var type2 = _toString.call(state.dump);
  if (block3) {
    block3 = state.flowLevel < 0 || state.flowLevel > level;
  }
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object4);
    duplicate = duplicateIndex !== -1;
  }
  if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }
  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type2 === "[object Object]") {
      if (block3 && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object Array]") {
      var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;
      if (block3 && state.dump.length !== 0) {
        writeBlockSequence(state, arrayLevel, state.dump, compact);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, arrayLevel, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object String]") {
      if (state.tag !== "?") {
        writeScalar(state, state.dump, level, iskey);
      }
    } else {
      if (state.skipInvalid) return false;
      throw new YAMLException("unacceptable kind of an object to dump " + type2);
    }
    if (state.tag !== null && state.tag !== "?") {
      state.dump = "!<" + state.tag + "> " + state.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object4, state) {
  var objects = [], duplicatesIndexes = [], index2, length;
  inspectNode(object4, objects, duplicatesIndexes);
  for (index2 = 0, length = duplicatesIndexes.length; index2 < length; index2 += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index2]]);
  }
  state.usedDuplicates = new Array(length);
}
function inspectNode(object4, objects, duplicatesIndexes) {
  var objectKeyList, index2, length;
  if (object4 !== null && typeof object4 === "object") {
    index2 = objects.indexOf(object4);
    if (index2 !== -1) {
      if (duplicatesIndexes.indexOf(index2) === -1) {
        duplicatesIndexes.push(index2);
      }
    } else {
      objects.push(object4);
      if (Array.isArray(object4)) {
        for (index2 = 0, length = object4.length; index2 < length; index2 += 1) {
          inspectNode(object4[index2], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object4);
        for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
          inspectNode(object4[objectKeyList[index2]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump(input, options2) {
  options2 = options2 || {};
  var state = new State(options2);
  if (!state.noRefs) getDuplicateReferences(input, state);
  if (writeNode(state, 0, input, true, true)) return state.dump + "\n";
  return "";
}
function safeDump(input, options2) {
  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options2));
}
dumper$1.dump = dump;
dumper$1.safeDump = safeDump;
var loader = loader$1;
var dumper = dumper$1;
function deprecated(name2) {
  return function() {
    throw new Error("Function " + name2 + " is deprecated and cannot be used.");
  };
}
jsYaml$1.Type = type;
jsYaml$1.Schema = schema;
jsYaml$1.FAILSAFE_SCHEMA = failsafe;
jsYaml$1.JSON_SCHEMA = json;
jsYaml$1.CORE_SCHEMA = core;
jsYaml$1.DEFAULT_SAFE_SCHEMA = default_safe;
jsYaml$1.DEFAULT_FULL_SCHEMA = default_full;
jsYaml$1.load = loader.load;
jsYaml$1.loadAll = loader.loadAll;
jsYaml$1.safeLoad = loader.safeLoad;
jsYaml$1.safeLoadAll = loader.safeLoadAll;
jsYaml$1.dump = dumper.dump;
jsYaml$1.safeDump = dumper.safeDump;
jsYaml$1.YAMLException = exception;
jsYaml$1.MINIMAL_SCHEMA = failsafe;
jsYaml$1.SAFE_SCHEMA = default_safe;
jsYaml$1.DEFAULT_SCHEMA = default_full;
jsYaml$1.scan = deprecated("scan");
jsYaml$1.parse = deprecated("parse");
jsYaml$1.compose = deprecated("compose");
jsYaml$1.addConstructor = deprecated("addConstructor");
var yaml = jsYaml$1;
var jsYaml = yaml;
var yaml$1 = getDefaultExportFromCjs(jsYaml);
var matchHtmlRegExp = /["'&<>]/;
var escapeHtml_1 = escapeHtml;
function escapeHtml(string2) {
  var str2 = "" + string2;
  var match = matchHtmlRegExp.exec(str2);
  if (!match) {
    return str2;
  }
  var escape2;
  var html2 = "";
  var index2 = 0;
  var lastIndex = 0;
  for (index2 = match.index; index2 < str2.length; index2++) {
    switch (str2.charCodeAt(index2)) {
      case 34:
        escape2 = "&quot;";
        break;
      case 38:
        escape2 = "&amp;";
        break;
      case 39:
        escape2 = "&#39;";
        break;
      case 60:
        escape2 = "&lt;";
        break;
      case 62:
        escape2 = "&gt;";
        break;
      default:
        continue;
    }
    if (lastIndex !== index2) {
      html2 += str2.substring(lastIndex, index2);
    }
    lastIndex = index2 + 1;
    html2 += escape2;
  }
  return lastIndex !== index2 ? html2 + str2.substring(lastIndex, index2) : html2;
}
var escape = getDefaultExportFromCjs(escapeHtml_1);
function _optionalChain(ops) {
  let lastAccessLHS = void 0;
  let value = ops[0];
  let i = 1;
  while (i < ops.length) {
    const op = ops[i];
    const fn = ops[i + 1];
    i += 2;
    if ((op === "optionalAccess" || op === "optionalCall") && value == null) {
      return void 0;
    }
    if (op === "access" || op === "optionalAccess") {
      lastAccessLHS = value;
      value = fn(value);
    } else if (op === "call" || op === "optionalCall") {
      value = fn((...args) => value.call(lastAccessLHS, ...args));
      lastAccessLHS = void 0;
    }
  }
  return value;
}
var path;
var newline2 = "\n";
function default_frontmatter(value, messages2) {
  try {
    return yaml$1.safeLoad(value);
  } catch (e2) {
    messages2.push(new Message("YAML failed to parse"));
  }
}
function parse_frontmatter({
  parse: parse8,
  type: type2
}) {
  const transformer = (tree, vFile) => {
    visit$6(tree, type2, (node) => {
      const data3 = parse8(node.value, vFile.messages);
      if (data3) {
        vFile.data.fm = data3;
      }
    });
  };
  return transformer;
}
function escape_code({ blocks }) {
  const entites = [
    [/</g, "&lt;"],
    [/>/g, "&gt;"],
    [/{/g, "&#123;"],
    [/}/g, "&#125;"]
  ];
  return function(tree) {
    if (!blocks) {
      visit$6(tree, "code", escape2);
    }
    visit$6(tree, "inlineCode", escape2);
    function escape2(node) {
      for (let i = 0; i < entites.length; i += 1) {
        node.value = node.value.replace(entites[i][0], entites[i][1]);
      }
    }
  };
}
function escape_brackets() {
  const entites = [
    // remark-parse does not transform \<
    [/\\</g, "&lt;"],
    // remark-parse transforms \> to '>', and &gt; to '>'
    [/^>$/g, "&gt;"],
    // remark-parse transforms &lt; to '<'
    [/^<$/g, "&lt;"]
  ];
  return function(tree) {
    visit$6(tree, "text", escape2);
    function escape2(node) {
      for (let i = 0; i < entites.length; i += 1) {
        node.value = node.value.replace(entites[i][0], entites[i][1]);
      }
    }
  };
}
function smartypants_transformer(options2 = {}) {
  const processor = retext$1().use(smartypants$1, options2);
  return function(tree) {
    visit$6(tree, "text", (node) => {
      node.value = String(processor.processSync(node.value));
    });
  };
}
var attrs = `(?:\\s{0,1}[a-zA-z]+=(?:"){0,1}[a-zA-Z0-9]+(?:"){0,1})*`;
var context = `(?:\\s{0,1}context)=(?:"){0,1}module(?:"){0,1}`;
var RE_BLANK = /^\n+$|^\s+$/;
var RE_SCRIPT = new RegExp(`^(<script` + attrs + `>)`);
var RE_MODULE_SCRIPT = new RegExp(
  `^(<script` + attrs + context + attrs + `>)`
);
function extract_parts(nodes) {
  const parts = {
    special: [],
    html: [],
    instance: [],
    module: [],
    css: []
  };
  children: for (let i = 0; i < nodes.length; i += 1) {
    const empty_node = nodes[i].type === "text" && RE_BLANK.exec(nodes[i].value);
    if (empty_node || !nodes[i].value) {
      if (!parts.html.length || !(RE_BLANK.exec(nodes[i].value) && RE_BLANK.exec(parts.html[parts.html.length - 1].value))) {
        parts.html.push(nodes[i]);
      }
      continue children;
    }
    let result;
    try {
      result = parse6(nodes[i].value);
    } catch (e2) {
      parts.html.push(nodes[i]);
      continue children;
    }
    if (!result.html || !result.html.children) return parts;
    const _parts = result.html.children.map((v) => {
      if (v.type === "Options" || v.type === "Head" || v.type === "Window" || v.type === "Body") {
        return ["special", v.start, v.end];
      } else {
        return ["html", v.start, v.end];
      }
    });
    results: for (const key2 in result) {
      if (key2 === "html" || !result[key2])
        continue results;
      _parts.push([
        key2,
        result[key2].start,
        result[key2].end
      ]);
    }
    const sorted = _parts.sort((a, b) => a[1] - b[1]);
    sorted.forEach((next2) => {
      parts[next2[0]].push({
        type: "raw",
        value: nodes[i].value.substring(next2[1], next2[2])
      });
    });
  }
  return parts;
}
function map_layout_to_path(filename2, layout_map) {
  const match = Object.keys(layout_map).find(
    (l2) => new RegExp(`\\${path.sep}${l2}\\${path.sep}`).test(
      path.normalize(filename2).replace(process.cwd(), "")
    )
  );
  if (match) {
    return layout_map[match];
  } else {
    return layout_map["_"] ? layout_map["_"] : void 0;
  }
}
function generate_layout_import(layout) {
  if (!layout) return false;
  return `import Layout_MDSVEX_DEFAULT${layout.components.length ? `, * as Components` : ""} from '${layout.path}';`;
}
function generate_layout({
  frontmatter_layout,
  layout_options,
  layout_mode,
  filename: filename2
}) {
  let selected_layout;
  const error = { reason: "" };
  if (!layout_options || frontmatter_layout === false) {
    return [false, false, false];
  } else if (layout_mode === "single") {
    selected_layout = layout_options.__mdsvex_default;
    if (frontmatter_layout)
      error.reason = `You attempted to apply a named layout in the front-matter of "${filename2}", but did not provide any named layouts as options to the preprocessor. `;
  } else if (frontmatter_layout) {
    selected_layout = layout_options[frontmatter_layout];
    if (!selected_layout)
      error.reason = `Could not find a layout with the name "${frontmatter_layout}" and no fall back layout ("_") was provided.`;
  } else {
    selected_layout = map_layout_to_path(filename2, layout_options);
  }
  return [
    generate_layout_import(selected_layout),
    selected_layout !== void 0 && selected_layout.components.length > 0 && selected_layout.components,
    error.reason ? error : false
  ];
}
var handle_path = async () => {
  path = await import("./path-3FR4MLQ3.js");
};
function transform_hast({
  layout,
  layout_mode
}) {
  return function transformer(tree, vFile) {
    visit$6(tree, "element", (node) => {
      if (node.tagName === "a" && node.properties && typeof node.properties.href === "string") {
        node.properties.href = node.properties.href.replace(/%7B/g, "{").replace(/%7D/g, "}");
      }
      if (node.tagName === "img" && node.properties && typeof node.properties.src === "string") {
        node.properties.src = node.properties.src.replace(/%7B/g, "{").replace(/%7D/g, "}");
      }
    });
    if (!layout && !vFile.data.fm) return tree;
    visit$6(tree, "root", (node) => {
      const { special: special2, html: html2, instance, module: _module, css } = extract_parts(
        node.children
      );
      const { fm: metadata } = vFile.data;
      const stringified = metadata && JSON.stringify(metadata).replace(/<(\/?script|\/?style)/g, '<"+"$1');
      const fm = metadata && `export const metadata = ${stringified};${newline2}	const { ${Object.keys(metadata).map(
        (key2) => key2.includes("-") ? `'${key2}': ${key2.replace(/-/g, "_")}` : key2
      ).join(", ")} } = metadata;`;
      const frontmatter_layout = metadata && metadata.layout;
      const [import_script2, components, error] = generate_layout({
        frontmatter_layout,
        layout_options: layout,
        layout_mode,
        //@ts-ignore
        filename: vFile.filename
      });
      if (error) vFile.messages.push(new Message(error.reason));
      if (components) {
        for (let i = 0; i < components.length; i++) {
          visit$6(tree, "element", (node2) => {
            if (node2.tagName === components[i]) {
              node2.tagName = `Components.${components[i]}`;
            }
          });
        }
      }
      if (import_script2 && !instance[0]) {
        instance.push({
          type: "raw",
          value: `${newline2}<script>${newline2}	${import_script2}${newline2}<\/script>${newline2}`
        });
      } else if (import_script2) {
        instance[0].value = instance[0].value.replace(
          RE_SCRIPT,
          `$1${newline2}	${import_script2}`
        );
      }
      if (!_module[0] && fm) {
        _module.push({
          type: "raw",
          value: `<script context="module">${newline2}	${fm}${newline2}<\/script>`
        });
      } else if (fm) {
        _module[0].value = _module[0].value.replace(
          RE_MODULE_SCRIPT,
          (match) => `${match}${newline2}	${fm}`
        );
      }
      node.children = [
        //@ts-ignore
        ..._module,
        //@ts-ignore
        { type: "raw", value: _module[0] ? newline2 : "" },
        //@ts-ignore
        ...instance,
        //@ts-ignore
        { type: "raw", value: instance[0] ? newline2 : "" },
        //@ts-ignore
        ...css,
        //@ts-ignore
        { type: "raw", value: css[0] ? newline2 : "" },
        //@ts-ignore
        ...special2,
        //@ts-ignore
        { type: "raw", value: special2[0] ? newline2 : "" },
        {
          //@ts-ignore
          type: "raw",
          value: import_script2 ? `<Layout_MDSVEX_DEFAULT {...$$props}${fm ? " {...metadata}" : ""}>` : ""
        },
        //@ts-ignore
        { type: "raw", value: newline2 },
        //@ts-ignore
        ...html2,
        //@ts-ignore
        { type: "raw", value: newline2 },
        //@ts-ignore
        { type: "raw", value: import_script2 ? "</Layout_MDSVEX_DEFAULT>" : "" }
      ];
    });
  };
}
var langs = {};
var Prism;
var make_path = (base_path, id2) => base_path.replace("{id}", id2);
function get_lang_info(name2, lang_meta, base_path) {
  const _lang_meta = {
    name: name2,
    path: `prismjs/${make_path(base_path, name2)}`,
    deps: /* @__PURE__ */ new Set()
  };
  const aliases = /* @__PURE__ */ new Set();
  if (lang_meta.require) {
    if (Array.isArray(lang_meta.require)) {
      lang_meta.require.forEach((id2) => _lang_meta.deps.add(id2));
    } else {
      _lang_meta.deps.add(lang_meta.require);
    }
  }
  if (lang_meta.peerDependencies) {
    if (Array.isArray(lang_meta.peerDependencies)) {
      lang_meta.peerDependencies.forEach((id2) => _lang_meta.deps.add(id2));
    } else {
      _lang_meta.deps.add(lang_meta.peerDependencies);
    }
  }
  if (lang_meta.alias) {
    if (Array.isArray(lang_meta.alias)) {
      lang_meta.alias.forEach((id2) => aliases.add(id2));
    } else {
      aliases.add(lang_meta.alias);
    }
  }
  return [{ ..._lang_meta, aliases }, aliases];
}
async function load_language_metadata() {
  const mod = await import(
    //@ts-ignore
    "./components-DzBOjdti-2MXLTDY3.js"
  ).then(function(n) {
    return n.c;
  });
  const languages = mod.languages || mod.default.languages;
  const meta2 = languages.meta;
  for (const lang2 in languages) {
    const [lang_info, aliases] = get_lang_info(
      lang2,
      // @ts-ignore
      languages[lang2],
      meta2.path
    );
    langs[lang2] = lang_info;
    aliases.forEach((_n) => {
      langs[_n] = langs[lang2];
    });
  }
  const svelte_meta = {
    name: "svelte",
    aliases: /* @__PURE__ */ new Set(["sv"]),
    path: "prism-svelte",
    deps: /* @__PURE__ */ new Set(["javscript", "css"])
  };
  langs.svelte = svelte_meta;
  langs.sv = svelte_meta;
}
async function load_language(lang2) {
  if (!langs[lang2]) return;
  await Promise.all(
    Array.from(langs[lang2].deps).map(async (name2) => await load_language(name2))
  );
  try {
    await import(
      /* @vite-ignore */
      langs[lang2].path
    );
  } catch (e2) {
    try {
      await import(
        /* @vite-ignore */
        langs[lang2].path + ".js"
      );
    } catch (e3) {
      console.log("failed to load language", lang2);
    }
  }
}
function highlight_blocks({
  highlighter: highlight_fn,
  alias,
  optimise = true
} = {}) {
  let pending_langs;
  let processed_langs = false;
  if (highlight_fn) {
    pending_langs = load_language_metadata();
  }
  return async function(tree, vFile) {
    if (highlight_fn) {
      if (!processed_langs) {
        await pending_langs;
        if (alias) {
          for (const lang2 in alias) {
            langs[lang2] = langs[alias[lang2]];
          }
        }
        processed_langs = true;
      }
      const nodes = [];
      visit$6(tree, "code", (node) => {
        nodes.push(node);
      });
      await Promise.all(
        nodes.map(async (node) => {
          node.type = "html";
          node.value = await highlight_fn(
            node.value,
            node.lang,
            node.meta,
            //@ts-ignore
            vFile.filename,
            optimise
          );
        })
      );
    }
  };
}
var escape_svelty = (str2) => str2.replace(
  /[{}`]/g,
  //@ts-ignore
  (c) => ({ "{": "&#123;", "}": "&#125;", "`": "&#96;" })[c]
).replace(/\\([trn])/g, "&#92;$1");
var code_highlight = async (code2, lang2, _meta, _filename, optimise) => {
  const normalised_lang = _optionalChain([lang2, "optionalAccess", (_) => _.toLowerCase, "call", (_2) => _2()]);
  let _lang = !!normalised_lang && langs[normalised_lang];
  if (!Prism) Prism = await import("./prism-Thd-V7xt-CWOYFU6A.js").then(function(n) {
    return n.p;
  });
  let status = "loading";
  if (_lang && !Prism.languages[_lang.name]) {
    try {
      await load_language(_lang.name);
      status = "loaded";
    } catch (e2) {
      status = "failed";
    }
  }
  if (!_lang && normalised_lang && Prism.languages[normalised_lang] && status === "loaded") {
    langs[normalised_lang] = { name: lang2 };
    _lang = langs[normalised_lang];
  }
  const highlighted = escape_svelty(
    _lang && Prism.languages[_lang.name] ? Prism.highlight(code2, Prism.languages[_lang.name], _lang.name) : escape(code2)
  );
  return optimise ? `<pre class="language-${normalised_lang}">{@html \`<code class="language-${normalised_lang}">${highlighted}</code>\`}</pre>` : `<pre class="language-${normalised_lang}"><code class="language-${normalised_lang}">${highlighted}</code></pre>`;
};
var is_browser = typeof window !== "undefined";
function stringify(options2 = {}) {
  this.Compiler = compiler2;
  function compiler2(tree) {
    return hast_to_html(tree, options2);
  }
}
var apply_plugins = (plugins, parser2) => {
  plugins.forEach((plugin) => {
    if (Array.isArray(plugin)) {
      if (plugin[1] && plugin[1]) parser2.use(plugin[0], plugin[1]);
      else parser2.use(plugin[0]);
    } else {
      parser2.use(plugin);
    }
  });
  return parser2;
};
function transform({
  remarkPlugins = [],
  rehypePlugins = [],
  frontmatter: frontmatter2,
  smartypants: smartypants2,
  highlight
} = {}) {
  const fm_opts = frontmatter2 ? frontmatter2 : { parse: default_frontmatter, type: "yaml", marker: "-" };
  const toMDAST = unified$3().use(markdown).use(mdsvex_parser).use(external, { target: false, rel: ["nofollow"] }).use(escape_brackets).use(escape_code, { blocks: !!highlight }).use(extract_frontmatter, [{ type: fm_opts.type, marker: fm_opts.marker }]).use(parse_frontmatter, { parse: fm_opts.parse, type: fm_opts.type });
  if (smartypants2) {
    toMDAST.use(
      smartypants_transformer,
      typeof smartypants2 === "boolean" ? {} : smartypants2
    );
  }
  apply_plugins(remarkPlugins, toMDAST).use(highlight_blocks, highlight || {});
  const toHAST = toMDAST.use(remark2rehype$1, {
    // @ts-ignore
    allowDangerousHtml: true,
    allowDangerousCharacters: true
  });
  apply_plugins(rehypePlugins, toHAST);
  const processor = toHAST.use(stringify, {
    allowDangerousHtml: true,
    allowDangerousCharacters: true
  });
  processor.add_layouts = (layout, layout_mode) => {
    processor.use(transform_hast, { layout, layout_mode });
  };
  return processor;
}
var defaults = {
  remarkPlugins: [],
  rehypePlugins: [],
  smartypants: true,
  extension: ".svx",
  highlight: { highlighter: code_highlight, optimise: true }
};
function to_posix(_path) {
  const isExtendedLengthPath = /^\\\\\?\\/.test(_path);
  const hasNonAscii = /[^\u0000-\u0080]+/.test(_path);
  if (isExtendedLengthPath || hasNonAscii) {
    return _path;
  }
  return _path.replace(/\\/g, "/");
}
async function resolve_layout(layout_path) {
  if (is_browser) {
    return to_posix(layout_path);
  }
  try {
    return to_posix(layout_path);
  } catch (e2) {
    const path2 = await import("./path-3FR4MLQ3.js");
    try {
      const _path = path2.join(process.cwd(), layout_path);
      return to_posix(_path);
    } catch (e3) {
      throw new Error(
        `The layout path you provided couldn't be found at either ${layout_path} or ${path2.join(
          process.cwd(),
          layout_path
        )}. Please double-check it and try again.`
      );
    }
  }
}
async function process_layouts(layouts) {
  if (is_browser) {
    return layouts;
  }
  const _layouts = layouts;
  for (const key2 in _layouts) {
    const fs = await import("./fs-KXLUXRDK.js");
    const layout = fs.readFileSync(_layouts[key2].path, { encoding: "utf8" });
    let ast2;
    try {
      ast2 = parse6(layout);
    } catch (e2) {
      throw new Error(e2.toString() + `
	at ${_layouts[key2].path}`);
    }
    if (ast2.module) {
      const component_exports = ast2.module.content.body.filter(
        (node) => node.type === "ExportNamedDeclaration"
      );
      if (component_exports.length) {
        _layouts[key2].components = [];
        for (let i = 0; i < component_exports.length; i++) {
          if (component_exports[i].specifiers && component_exports[i].specifiers.length) {
            for (let j = 0; j < component_exports[i].specifiers.length; j++) {
              _layouts[key2].components.push(
                component_exports[i].specifiers[j].exported.name
              );
            }
          } else if (component_exports[i].declaration.declarations) {
            const declarations = component_exports[i].declaration.declarations;
            for (let j = 0; j < declarations.length; j++) {
              _layouts[key2].components.push(declarations[j].id.name);
            }
          } else if (component_exports[i].declaration) {
            _layouts[key2].components.push(
              //@ts-ignore
              component_exports[i].declaration.id.name
            );
          }
        }
      }
    }
  }
  return _layouts;
}
var mdsvex = (options2 = defaults) => {
  let {
    remarkPlugins = [],
    rehypePlugins = [],
    smartypants: smartypants2 = true,
    extension = ".svx",
    extensions,
    layout = false,
    highlight = { highlighter: code_highlight, optimise: true },
    frontmatter: frontmatter2
  } = options2;
  if (highlight === void 0) {
    highlight = { highlighter: code_highlight, optimise: true };
  } else if (highlight) {
    highlight = {
      highlighter: code_highlight,
      optimise: true,
      ...highlight
    };
  }
  if (options2.layouts) {
    throw new Error(
      `mdsvex: "layouts" is not a valid option. Did you mean "layout"?`
    );
  }
  const unknown_opts = [];
  const known_opts = [
    "filename",
    "remarkPlugins",
    "rehypePlugins",
    "smartypants",
    "extension",
    "extensions",
    "layout",
    "highlight",
    "frontmatter"
  ];
  for (const opt in options2) {
    if (!known_opts.includes(opt)) unknown_opts.push(opt);
  }
  if (unknown_opts.length) {
    console.warn(
      `mdsvex: Received unknown options: ${unknown_opts.join(
        ", "
      )}. Valid options are: ${known_opts.join(", ")}.`
    );
  }
  let layouts_processed = void 0;
  const parser2 = transform({
    remarkPlugins,
    rehypePlugins,
    smartypants: smartypants2,
    highlight,
    frontmatter: frontmatter2
  });
  return {
    name: "mdsvex",
    markup: async ({ content, filename: filename2 }) => {
      let _layout = {};
      let layout_mode = "single";
      if (!layouts_processed && !is_browser) {
        let resolve;
        layouts_processed = new Promise((r) => resolve = r);
        await handle_path();
        if (typeof layout === "string") {
          _layout.__mdsvex_default = {
            path: await resolve_layout(layout),
            components: []
          };
        } else if (typeof layout === "object") {
          layout_mode = "named";
          for (const name2 in layout) {
            _layout[name2] = {
              path: await resolve_layout(layout[name2]),
              components: []
            };
          }
        }
        _layout = await process_layouts(_layout);
        parser2.add_layouts(_layout, layout_mode);
        resolve();
      }
      if (highlight && highlight.highlighter === void 0) {
        highlight.highlighter = code_highlight;
      }
      const extensionsParts = (extensions || [extension]).map(
        (ext) => ext.startsWith(".") ? ext : "." + ext
      );
      if (!extensionsParts.some((ext) => filename2.endsWith(ext))) return;
      await layouts_processed;
      const parsed = await parser2.process({ contents: content, filename: filename2 });
      return {
        code: parsed.contents,
        data: parsed.data,
        map: ""
      };
    }
  };
};
var _compile = async (source2, opts) => {
  if (is_browser) {
    globalThis.process = make_process();
  }
  const preprocessor = mdsvex(opts);
  return preprocessor.markup({
    content: source2,
    filename: opts && opts.filename || `file${opts && (opts.extensions && opts.extensions[0] || opts.extension) || ".svx"}`
  });
};
globalThis.global = globalThis;
if (typeof window !== "undefined") {
  window.global = globalThis;
}

export {
  defineConfig,
  commonjsGlobal,
  getDefaultExportFromCjs,
  escape_svelty,
  code_highlight,
  mdsvex,
  _compile
};
//# sourceMappingURL=chunk-56D57423.js.map
