{
  "version": 3,
  "sources": ["../../.deno/javascript-interface-library@0.1.14/node_modules/javascript-interface-library/src/javascript-interface-library.ts", "../../.deno/svelte-coordinate-conversion@0.1.9/node_modules/svelte-coordinate-conversion/src/svelte-coordinate-conversion.ts", "../../.deno/svelte-drag-and-drop-actions@0.1.35/node_modules/svelte-drag-and-drop-actions/src/svelte-drag-and-drop-actions.ts"],
  "sourcesContent": ["//----------------------------------------------------------------------------//\n//                        JavaScript Interface Library                        //\n//----------------------------------------------------------------------------//\n\n/**** get a reference to the \"global\" object ****/\n\n  export const global = /*#__PURE__*/ Function('return this')()\n// see https://stackoverflow.com/questions/3277182/how-to-get-the-global-object-in-javascript\n\n//------------------------------------------------------------------------------\n//--                             Object Functions                             --\n//------------------------------------------------------------------------------\n// allow methods from Object.prototype to be applied to \"vanilla\" objects\n\n/**** Object_hasOwnProperty ****/\n\n  export function Object_hasOwnProperty (Value:Object, PropertyName:string):boolean {\n    return (\n      (Value == null) ||              // let this method crash like its original\n      ('hasOwnProperty' in Value) && (typeof Value.hasOwnProperty === 'function')\n      ? Value.hasOwnProperty(PropertyName)\n      : Object.prototype.hasOwnProperty.call(Value,PropertyName)\n    )\n  }\n\n/**** Object_isPrototypeOf ****/\n\n  export function Object_isPrototypeOf (Value:Object, Candidate:any):boolean {\n    return (\n      (Value == null) ||              // let this method crash like its original\n      ('isPrototypeOf' in Value) && (typeof Value.isPrototypeOf === 'function')\n      ? Value.isPrototypeOf(Candidate)\n      : Object.prototype.isPrototypeOf.call(Value,Candidate)\n    )\n  }\n\n/**** Object_propertyIsEnumerable ****/\n\n  export function Object_propertyIsEnumerable (Value:Object, PropertyName:string):boolean {\n    return (\n      (Value == null) ||              // let this method crash like its original\n      ('propertyIsEnumerable' in Value) && (typeof Value.propertyIsEnumerable === 'function')\n      ? Value.propertyIsEnumerable(PropertyName)\n      : Object.prototype.propertyIsEnumerable.call(Value,PropertyName)\n    )\n  }\n\n/**** Object_toString ****/\n\n  export function Object_toString (Value:Object):string {\n    return (\n      (Value == null) ||              // let this method crash like its original\n      ('toString' in Value) && (typeof Value.toString === 'function')\n      ? Value.toString()\n      : Object.prototype.toString.call(Value)\n    )\n  }\n\n/**** Object_toLocaleString ****/\n\n  export function Object_toLocaleString (Value:Object):string {\n    return (\n      (Value == null) ||              // let this method crash like its original\n      ('toLocaleString' in Value) && (typeof Value.toLocaleString === 'function')\n      ? Value.toLocaleString()\n      : Object.prototype.toString.call(Value)\n    ) // a missing \"toLocaleString\" method will crash Object.prototype.toLocaleString\n  }\n\n/**** Object_valueOf ****/\n\n  export function Object_valueOf (Value:Object):any {\n    return (\n      (Value == null) ||              // let this method crash like its original\n      ('valueOf' in Value) && (typeof Value.valueOf === 'function')\n      ? Value.valueOf()\n      : Object.prototype.valueOf.call(Value)\n    )\n  }\n\n/**** ObjectMergedWith ****/\n\n  export function ObjectMergedWith (\n    TargetObject:object, ...otherObjectList:object[]\n  ):object {\n    for (let i = 0, l = otherObjectList.length; i < l; i++) {\n      let otherObject = otherObjectList[i]\n      if (otherObject == null) { continue }\n\n      if (typeof otherObject === 'object') {\n        for (let Key in otherObject) {\n          let Descriptor = Object.getOwnPropertyDescriptor(otherObject,Key)\n          if (Descriptor != null) {\n            Object.defineProperty(TargetObject,Key,Descriptor)\n          }\n        }\n      } else {\n        throwError('InvalidArgument: argument #' + (i+1) + ' is not an object')\n      }\n    }\n\n    return TargetObject\n  }\n\n/**** throwError - simplifies construction of named errors ****/\n\n  export function throwError (Message:string):never {\n    let Match = /^([$a-zA-Z][$a-zA-Z0-9]*):\\s*(\\S.+)\\s*$/.exec(Message)\n    if (Match == null) {\n      throw new Error(Message)\n    } else {\n      let namedError = new Error(Match[2])\n        namedError.name = Match[1]\n      throw namedError\n    }\n  }\n\n//------------------------------------------------------------------------------\n//--                      Value Classification Functions                      --\n//------------------------------------------------------------------------------\n\n/**** ValueExists ****/\n\n  export function ValueExists (Value:any):boolean {\n    return (Value != null)\n  }\n\n/**** ValueIsMissing ****/\n\n  export function ValueIsMissing (Value:any):boolean {\n    return (Value == null)\n  }\n\n/**** ValueIsBoolean ****/\n\n  export function ValueIsBoolean (Value:any):boolean {\n    return (typeof Value === 'boolean') || (Value instanceof Boolean)\n  }\n\n/**** ValueIsNumber ****/\n\n  export function ValueIsNumber (Value:any):boolean {\n    return (typeof Value === 'number') || (Value instanceof Number)\n  }\n\n/**** ValueIsFiniteNumber (pure \"isFinite\" breaks on objects) ****/\n\n  export function ValueIsFiniteNumber (Value:any):boolean {\n    return (\n      (typeof Value === 'number') || (Value instanceof Number)\n    ) && isFinite(Value.valueOf())\n  }\n\n/**** ValueIsNaN (numeric, but NaN - this differs from pure \"isNaN\") ****/\n\n  export function ValueIsNaN (Value:any):boolean {\n    return (\n      (typeof Value === 'number') || (Value instanceof Number)\n    ) && isNaN(Value.valueOf())\n  }\n\n/**** ValueIsNumberInRange ****/\n\n  export function ValueIsNumberInRange (\n    Value:any, minValue?:number, maxValue?:number,\n    withMin:boolean = true, withMax:boolean = true\n  ):boolean {\n    if (! ValueIsNumber(Value) || isNaN(Value)) { return false }\n\n    if (ValueIsFiniteNumber(minValue)) {    // more robust than \"isFinite\" alone\n      if (ValueIsFiniteNumber(maxValue)) {  // more robust than \"isFinite\" alone\n        if (\n          (Value < (minValue as Number)) || (! withMin && (Value === minValue)) ||\n          (Value > (maxValue as Number)) || (! withMax && (Value === maxValue))\n        ) {\n          return false\n        }\n      } else {\n        if ((Value < (minValue as Number)) || (! withMin && (Value === minValue))) {\n          return false\n        }\n      }\n    } else {\n      if (ValueIsFiniteNumber(maxValue)) {  // more robust than \"isFinite\" alone\n        if ((Value > (maxValue as Number)) || (! withMax && (Value === maxValue))) {\n          return false\n        }\n      }\n    }\n\n    return true\n  }\n\n/**** ValueIsInteger ****/\n\n  export function ValueIsInteger (Value:any):boolean {\n    if ((typeof Value !== 'number') && ! (Value instanceof Number)) {\n      return false\n    }\n\n    Value = Value.valueOf()\n    return isFinite(Value) && (Math.round(Value) === Value)\n  }\n\n/**** ValueIsIntegerInRange ****/\n\n  export function ValueIsIntegerInRange (\n    Value:any, minValue?:number, maxValue?:number\n  ):boolean {\n    if (! ValueIsInteger(Value) || isNaN(Value)) { return false }\n\n    if (ValueIsFiniteNumber(minValue)) {    // more robust than \"isFinite\" alone\n      if (ValueIsFiniteNumber(maxValue)) {  // more robust than \"isFinite\" alone\n        if ((Value < (minValue as Number)) || (Value > (maxValue as Number))) {\n          return false\n        }\n      } else {\n        if (Value < (minValue as Number)) {\n          return false\n        }\n      }\n    } else {\n      if (ValueIsFiniteNumber(maxValue)) {  // more robust than \"isFinite\" alone\n        if (Value > (maxValue as Number)) {\n          return false\n        }\n      }\n    }\n\n    return true\n  }\n\n/**** ValueIsOrdinal ****/\n\n  export function ValueIsOrdinal (Value:any):boolean {\n    if ((typeof Value !== 'number') && ! (Value instanceof Number)) {\n      return false\n    }\n\n    Value = Value.valueOf()\n    return isFinite(Value) && (Math.round(Value) === Value) && (Value >= 0)\n  }\n\n/**** ValueIsCardinal ****/\n\n  export function ValueIsCardinal (Value:any):boolean {\n    if ((typeof Value !== 'number') && ! (Value instanceof Number)) {\n      return false\n    }\n\n    Value = Value.valueOf()\n    return isFinite(Value) && (Math.round(Value) === Value) && (Value >= 1)\n  }\n\n/**** ValueIsString ****/\n\n  export function ValueIsString (Value:any):boolean {\n    return (typeof Value === 'string') || (Value instanceof String)\n  }\n\n/**** ValueIs[Non]EmptyString ****/\n\n  const emptyStringPattern = /^\\s*$/\n\n  export function ValueIsEmptyString (Value:any):boolean {\n    return (\n      (typeof Value === 'string') || (Value instanceof String)\n    ) && emptyStringPattern.test(Value.valueOf())\n  }\n\n  export function ValueIsNonEmptyString (Value:any):boolean {\n    return (\n      (typeof Value === 'string') || (Value instanceof String)\n    ) && ! emptyStringPattern.test(Value.valueOf())\n  }\n\n/**** ValueIsStringMatching ****/\n\n  export function ValueIsStringMatching (Value:any, Pattern:RegExp):boolean {\n    return (\n      (typeof Value === 'string') || (Value instanceof String)\n    ) && Pattern.test(Value.valueOf())\n  }\n\n/**** ValueIsText ****/\n\n  const noCtrlCharsButCRLFPattern = /^[^\\x00-\\x09\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x9F\\u2028\\u2029\\uFFF9-\\uFFFB]*$/\n\n  export function ValueIsText (Value:any):boolean {\n    return ValueIsStringMatching(Value,noCtrlCharsButCRLFPattern)\n  }\n\n/**** ValueIsTextline ****/\n\n  const noCtrlCharsPattern = /^[^\\x00-\\x1F\\x7F-\\x9F\\u2028\\u2029\\uFFF9-\\uFFFB]*$/\n\n  export function ValueIsTextline (Value:any):boolean {\n    return ValueIsStringMatching(Value,noCtrlCharsPattern)\n  }\n\n/**** ValueIsFunction ****/\n\n  export function ValueIsFunction (Value:any):boolean {\n    return (typeof Value === 'function')\n  }\n\n/**** ValueIsAnonymousFunction ****/\n\n  export function ValueIsAnonymousFunction (Value:any):boolean {\n    return (\n      (typeof Value === 'function') &&\n      ((Value.name == null) || (Value.name === ''))\n    )\n  }\n\n/**** ValueIsNamedFunction ****/\n\n  export function ValueIsNamedFunction (Value:any):boolean {\n    return (\n      (typeof Value === 'function') &&\n      (Value.name != null) && (Value.name !== '')\n    )\n  }\n\n/**** ValueIsNativeFunction ****/\n\n  export function ValueIsNativeFunction (Value:any):boolean {\n    return (\n      (typeof Value === 'function') &&\n      /^function\\s*[^(]*\\(\\)\\s*\\{\\s*\\[native code\\]\\s*\\}\\s*$/.test(Value.toString())\n    )\n  }\n\n/**** ValueIsScriptedFunction ****/\n\n  export function ValueIsScriptedFunction (Value:any):boolean {\n    return (\n      (typeof Value === 'function') &&\n      ! /^function\\s*[^(]*\\(\\)\\s*\\{\\s*\\[native code\\]\\s*\\}\\s*$/.test(Value.toString())\n    )\n  }\n\n/**** ValueIsObject ****/\n\n  export function ValueIsObject (Value:any):boolean {\n    return (Value != null) && (typeof Value === 'object')\n  }\n\n/**** ValueIsPlainObject ****/\n\n  export function ValueIsPlainObject (Value:any):boolean {\n    return (\n      (Value != null) && (typeof Value === 'object') &&\n      (Object.getPrototypeOf(Value) === Object.prototype)\n    )\n  }\n\n/**** ValueIsVanillaObject ****/\n\n  export function ValueIsVanillaObject (Value:any):boolean {\n    return (\n      (Value != null) && (typeof Value === 'object') &&\n      ! (Value instanceof Object)\n    )\n  }\n\n/**** ValueIsArray ****/\n\n  export let ValueIsArray = Array.isArray\n\n/**** ValueIsList (\"dense\" array) ****/\n\n  export function ValueIsList (\n    Value:any, minLength?:number, maxLength?:number\n  ):boolean {\n    if (ValueIsArray(Value)) {\n      for (let i = 0, l = Value.length; i < l; i++) {\n        if (Value[i] === undefined) { return false }\n      }\n\n      if (minLength != null) {\n        if (Value.length < minLength) { return false }\n      }\n\n      if (maxLength != null) {\n        if (Value.length > maxLength) { return false }\n      }\n      return true\n    }\n\n    return false\n  }\n\n/**** ValueIsListSatisfying ****/\n\n  export function ValueIsListSatisfying (\n    Value:any, Validator:Function, minLength?:number, maxLength?:number\n  ):boolean {\n    if (ValueIsArray(Value)) {\n      try {\n        for (let i = 0, l = Value.length; i < l; i++) {\n          if (Validator(Value[i]) == false) { return false }\n        }\n\n        if (minLength != null) {\n          if (Value.length < minLength) { return false }\n        }\n\n        if (maxLength != null) {\n          if (Value.length > maxLength) { return false }\n        }\n        return true\n      } catch (Signal) { /* nop */ }\n    }\n\n    return false\n  }\n\n/**** ValueIsInstanceOf ****/\n\n  export function ValueIsInstanceOf (Value:any, Constructor:Function):boolean {\n    return (Value instanceof Constructor)\n  }\n\n/**** ValueInheritsFrom ****/\n\n  export function ValueInheritsFrom (Value:any, Prototype:Object):boolean {\n    return Object_isPrototypeOf(Prototype,Value)\n  }\n\n/**** ValueIsDate ****/\n\n  export function ValueIsDate (Value:any):boolean {\n    return (Value instanceof Date)\n  }\n\n/**** ValueIsError ****/\n\n  export function ValueIsError (Value:any):boolean {\n    return (Value instanceof Error)\n  }\n\n/**** ValueIsPromise ****/\n\n  export function ValueIsPromise (Value:any):boolean {\n    return (Value != null) && (typeof Value.then === 'function')\n  }\n// see https://stackoverflow.com/questions/27746304/how-do-i-tell-if-an-object-is-a-promise\n\n/**** ValueIsRegExp ****/\n\n  export function ValueIsRegExp (Value:any):boolean {\n    return (Value instanceof RegExp)\n  }\n\n/**** ValueIsOneOf ****/\n\n  export function ValueIsOneOf (Value:any, ValueList:any[]):boolean {\n    return (ValueList.indexOf(Value) >= 0)\n  }                     // no automatic unboxing of boxed values and vice-versa!\n\n/**** ValueIsColor ****/\n\n  export function ValueIsColor (Value:any):boolean {\n    return ValueIsString(Value) && (\n      ColorSet.hasOwnProperty (Value) ||\n      /^#[a-fA-F0-9]{6}$/.test(Value) ||\n      /^#[a-fA-F0-9]{8}$/.test(Value) ||\n      /^rgb\\([0-9]+,\\s*[0-9]+,\\s*[0-9]+\\)$/.test(Value) ||        // not perfect\n      /^rgba\\([0-9]+,\\s*[0-9]+,\\s*[0-9]+,([01]|[0]?[.][0-9]+)\\)$/.test(Value) // dto.\n    )\n  }\n\n/**** ValueIsEMailAddress ****/\n\n  const EMailAddressPattern = /(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])/\n  // see https://stackoverflow.com/questions/201323/how-to-validate-an-email-address-using-a-regular-expression\n\n  export function ValueIsEMailAddress (Value:any):boolean {\n    return ValueIsStringMatching(Value, EMailAddressPattern)\n  }\n\n/**** ValueIsURL ****/\n\n  const noCtrlCharsOrWhitespacePattern = /^[^\\s\\x00-\\x1F\\x7F-\\x9F\\u2028\\u2029\\uFFF9-\\uFFFB]*$/\n\n  export function ValueIsURL (Value:any):boolean {\n    if (\n      ! ValueIsStringMatching(Value, noCtrlCharsOrWhitespacePattern) ||\n      (Value === '')\n    ) { return false }\n\n    try {\n      new URL(Value, 'file://')\n      return true\n    } catch (Signal) {\n      return false\n    }\n  }\n\n//------------------------------------------------------------------------------\n//--                      Argument Validation Functions                       --\n//------------------------------------------------------------------------------\n\n  export const rejectNil = false\n  export const acceptNil = true\n\n/**** validatedArgument ****/\n\n  export function validatedArgument (\n    Description:string, Argument:any, ValueIsValid:(Value:any) => boolean,\n    NilIsAcceptable:boolean, Expectation:string\n  ):any|null|undefined {\n    if (Argument == null) {\n      if (NilIsAcceptable) {\n        return Argument\n      } else {\n        throwError(`MissingArgument: no ${escaped(Description)} given`)\n      }\n    } else {\n      if (ValueIsValid(Argument)) {\n        switch (true) {\n          case Argument instanceof Boolean:\n          case Argument instanceof Number:\n          case Argument instanceof String:\n            return Argument.valueOf()                  // unboxes any primitives\n          default:\n            return Argument\n        }\n      } else {\n        throwError(\n          `InvalidArgument: the given ${escaped(Description)} is no valid ${escaped(Expectation)}`\n        )\n      }\n    }\n  }\n\n/**** ValidatorForClassifier ****/\n\n  export function ValidatorForClassifier (\n    Classifier:(Value:any) => boolean, NilIsAcceptable:boolean,\n    Expectation:string\n  ):Function {\n    let Validator = function (Description:string, Argument:any):any {\n      return validatedArgument(\n        Description, Argument, Classifier, NilIsAcceptable, Expectation\n      )\n    }\n\n    let ClassifierName = Classifier.name\n    if ((ClassifierName != null) && /^ValueIs/.test(ClassifierName)) {\n      let ValidatorName = ClassifierName.replace(  // derive name from validator\n        /^ValueIs/, NilIsAcceptable ? 'allow' : 'expect'\n      )\n      return FunctionWithName(Validator,ValidatorName)\n    } else {\n      return Validator                              // without any specific name\n    }\n  }\n\n/**** FunctionWithName (works with older JS engines as well) ****/\n\n  export function FunctionWithName (\n    originalFunction:Function, desiredName:string|String\n  ):Function {\n    if (originalFunction == null) {\n      throwError('MissingArgument: no function given')\n    }\n    if (typeof originalFunction !== 'function') {\n      throwError('InvalidArgument: the given 1st Argument is not a JavaScript function')\n    }\n\n    if (desiredName == null) {\n      throwError('MissingArgument: no desired name given')\n    }\n    if ((typeof desiredName !== 'string') && ! (desiredName instanceof String)) {\n      throwError('InvalidArgument: the given desired name is not a string')\n    }\n\n    if (originalFunction.name === desiredName) { return originalFunction }\n\n    try {\n      Object.defineProperty(originalFunction, 'name', { value:desiredName })\n      if (originalFunction.name === desiredName) { return originalFunction }\n    } catch (signal) { /* ok - let's take the hard way */ }\n\n    let renamed = new Function(\n      'originalFunction', 'return function ' + desiredName + ' () {' +\n        'return originalFunction.apply(this,Array.prototype.slice.apply(arguments))' +\n      '}'\n    )\n    return renamed(originalFunction)\n  }                                  // also works with older JavaScript engines\n\n/**** expect[ed]Value ****/\n\n  export function expectValue (Description:string, Argument:any):any {\n    if (Argument == null) {\n      throwError(`MissingArgument: no ${escaped(Description)} given`)\n    } else {\n      return Argument.valueOf()\n    }\n  }\n  export const expectedValue = expectValue\n\n/**** allow/expect[ed]Boolean ****/\n\n  export const allowBoolean = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsBoolean, acceptNil, 'boolean value'\n  ), allowedBoolean = allowBoolean\n\n  export const expectBoolean = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsBoolean, rejectNil, 'boolean value'\n  ), expectedBoolean = expectBoolean\n\n/**** allow/expect[ed]Number ****/\n\n  export const allowNumber = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsNumber, acceptNil, 'numeric value'\n  ), allowedNumber = allowNumber\n\n  export const expectNumber = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsNumber, rejectNil, 'numeric value'\n  ), expectedNumber = expectNumber\n\n/**** allow/expect[ed]FiniteNumber ****/\n\n  export const allowFiniteNumber = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsFiniteNumber, acceptNil, 'finite numeric value'\n  ), allowedFiniteNumber = allowFiniteNumber\n\n  export const expectFiniteNumber = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsFiniteNumber, rejectNil, 'finite numeric value'\n  ), expectedFiniteNumber = expectFiniteNumber\n\n/**** allow/expect[ed]NaN ****/\n\n  export const allowNaN = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsNaN, acceptNil, 'NaN value'\n  ), allowedNaN = allowNaN\n\n  export const expectNaN = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsNaN, rejectNil, 'NaN value'\n  ), expectedNaN = expectNaN\n\n/**** allow[ed]NumberInRange ****/\n\n  export function allowNumberInRange (\n    Description:string, Argument:any,\n    minValue?:number, maxValue?:number, withMin?:boolean, withMax?:boolean\n  ):number|null|undefined {\n    return (Argument == null\n      ? Argument\n      : expectedNumberInRange(Description, Argument, minValue,maxValue, withMin,withMax)\n    )\n  }\n  export const allowedNumberInRange = allowNumberInRange\n\n/**** expect[ed]NumberInRange ****/\n\n  export function expectNumberInRange (\n    Description:string, Argument:any,\n    minValue?:number, maxValue?:number, withMin?:boolean, withMax?:boolean\n  ):number {\n    expectNumber(Description, Argument)\n\n    if (isNaN(Argument)) {\n      throwError(\n        `InvalidArgument: the given ${escaped(Description)} is not-a-number`\n      )\n    }\n\n    if (withMin == null) { withMin = true }\n    if (withMax == null) { withMax = true }\n\n    if ((minValue != null) && isFinite(minValue)) {\n      if ((maxValue != null) && isFinite(maxValue)) {\n        if (\n          (Argument < minValue) || (! withMin && (Argument === minValue)) ||\n          (Argument > maxValue) || (! withMax && (Argument === maxValue))\n        ) {\n          throw new RangeError(\n            `the given ${escaped(Description)} (${Argument}) is outside ` +\n            `the allowed range (${minValue}...${maxValue})`\n          )\n        }\n      } else {\n        if ((Argument < minValue) || (! withMin && (Argument === minValue))) {\n          throw new RangeError(\n            `the given ${escaped(Description)} is below the allowed ` +\n            `minimum (${Argument} ${withMin ? '<' : '<='} ${minValue})`\n          )\n        }\n      }\n    } else {\n      if ((maxValue != null) && isFinite(maxValue)) {\n        if ((Argument > maxValue) || (! withMax && (Argument === maxValue))) {\n          throw new RangeError(\n            `the given ${escaped(Description)} exceeds the allowed ` +\n            `maximum (${Argument} ${withMax ? '>' : '>='} ${maxValue})`\n          )\n        }\n      }\n    }\n\n    return Argument.valueOf()\n  }\n  export const expectedNumberInRange = expectNumberInRange\n\n/**** allow/expect[ed]Integer ****/\n\n  export const allowInteger = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsInteger, acceptNil, 'integral numeric value'\n  ), allowedInteger = allowInteger\n\n  export const expectInteger = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsInteger, rejectNil, 'integral numeric value'\n  ), expectedInteger = expectInteger\n\n/**** allow[ed]IntegerInRange ****/\n\n  export function allowIntegerInRange (\n    Description:string, Argument:any, minValue?:number, maxValue?:number\n  ):number|null|undefined {\n    return (Argument == null\n      ? Argument\n      : expectedIntegerInRange(Description, Argument, minValue,maxValue)\n    )\n  }\n  export const allowedIntegerInRange = allowIntegerInRange\n\n/**** expect[ed]IntegerInRange ****/\n\n  export function expectIntegerInRange (\n    Description:string, Argument:any, minValue?:number, maxValue?:number\n  ):number {\n    expectInteger(Description, Argument)\n\n    if (isNaN(Argument)) {\n      throwError(\n        `InvalidArgument: the given ${escaped(Description)} is not-a-number`\n      )\n    }\n\n    if ((minValue != null) && isFinite(minValue)) {\n      if ((maxValue != null) && isFinite(maxValue)) {\n        if ((Argument < minValue) || (Argument > maxValue)) {\n          throw new RangeError(\n            `the given ${escaped(Description)} (${Argument}) is outside ` +\n            `the allowed range (${minValue}...${maxValue})`\n          )\n        }\n      } else {\n        if (Argument < minValue) {\n          throw new RangeError(\n            `the given ${escaped(Description)} is below the allowed ` +\n            `minimum (${Argument} < ${minValue})`\n          )\n        }\n      }\n    } else {\n      if ((maxValue != null) && isFinite(maxValue)) {\n        if (Argument > maxValue) {\n          throw new RangeError(\n            `the given ${escaped(Description)} exceeds the allowed ` +\n            `maximum (${Argument} > ${maxValue})`\n          )\n        }\n      }\n    }\n\n    return Argument.valueOf()\n  }\n  export const expectedIntegerInRange = expectIntegerInRange\n\n/**** allow/expect[ed]Ordinal ****/\n\n  export const allowOrdinal = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsOrdinal, acceptNil, 'ordinal number'\n  ), allowedOrdinal = allowOrdinal\n\n  export const expectOrdinal = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsOrdinal, rejectNil, 'ordinal number'\n  ), expectedOrdinal = expectOrdinal\n\n/**** allow/expect[ed]Cardinal ****/\n\n  export const allowCardinal = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsCardinal, acceptNil, 'cardinal number'\n  ), allowedCardinal = allowCardinal\n\n  export const expectCardinal = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsCardinal, rejectNil, 'cardinal number'\n  ), expectedCardinal = expectCardinal\n\n/**** allow/expect[ed]String ****/\n\n  export const allowString = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsString, acceptNil, 'literal string'\n  ), allowedString = allowString\n\n  export const expectString = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsString, rejectNil, 'literal string'\n  ), expectedString = expectString\n\n/**** allow/expect[ed]NonEmptyString ****/\n\n  export const allowNonEmptyString = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsNonEmptyString, acceptNil, 'non-empty literal string'\n  ), allowedNonEmptyString = allowNonEmptyString\n\n  export const expectNonEmptyString = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsNonEmptyString, rejectNil, 'non-empty literal string'\n  ), expectedNonEmptyString = expectNonEmptyString\n\n/**** allow[ed]StringMatching ****/\n\n  export function allowStringMatching (\n    Description:string, Argument:any, Pattern:RegExp\n  ):string|null|undefined {\n    return (Argument == null\n      ? Argument\n      : expectedStringMatching(Description, Argument, Pattern)\n    )\n  }\n  export const allowedStringMatching = allowStringMatching\n\n/**** expect[ed]StringMatching ****/\n\n  export function expectStringMatching (\n    Description:string, Argument:any, Pattern:RegExp\n  ):string {\n    expectString(Description, Argument)\n\n    if (Pattern.test(Argument)) {\n      return Argument.valueOf()\n    } else {\n      throwError(\n        `InvalidArgument: the given ${escaped(Description)} does not match the specified pattern`\n      )\n    }\n  }\n  export const expectedStringMatching = expectStringMatching\n\n/**** allow/expect[ed]Text ****/\n\n  export const allowText = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsText, acceptNil, 'literal text'\n  ), allowedText = allowText\n\n  export const expectText = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsText, rejectNil, 'literal text'\n  ), expectedText = expectText\n\n/**** allow/expect[ed]Textline ****/\n\n  export const allowTextline = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsTextline, acceptNil, 'single line of text'\n  ), allowedTextline = allowTextline\n\n  export const expectTextline = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsTextline, rejectNil, 'single line of text'\n  ), expectedTextline = expectTextline\n\n/**** allow/expect[ed]Function ****/\n\n  export const allowFunction = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsFunction, acceptNil, 'JavaScript function'\n  ), allowedFunction = allowFunction\n\n  export const expectFunction = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsFunction, rejectNil, 'JavaScript function'\n  ), expectedFunction = expectFunction\n\n/**** allow/expect[ed]AnonymousFunction ****/\n\n  export const allowAnonymousFunction = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsAnonymousFunction, acceptNil, 'anonymous JavaScript function'\n  ), allowedAnonymousFunction = allowAnonymousFunction\n\n  export const expectAnonymousFunction = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsAnonymousFunction, rejectNil, 'anonymous JavaScript function'\n  ), expectedAnonymousFunction = expectAnonymousFunction\n\n/**** allow/expect[ed]NamedFunction ****/\n\n  export const allowNamedFunction = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsNamedFunction, acceptNil, 'named JavaScript function'\n  ), allowedNamedFunction = allowNamedFunction\n\n  export const expectNamedFunction = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsNamedFunction, rejectNil, 'named JavaScript function'\n  ), expectedNamedFunction = expectNamedFunction\n\n/**** allow/expect[ed]NativeFunction ****/\n\n  export const allowNativeFunction = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsNativeFunction, acceptNil, 'native JavaScript function'\n  ), allowedNativeFunction = allowNativeFunction\n\n  export const expectNativeFunction = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsNativeFunction, rejectNil, 'native JavaScript function'\n  ), expectedNativeFunction = expectNativeFunction\n\n/**** allow/expect[ed]ScriptedFunction ****/\n\n  export const allowScriptedFunction = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsScriptedFunction, acceptNil, 'scripted JavaScript function'\n  ), allowedScriptedFunction = allowScriptedFunction\n\n  export const expectScriptedFunction = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsScriptedFunction, rejectNil, 'scripted JavaScript function'\n  ), expectedScriptedFunction = expectScriptedFunction\n\n/**** allow/expect[ed]Object ****/\n\n  export const allowObject = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsObject, acceptNil, 'JavaScript object'\n  ), allowedObject = allowObject\n\n  export const expectObject = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsObject, rejectNil, 'JavaScript object'\n  ), expectedObject = expectObject\n\n/**** allow/expect[ed]PlainObject ****/\n\n  export const allowPlainObject = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsPlainObject, acceptNil, '\"plain\" JavaScript object'\n  ), allowedPlainObject = allowPlainObject\n\n  export const expectPlainObject = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsPlainObject, rejectNil, '\"plain\" JavaScript object'\n  ), expectedPlainObject = expectPlainObject\n\n/**** allow/expect[ed]VanillaObject ****/\n\n  export const allowVanillaObject = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsVanillaObject, acceptNil, '\"vanilla\" JavaScript object'\n  ), allowedVanillaObject = allowVanillaObject\n\n  export const expectVanillaObject = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsVanillaObject, rejectNil, '\"vanilla\" JavaScript object'\n  ), expectedVanillaObject = expectVanillaObject\n\n/**** allow[ed]Array ****/\n\n  export function allowArray (Description:string, Argument:any):any[]|null|undefined {\n    return (Argument == null\n      ? Argument\n      : expectedArray(Description,Argument)\n    )\n  }\n  export const allowedArray = allowArray\n\n/**** expect[ed]Array ****/\n\n  export function expectArray (Description:string, Argument:any):any[] {\n    if (Argument == null) {\n      throwError(`MissingArgument: no ${escaped(Description)} given`)\n    }\n\n    if (ValueIsArray(Argument)) {\n      return Argument\n    } else {\n      throwError(\n        `InvalidArgument: the given ${escaped(Description)} is no JavaScript array`\n      )\n    }\n  }\n  export const expectedArray = expectArray\n\n/**** allow[ed]List ****/\n\n  export function allowList (\n    Description:string, Argument:any, Expectation?:string,\n    minLength?:number, maxLength?:number\n  ):any[]|null|undefined {\n    return (Argument == null\n      ? Argument\n      : expectedList(Description, Argument, Expectation, minLength,maxLength)\n    )\n  }\n  export const allowedList = allowList\n\n/**** expect[ed]List ****/\n\n  export function expectList (\n    Description:string, Argument:any, Expectation?:string,\n    minLength?:number, maxLength?:number\n  ):any[] {\n    if (Argument == null) {\n      throwError(`MissingArgument: no ${escaped(Description)} given`)\n    }\n\n    if (ValueIsList(Argument, minLength,maxLength)) {\n      return Argument\n    } else {\n      throwError(\n        `InvalidArgument: the given ${escaped(Description)} is ` + (\n          Expectation == null\n          ? 'either not a list or contains an invalid number of elements'\n          : 'no ' + escaped(Expectation)\n        )\n      )\n    }\n  }\n  export const expectedList = expectList\n\n/**** allow[ed]ListSatisfying ****/\n\n  export function allowListSatisfying (\n    Description:string, Argument:any, Validator:(Value:any) => boolean,\n    Expectation?:string, minLength?:number, maxLength?:number\n  ):any[]|null|undefined {\n    return (Argument == null\n      ? Argument\n      : expectedListSatisfying(\n          Description, Argument, Validator, Expectation, minLength,maxLength\n        )\n    )\n  }\n  export const allowedListSatisfying = allowListSatisfying\n\n/**** expect[ed]ListSatisfying ****/\n\n  export function expectListSatisfying (\n    Description:string, Argument:any, Validator:(Value:any) => boolean,\n    Expectation?:string, minLength?:number, maxLength?:number\n  ):any[] {\n    if (Argument == null) {\n      throwError(`MissingArgument: no ${escaped(Description)} given`)\n    }\n\n    if (ValueIsListSatisfying(Argument,Validator, minLength,maxLength)) {\n      return Argument\n    } else {\n      throwError(\n        `InvalidArgument: the given ${escaped(Description)} is ` + (\n          Expectation == null\n          ? 'either not a list or contains invalid elements'\n          : 'no ' + escaped(Expectation)\n        )\n      )\n    }\n  }\n  export const expectedListSatisfying = expectListSatisfying\n\n/**** allow[ed]InstanceOf ****/\n\n  export function allowInstanceOf (\n    Description:string, Argument:any, constructor:Function, Expectation:string\n  ):any|null|undefined {\n    return (Argument == null\n      ? Argument\n      : expectedInstanceOf(Description, Argument, constructor, Expectation)\n    )\n  }\n  export const allowedInstanceOf = allowInstanceOf\n\n/**** expect[ed]InstanceOf ****/\n\n  export function expectInstanceOf (\n    Description:string, Argument:any, constructor:Function, Expectation:string\n  ):any {\n    if (Argument == null) {\n      throwError(`MissingArgument: no ${escaped(Description)} given`)\n    }\n\n    if (! (Argument instanceof constructor)) {\n      throwError(\n        `InvalidArgument: the given ${escaped(Description)} is no ${escaped(Expectation)}`\n      )\n    }\n\n    return Argument\n  }\n  export const expectedInstanceOf = expectInstanceOf\n\n/**** allow[ed]ValueInheritingFrom ****/\n\n  export function allowValueInheritingFrom (\n    Description:string, Argument:any, prototype:any, Expectation:string\n  ):any|null|undefined {\n    return (Argument == null\n      ? Argument\n      : expectedValueInheritingFrom(Description, Argument, prototype, Expectation)\n    )\n  }\n  export const allowedValueInheritingFrom = allowValueInheritingFrom\n\n/**** expect[ed]ValueInheritingFrom ****/\n\n  export function expectValueInheritingFrom (\n    Description:string, Argument:any, prototype:any, Expectation:string\n  ):any {\n    if (Argument == null) {\n      throwError(`MissingArgument: no ${escaped(Description)} given`)\n    }\n\n    if (prototype.isPrototypeOf(Argument)) {\n      return Argument\n    } else {\n      throwError(\n        `InvalidArgument: the given ${escaped(Description)} is no ${escaped(Expectation)}`\n      )\n    }\n  }\n  export const expectedValueInheritingFrom = expectValueInheritingFrom\n\n/**** allow/expect[ed]Date ****/\n\n  export const allowDate = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsDate, acceptNil, 'JavaScript Date object'\n  ), allowedDate = allowDate\n\n  export const expectDate = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsDate, rejectNil, 'JavaScript Date object'\n  ), expectedDate = expectDate\n\n/**** allow/expect[ed]Error ****/\n\n  export const allowError = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsError, acceptNil, 'JavaScript Error object'\n  ), allowedError = allowError\n\n  export const expectError = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsError, rejectNil, 'JavaScript Error object'\n  ), expectedError = expectError\n\n/**** allow/expect[ed]Promise ****/\n\n  export const allowPromise = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsPromise, acceptNil, 'JavaScript Promise (or \"Thenable\") object'\n  ), allowedPromise = allowPromise\n\n  export const expectPromise = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsPromise, rejectNil, 'JavaScript Promise (or \"Thenable\") object'\n  ), expectedPromise = expectPromise\n\n/**** allow/expect[ed]RegExp ****/\n\n  export const allowRegExp = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsRegExp, acceptNil, 'JavaScript RegExp object'\n  ), allowedRegExp = allowRegExp\n\n  export const expectRegExp = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsRegExp, rejectNil, 'JavaScript RegExp object'\n  ), expectedRegExp = expectRegExp\n\n/**** allow[ed]OneOf ****/\n\n  export function allowOneOf (\n    Description:string, Argument:any, ValueList:any[]\n  ):any|null|undefined {\n    return (Argument == null\n      ? Argument\n      : expectedOneOf(Description, Argument, ValueList)\n    )\n  }\n  export const allowedOneOf = allowOneOf\n\n/**** expect[ed]OneOf ****/\n\n  export function expectOneOf (\n    Description:string, Argument:any, ValueList:any[]\n  ):any {\n    if (Argument == null) {\n      throwError(`MissingArgument: no ${escaped(Description)} given`)\n    }\n\n    if (ValueIsOneOf(Argument,ValueList)) {\n      return (                                         // unboxes any primitives\n        (Argument == null) || (typeof Argument.valueOf !== 'function')\n        ? Argument\n        : Argument.valueOf()\n      )\n    } else {\n      throwError(\n        `InvalidArgument: the given ${escaped(Description)} is not among the supported values`\n      )\n    }\n  }\n  export const expectedOneOf = expectOneOf\n\n/**** allow/expect[ed]Color ****/\n\n  export const allowColor = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsColor, acceptNil, 'valid CSS color specification'\n  ), allowedColor = allowColor\n\n  export const expectColor = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsColor, rejectNil, 'valid CSS color specification'\n  ), expectedColor = expectColor\n\n/**** allow/expect[ed]EMailAddress ****/\n\n  export const allowEMailAddress = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsEMailAddress, acceptNil, 'valid EMail address'\n  ), allowedEMailAddress = allowEMailAddress\n\n  export const expectEMailAddress = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsEMailAddress, rejectNil, 'valid EMail address'\n  ), expectedEMailAddress = expectEMailAddress\n\n/**** allow/expect[ed]URL ****/\n\n  export const allowURL = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsURL, acceptNil, 'valid URL'\n  ), allowedURL = allowURL\n\n  export const expectURL = /*#__PURE__*/ ValidatorForClassifier(\n    ValueIsURL, rejectNil, 'valid URL'\n  ), expectedURL = expectURL\n\n/**** escaped - escapes all control characters in a given string ****/\n\n  export function escaped (Text:string):string {\n    const EscapeSequencePattern = /\\\\x[0-9a-zA-Z]{2}|\\\\u[0-9a-zA-Z]{4}|\\\\[0bfnrtv'\"\\\\\\/]?/g\n    const CtrlCharCodePattern  = /[\\x00-\\x1f\\x7f-\\x9f]/g\n\n    return Text\n      .replace(EscapeSequencePattern, function (Match:string):string {\n        return (Match === '\\\\' ? '\\\\\\\\' : Match)\n      })\n      .replace(CtrlCharCodePattern, function (Match:string):string {\n        switch (Match) {\n          case '\\0':  return '\\\\0'\n          case '\\b':  return '\\\\b'\n          case '\\f':  return '\\\\f'\n          case '\\n':  return '\\\\n'\n          case '\\r':  return '\\\\r'\n          case '\\t':  return '\\\\t'\n          case '\\v':  return '\\\\v'\n          default: {\n            let HexCode = Match.charCodeAt(0).toString(16)\n            return '\\\\x' + '00'.slice(HexCode.length) + HexCode\n          }\n        }\n      })\n  }\n\n/**** unescaped - evaluates all escape sequences in a given string ****/\n\n  export function unescaped (Text:string):string {\n    const EscapeSequencePattern = /\\\\[0bfnrtv'\"\\\\\\/]|\\\\x[0-9a-zA-Z]{2}|\\\\u[0-9a-zA-Z]{4}/g\n\n    return Text\n      .replace(EscapeSequencePattern, function (Match:string):string {\n        switch (Match) {\n          case '\\\\0':  return '\\0'\n          case '\\\\b':  return '\\b'\n          case '\\\\f':  return '\\f'\n          case '\\\\n':  return '\\n'\n          case '\\\\r':  return '\\r'\n          case '\\\\t':  return '\\t'\n          case '\\\\v':  return '\\v'\n          case '\\\\\\'': return \"'\"\n          case '\\\\\"':  return '\"'\n          case '\\\\\\\\': return \"\\\\\"\n          default: {\n            let CharCode = parseInt(Match.slice(2),16)\n            return String.fromCharCode(CharCode)\n          }\n        }\n    })\n  }\n\n/**** quotable - makes a given string ready to be put in single/double quotes ****/\n\n  export function quotable (Text:string, Quote:'\"' | \"'\" = '\"'):string {\n    const EscSeqOrSglQuotePattern = /\\\\x[0-9a-zA-Z]{2}|\\\\u[0-9a-zA-Z]{4}|\\\\[0bfnrtv'\"\\\\\\/]?|'/g\n    const EscSeqOrDblQuotePattern = /\\\\x[0-9a-zA-Z]{2}|\\\\u[0-9a-zA-Z]{4}|\\\\[0bfnrtv'\"\\\\\\/]?|\"/g\n    const CtrlCharCodePattern     = /[\\x00-\\x1f\\x7f-\\x9f]/g\n\n    return Text\n      .replace(\n        Quote === \"'\" ? EscSeqOrSglQuotePattern : EscSeqOrDblQuotePattern,\n        function (Match:string):string {\n          switch (Match) {\n            case \"'\":  return \"\\\\'\"\n            case '\"':  return '\\\\\"'\n            case '\\\\': return '\\\\\\\\'\n            default:   return Match\n          }\n        }\n      )\n      .replace(CtrlCharCodePattern, function (Match:string):string {\n        switch (Match) {\n          case '\\0':  return '\\\\0'\n          case '\\b':  return '\\\\b'\n          case '\\f':  return '\\\\f'\n          case '\\n':  return '\\\\n'\n          case '\\r':  return '\\\\r'\n          case '\\t':  return '\\\\t'\n          case '\\v':  return '\\\\v'\n          default: {\n            let HexCode = Match.charCodeAt(0).toString(16)\n            return '\\\\x' + '00'.slice(HexCode.length) + HexCode\n          }\n        }\n      })\n  }\n\n/**** quoted ****/\n\n  export function quoted (Text:string, Quote:'\"' | \"'\" = '\"'):string {\n    return Quote + quotable(Text,Quote) + Quote\n  }\n\n/**** HTMLsafe ****/\n\n  export function HTMLsafe (Argument:string, EOLReplacement?:string):string {\n    EOLReplacement = (EOLReplacement || '').trim() || '<br/>'\n    return Argument.replace(\n      /[&<>\"'\\u0000-\\u001F\\u007F-\\u009F\\\\]/g, function (Match:string):string {\n        switch (Match) {\n          case '&':  return '&amp;'\n          case '<':  return '&lt;'\n          case '>':  return '&gt;'\n          case '\"':  return '&quot;'\n          case \"'\":  return '&apos;'\n          case '\\b': return '&#92;b'\n          case '\\f': return '&#92;f'\n          case '\\n': return EOLReplacement as string\n          case '\\r': return '&#92;r'\n          case '\\t': return '&#92;t'\n          case '\\v': return '&#92;v'\n          case '\\\\': return '&#92;'\n          default:   let Result = Match.charCodeAt(0).toString(16)\n                     return '&#x0000'.substring(3,7-Result.length) + Result + ';'\n        }\n      }\n    )\n  }\n\n/**** MarkDownSafe ****/\n\n  export function MarkDownSafe (Argument:string, EOLReplacement?:string):string {\n    return HTMLsafe(Argument, EOLReplacement).replace(/:/g,'&#58;')\n  }\n\n/**** ValuesDiffer ****/\n\n  export function ValuesDiffer (\n    thisValue:any, otherValue:any, Mode?:'by-value'|'by-reference'|undefined\n  ):boolean {\n    if (thisValue === otherValue) { return false }\n\n    let thisType = typeof thisValue\n    if (thisType !== typeof otherValue) { return true }\n\n    /**** ArraysDiffer ****/\n\n      function ArraysDiffer (\n        thisArray:any[], otherArray:any[], Mode:'by-value'|'by-reference'|undefined\n      ):boolean {\n        if (! Array.isArray(otherArray)) { return true }\n\n        if (thisArray.length !== otherArray.length) { return true }\n\n        for (let i = 0, l = thisArray.length; i < l; i++) {\n          if (ValuesDiffer(thisArray[i],otherArray[i],Mode)) { return true }\n        }\n\n        return false\n      }\n\n    /**** ObjectsDiffer ****/\n\n      function ObjectsDiffer (\n        thisObject:any, otherObject:any, Mode:'by-value'|'by-reference'|undefined\n      ):boolean {\n        if (Object.getPrototypeOf(thisObject) !== Object.getPrototypeOf(otherObject)) {\n          return true\n        }\n\n        for (let key in thisObject) {\n          if (! (key in otherObject)) { return true }\n        }\n\n        for (let key in otherObject) {\n          if (! (key in thisObject)) { return true }\n\n          if (ValuesDiffer(thisObject[key],otherObject[key],Mode)) {\n            return true\n          }\n        }\n\n        return false\n      }\n\n    switch (thisType) {\n      case 'undefined':\n      case 'boolean':\n      case 'string':\n      case 'function': return true   // most primitives are compared using \"===\"\n      case 'number':   return (\n                         (isNaN(thisValue) !== isNaN(otherValue)) ||\n                         (Math.abs(thisValue-otherValue) > Number.EPSILON)\n                       )\n      case 'object':\n        if (thisValue  == null) { return true }  // since \"other_value\" != null!\n        if (otherValue == null) { return true }   // since \"this_value\" != null!\n\n        if ((Mode === 'by-value') && (\n          (thisValue instanceof Boolean) ||\n          (thisValue instanceof Number) ||\n          (thisValue instanceof String)\n        )) {\n          return (thisValue.valueOf() !== otherValue.valueOf())\n        }\n\n        if (Array.isArray(thisValue)) {\n          return ArraysDiffer(thisValue,otherValue,Mode)\n        }\n\n        return (\n          Mode === 'by-reference'\n          ? true                           // because (thisValue !== otherValue)\n          : ObjectsDiffer(thisValue,otherValue,Mode)\n        )\n      default: return true                          // unsupported property type\n    }\n\n    return true\n  }\n\n/**** ValuesAreEqual ****/\n\n  export function ValuesAreEqual (\n    thisValue:any, otherValue:any, Mode?:'by-value'|'by-reference'|undefined\n  ):boolean {\n    return ! ValuesDiffer(thisValue,otherValue,Mode)\n  }\n\n/**** ObjectIsEmpty ****/\n\n  export function ObjectIsEmpty (Candidate:any):boolean {\n    expectObject('candidate',Candidate)\n    for (let Key in Candidate) {\n      if (Object_hasOwnProperty(Candidate,Key)) {\n        return false\n      }\n    }\n    return true\n  }\n\n/**** ObjectIsNotEmpty ****/\n\n  export function ObjectIsNotEmpty (Candidate:any):boolean {\n    return ! ObjectIsEmpty(Candidate)\n  }\n\n/**** StringIsEmpty ****/\n\n  export function StringIsEmpty (Candidate:string):boolean {\n    return /^\\s*$/.test(Candidate)\n  }\n\n/**** StringIsNotEmpty ****/\n\n  export function StringIsNotEmpty (Candidate:string):boolean {\n    return ! StringIsEmpty(Candidate)\n  }\n\n/**** constrained ****/\n\n  export function constrained (\n    Value:number, Minimum:number = -Infinity, Maximum:number = Infinity\n  ):number {\n    return Math.max(Minimum, Math.min(Value, Maximum))\n  }\n\n//------------------------------------------------------------------------------\n//--                             Color Utilities                              --\n//------------------------------------------------------------------------------\n\n// built-in color names (see http://www.w3.org/TR/SVG/types.html#ColorKeywords) ----\n\n  export const ColorSet = {\n           transparent:'rgba(0,0,0,0,0.0)',\n             aliceblue:'rgba(240,248,255,1.0)',         lightpink:'rgba(255,182,193,1.0)',\n          antiquewhite:'rgba(250,235,215,1.0)',       lightsalmon:'rgba(255,160,122,1.0)',\n                  aqua:'rgba(0,255,255,1.0)',       lightseagreen:'rgba(32,178,170,1.0)',\n            aquamarine:'rgba(127,255,212,1.0)',      lightskyblue:'rgba(135,206,250,1.0)',\n                 azure:'rgba(240,255,255,1.0)',    lightslategray:'rgba(119,136,153,1.0)',\n                 beige:'rgba(245,245,220,1.0)',    lightslategrey:'rgba(119,136,153,1.0)',\n                bisque:'rgba(255,228,196,1.0)',    lightsteelblue:'rgba(176,196,222,1.0)',\n                 black:'rgba(0,0,0,1.0)',             lightyellow:'rgba(255,255,224,1.0)',\n        blanchedalmond:'rgba(255,235,205,1.0)',              lime:'rgba(0,255,0,1.0)',\n                  blue:'rgba(0,0,255,1.0)',             limegreen:'rgba(50,205,50,1.0)',\n            blueviolet:'rgba(138,43,226,1.0)',              linen:'rgba(250,240,230,1.0)',\n                 brown:'rgba(165,42,42,1.0)',             magenta:'rgba(255,0,255,1.0)',\n             burlywood:'rgba(222,184,135,1.0)',            maroon:'rgba(128,0,0,1.0)',\n             cadetblue:'rgba(95,158,160,1.0)',   mediumaquamarine:'rgba(102,205,170,1.0)',\n            chartreuse:'rgba(127,255,0,1.0)',          mediumblue:'rgba(0,0,205,1.0)',\n             chocolate:'rgba(210,105,30,1.0)',       mediumorchid:'rgba(186,85,211,1.0)',\n                 coral:'rgba(255,127,80,1.0)',       mediumpurple:'rgba(147,112,219,1.0)',\n        cornflowerblue:'rgba(100,149,237,1.0)',    mediumseagreen:'rgba(60,179,113,1.0)',\n              cornsilk:'rgba(255,248,220,1.0)',   mediumslateblue:'rgba(123,104,238,1.0)',\n               crimson:'rgba(220,20,60,1.0)',   mediumspringgreen:'rgba(0,250,154,1.0)',\n                  cyan:'rgba(0,255,255,1.0)',     mediumturquoise:'rgba(72,209,204,1.0)',\n              darkblue:'rgba(0,0,139,1.0)',       mediumvioletred:'rgba(199,21,133,1.0)',\n              darkcyan:'rgba(0,139,139,1.0)',        midnightblue:'rgba(25,25,112,1.0)',\n         darkgoldenrod:'rgba(184,134,11,1.0)',          mintcream:'rgba(245,255,250,1.0)',\n              darkgray:'rgba(169,169,169,1.0)',         mistyrose:'rgba(255,228,225,1.0)',\n             darkgreen:'rgba(0,100,0,1.0)',              moccasin:'rgba(255,228,181,1.0)',\n              darkgrey:'rgba(169,169,169,1.0)',       navajowhite:'rgba(255,222,173,1.0)',\n             darkkhaki:'rgba(189,183,107,1.0)',              navy:'rgba(0,0,128,1.0)',\n           darkmagenta:'rgba(139,0,139,1.0)',             oldlace:'rgba(253,245,230,1.0)',\n        darkolivegreen:'rgba(85,107,47,1.0)',               olive:'rgba(128,128,0,1.0)',\n            darkorange:'rgba(255,140,0,1.0)',           olivedrab:'rgba(107,142,35,1.0)',\n            darkorchid:'rgba(153,50,204,1.0)',             orange:'rgba(255,165,0,1.0)',\n               darkred:'rgba(139,0,0,1.0)',             orangered:'rgba(255,69,0,1.0)',\n            darksalmon:'rgba(233,150,122,1.0)',            orchid:'rgba(218,112,214,1.0)',\n          darkseagreen:'rgba(143,188,143,1.0)',     palegoldenrod:'rgba(238,232,170,1.0)',\n         darkslateblue:'rgba(72,61,139,1.0)',           palegreen:'rgba(152,251,152,1.0)',\n         darkslategray:'rgba(47,79,79,1.0)',        paleturquoise:'rgba(175,238,238,1.0)',\n         darkslategrey:'rgba(47,79,79,1.0)',        palevioletred:'rgba(219,112,147,1.0)',\n         darkturquoise:'rgba(0,206,209,1.0)',          papayawhip:'rgba(255,239,213,1.0)',\n            darkviolet:'rgba(148,0,211,1.0)',           peachpuff:'rgba(255,218,185,1.0)',\n              deeppink:'rgba(255,20,147,1.0)',               peru:'rgba(205,133,63,1.0)',\n           deepskyblue:'rgba(0,191,255,1.0)',                pink:'rgba(255,192,203,1.0)',\n               dimgray:'rgba(105,105,105,1.0)',              plum:'rgba(221,160,221,1.0)',\n               dimgrey:'rgba(105,105,105,1.0)',        powderblue:'rgba(176,224,230,1.0)',\n            dodgerblue:'rgba(30,144,255,1.0)',             purple:'rgba(128,0,128,1.0)',\n             firebrick:'rgba(178,34,34,1.0)',                 red:'rgba(255,0,0,1.0)',\n           floralwhite:'rgba(255,250,240,1.0)',         rosybrown:'rgba(188,143,143,1.0)',\n           forestgreen:'rgba(34,139,34,1.0)',           royalblue:'rgba(65,105,225,1.0)',\n               fuchsia:'rgba(255,0,255,1.0)',         saddlebrown:'rgba(139,69,19,1.0)',\n             gainsboro:'rgba(220,220,220,1.0)',            salmon:'rgba(250,128,114,1.0)',\n            ghostwhite:'rgba(248,248,255,1.0)',        sandybrown:'rgba(244,164,96,1.0)',\n                  gold:'rgba(255,215,0,1.0)',            seagreen:'rgba(46,139,87,1.0)',\n             goldenrod:'rgba(218,165,32,1.0)',           seashell:'rgba(255,245,238,1.0)',\n                  gray:'rgba(128,128,128,1.0)',            sienna:'rgba(160,82,45,1.0)',\n                 green:'rgba(0,128,0,1.0)',                silver:'rgba(192,192,192,1.0)',\n           greenyellow:'rgba(173,255,47,1.0)',            skyblue:'rgba(135,206,235,1.0)',\n                  grey:'rgba(128,128,128,1.0)',         slateblue:'rgba(106,90,205,1.0)',\n              honeydew:'rgba(240,255,240,1.0)',         slategray:'rgba(112,128,144,1.0)',\n               hotpink:'rgba(255,105,180,1.0)',         slategrey:'rgba(112,128,144,1.0)',\n             indianred:'rgba(205,92,92,1.0)',                snow:'rgba(255,250,250,1.0)',\n                indigo:'rgba(75,0,130,1.0)',          springgreen:'rgba(0,255,127,1.0)',\n                 ivory:'rgba(255,255,240,1.0)',         steelblue:'rgba(70,130,180,1.0)',\n                 khaki:'rgba(240,230,140,1.0)',               tan:'rgba(210,180,140,1.0)',\n              lavender:'rgba(230,230,250,1.0)',              teal:'rgba(0,128,128,1.0)',\n         lavenderblush:'rgba(255,240,245,1.0)',           thistle:'rgba(216,191,216,1.0)',\n             lawngreen:'rgba(124,252,0,1.0)',              tomato:'rgba(255,99,71,1.0)',\n          lemonchiffon:'rgba(255,250,205,1.0)',         turquoise:'rgba(64,224,208,1.0)',\n             lightblue:'rgba(173,216,230,1.0)',            violet:'rgba(238,130,238,1.0)',\n            lightcoral:'rgba(240,128,128,1.0)',             wheat:'rgba(245,222,179,1.0)',\n             lightcyan:'rgba(224,255,255,1.0)',             white:'rgba(255,255,255,1.0)',\n  lightgoldenrodyellow:'rgba(250,250,210,1.0)',        whitesmoke:'rgba(245,245,245,1.0)',\n             lightgray:'rgba(211,211,211,1.0)',            yellow:'rgba(255,255,0,1.0)',\n            lightgreen:'rgba(144,238,144,1.0)',       yellowgreen:'rgba(154,205,50,1.0)',\n             lightgrey:'rgba(211,211,211,1.0)',\n  }\n\n/**** HexColor - converts a given color to #rrggbbaa ****/\n\n  export function HexColor (Color:string):string {\n    let lowerColor = Color.toLowerCase()\n    if (ColorSet.hasOwnProperty(lowerColor)) {\n// @ts-ignore TS dislikes indexing with literal keys\n      Color = ColorSet[lowerColor]\n    } // do not return here as color is now in RGBA format\n\n    if (/^#[a-fA-F0-9]{6}$/.test(Color)) {\n      return Color + 'FF'\n    }\n\n    if (/^#[a-fA-F0-9]{8}$/.test(Color)) {\n      return Color\n    }\n\n    const HexDigit = '0123456789ABCDEF'\n    function dec2hex (Value:number):string {\n      if (Value > 255) { Value = 255 }\n      return HexDigit[Math.trunc(Value / 16)] + HexDigit[Value % 16]\n    }\n\n    const RGBPattern = /^rgb\\(([0-9]+),\\s*([0-9]+),\\s*([0-9]+)\\)$/i // not perfect\n\n    let Match = RGBPattern.exec(Color)\n    if (Match != null) {\n      return ('#' +\n        dec2hex(parseInt(Match[1],10)) +\n        dec2hex(parseInt(Match[2],10)) +\n        dec2hex(parseInt(Match[3],10)) + 'FF'\n      )\n    }\n\n    const RGBAPattern = /^rgba\\(([(0-9]+),\\s*([0-9]+),\\s*([0-9]+),\\s*([01]?[.][0-9]+|[01])\\)$/i // not perfect\n\n    Match = RGBAPattern.exec(Color)\n    if (Match != null) {\n      return ('#' +\n        dec2hex(parseInt(Match[1],10)) +\n        dec2hex(parseInt(Match[2],10)) +\n        dec2hex(parseInt(Match[3],10)) +\n        dec2hex(parseFloat(Match[4]))\n      )\n    }\n\n    throwError('InvalidArgument: the given Value is not a valid CSS Color specification')\n  }\n\n/**** RGBAColor - converts a given color to RGBA(r,g,b,a) ****/\n\n  export function RGBAColor (Color:string):string {\n    let lowerColor = Color.toLowerCase()\n    if (ColorSet.hasOwnProperty(lowerColor)) {\n// @ts-ignore TS dislikes indexing with literal keys\n      return ColorSet[lowerColor]             // color is already in RGBA format\n    }\n\n    if (/^#[a-fA-F0-9]{6}$/.test(Color)) {\n      return ('rgba(' +\n        parseInt(Color.slice(1,3),16) + ',' +\n        parseInt(Color.slice(3,5),16) + ',' +\n        parseInt(Color.slice(5,7),16) + ', 1' +\n      ')')\n    }\n\n    if (/^#[a-fA-F0-9]{8}$/.test(Color)) {\n      return ('rgba(' +\n        parseInt(Color.slice(1,3),16) + ',' +\n        parseInt(Color.slice(3,5),16) + ',' +\n        parseInt(Color.slice(5,7),16) + ',' +\n        (parseInt(Color.slice(7),16)/255) +\n      ')')\n    }\n\n    const RGBPattern = /^rgb\\(([0-9]+),\\s*([0-9]+),\\s*([0-9]+)\\)$/i //not perfect\n\n    let Match = RGBPattern.exec(Color)\n    if (Match != null) {\n      return Color.slice(0,Color.length-1) + ',1)'\n    }\n\n    const RGBAPattern = /^rgba\\(([(0-9]+),\\s*([0-9]+),\\s*([0-9]+),\\s*([0]?[.][0-9]+|[01])\\)$/i // not perfect\n\n    Match = RGBAPattern.exec(Color)\n    if (Match != null) { return Color }\n\n    throwError('InvalidArgument: the given Value is not a valid CSS Color specification')\n  }\n\n/**** shortHexColor - converts a given color into #RRGGBB ****/\n\n  export function shortHexColor (Color:string):string {\n    return HexColor(Color).slice(0,7)\n  }\n", "//----------------------------------------------------------------------------//\n//                        Svelte Coordinate Conversion                        //\n//----------------------------------------------------------------------------//\n\n  type Position = { left:number, top:number }\n\n  function fromViewportTo (\n    System:'document'|'local', originalPosition:Position, Target?:Element\n  ):Position {\n    switch (true) {\n      case (originalPosition == null):\n        throw new Error('no \"Position\" given')\n      case (typeof originalPosition.left !== 'number') && ! (originalPosition.left as Number instanceof Number):\n      case (typeof originalPosition.top  !== 'number') && ! (originalPosition.top  as Number instanceof Number):\n        throw new Error('invalid \"Position\" given')\n    }\n\n    switch (System) {\n      case null: case undefined:\n        throw new Error('no coordinate system given')\n// @ts-ignore the following check is for non-TypeScript applications only\n      case 'viewport':\n        return { left:originalPosition.left, top:originalPosition.top }\n      case 'document':\n        return {\n          left:originalPosition.left + window.scrollX,\n          top:  originalPosition.top + window.scrollY\n        }\n      case 'local':\n        switch (true) {\n          case (Target == null):\n            throw new Error('no target element given')\n          case (Target instanceof Element):\n            let computedStyle = window.getComputedStyle(Target as Element)\n\n            let leftOffset = parseFloat(computedStyle.borderLeftWidth)\n            let topOffset  = parseFloat(computedStyle.borderTopWidth)\n\n            let TargetPositionInViewport = (Target as Element).getBoundingClientRect()\n            return {\n              left:originalPosition.left - TargetPositionInViewport.left - leftOffset,\n              top:  originalPosition.top - TargetPositionInViewport.top  - topOffset\n            }\n          default:\n            throw new Error('invalid target element given')\n        }\n      default:\n        throw new Error('invalid coordinate system given')\n    }\n  }\n\n  function fromDocumentTo (\n    System:'viewport'|'local', originalPosition:Position, Target?:Element\n  ):Position {\n    switch (true) {\n      case (originalPosition == null):\n        throw new Error('no \"Position\" given')\n      case (typeof originalPosition.left !== 'number') && ! (originalPosition.left as Number instanceof Number):\n      case (typeof originalPosition.top  !== 'number') && ! (originalPosition.top  as Number instanceof Number):\n        throw new Error('invalid \"Position\" given')\n    }\n\n    switch (System) {\n      case null: case undefined:\n        throw new Error('no coordinate system given')\n      case 'viewport':\n        return {\n          left:originalPosition.left - window.scrollX,\n          top:  originalPosition.top - window.scrollY\n        }\n// @ts-ignore the following check is for non-TypeScript applications only\n      case 'document':\n        return { left:originalPosition.left, top:originalPosition.top }\n      case 'local':\n        switch (true) {\n          case (Target == null):\n            throw new Error('no target element given')\n          case (Target instanceof Element):\n            let computedStyle = window.getComputedStyle(Target as Element)\n\n            let leftOffset = parseFloat(computedStyle.borderLeftWidth)\n            let topOffset  = parseFloat(computedStyle.borderTopWidth)\n\n            let TargetPositionInViewport = (Target as Element).getBoundingClientRect()\n            return {\n              left:originalPosition.left + window.scrollX - TargetPositionInViewport.left - leftOffset,\n              top:  originalPosition.top + window.scrollY - TargetPositionInViewport.top  - topOffset\n            }\n          default:\n            throw new Error('invalid target element given')\n        }\n      default:\n        throw new Error('invalid coordinate system given')\n    }\n  }\n\n  function fromLocalTo (\n    System:'viewport'|'document', originalPosition:Position, Source?:Element\n  ):Position {\n    switch (true) {\n      case (originalPosition == null):\n        throw new Error('no \"Position\" given')\n      case (typeof originalPosition.left !== 'number') && ! (originalPosition.left as Number instanceof Number):\n      case (typeof originalPosition.top  !== 'number') && ! (originalPosition.top  as Number instanceof Number):\n        throw new Error('invalid \"Position\" given')\n    }\n\n    let SourcePositionInViewport:Position, leftPosition:number, topPosition:number\n    switch (true) {\n      case (Source == null):\n        throw new Error('no source element given')\n      case (Source instanceof Element):\n        let computedStyle = window.getComputedStyle(Source as Element)\n\n        let leftOffset = parseFloat(computedStyle.borderLeftWidth)\n        let topOffset  = parseFloat(computedStyle.borderTopWidth)\n\n        SourcePositionInViewport = (Source as Element).getBoundingClientRect()\n        leftPosition = SourcePositionInViewport.left + leftOffset\n        topPosition  = SourcePositionInViewport.top  + topOffset\n        break\n      default:\n        throw new Error('invalid source element given')\n    }\n\n    switch (System) {\n      case null: case undefined:\n        throw new Error('no coordinate system given')\n      case 'viewport':\n        return {\n          left:originalPosition.left + leftPosition,\n          top:  originalPosition.top + topPosition\n        }\n      case 'document':\n        return {\n          left:originalPosition.left + leftPosition + window.scrollX,\n          top:  originalPosition.top + topPosition  + window.scrollY\n        }\n// @ts-ignore the following check is for non-TypeScript applications only\n      case 'local':\n        return { left:originalPosition.left, top:originalPosition.top }\n      default:\n        throw new Error('invalid coordinate system given')\n    }\n  }\n\n\n\n  export default {\n    fromViewportTo,\n    fromDocumentTo,\n    fromLocalTo\n  }\n", "//----------------------------------------------------------------------------//\n//                        Svelte Drag-and-Drop Actions                        //\n//----------------------------------------------------------------------------//\n\n  import {\n    global, throwError,\n    ValueIsNumber, ValueIsFiniteNumber, ValueIsString, ValueIsNonEmptyString,\n    ValueIsFunction, ValueIsPlainObject, ValueIsOneOf,\n    allowedFiniteNumber, allowedIntegerInRange, allowedOrdinal,\n    allowedString, allowedNonEmptyString,\n    allowPlainObject, allowedPlainObject,\n    allowListSatisfying, allowedFunction,\n    ObjectIsNotEmpty, quoted, constrained\n  } from 'javascript-interface-library'\n\n  import Conversion from 'svelte-coordinate-conversion'\n\n/**** never ever trust module loading if you REALLY need a singleton! ****/\n// finding multiple existing singletons if you actually trust them is so hard!\n\n  type ContextType = extendedDragAndDropSupport & SupportForHoldingAndPanning\n  const Context:ContextType = (            // make this package a REAL singleton\n    '__DragAndDropActions' in global\n    ? global.__DragAndDropActions\n    : global.__DragAndDropActions = {}\n  )\n\n//-------------------------------------------------------------------------------\n//--             use:asDraggable={options} - \"drag\" without \"drop\"             --\n//-------------------------------------------------------------------------------\n\n  export type PositionReference = (\n    'parent' | 'body' | string | HTMLElement | SVGElement // | MathMLElement\n  )\n\n  export type Position = { x:number, y:number }\n\n  export type DragDummy = (\n    string | HTMLElement | SVGElement | // MathMLElement |\n    ((DraggableExtras:any, Element:HTMLElement|SVGElement) => HTMLElement|SVGElement) |\n    'standard' | 'none'\n  ) | null | undefined\n\n  type DraggableOptions = {\n    Extras?:any,\n    relativeTo?:PositionReference, onlyFrom?:string, neverFrom?:string,\n    Dummy?:DragDummy, DummyOffsetX?:number, DummyOffsetY?:number,\n    minX?:number, minY?:number, maxX?:number, maxY?:number,\n    Pannable?:string|HTMLElement|SVGElement,\n    PanSensorWidth?:number, PanSensorHeight?:number, PanSpeed?:number,\n    onDragStart?:Position | ((DraggableExtras:any) => Position),\n    onDragMove?: (x:number,y:number, dx:number,dy:number, DraggableExtras:any) => void,\n    onDragEnd?:  (x:number,y:number, dx:number,dy:number, DraggableExtras:any) => void,\n  }\n\n/**** parsedDraggableOptions ****/\n\n  function parsedDraggableOptions (Options:any):DraggableOptions {\n    Options = allowedPlainObject('drag options',Options) || {}\n\n    let Extras:any, relativeTo:PositionReference\n    let onlyFrom:string|undefined, neverFrom:string|undefined\n    let Dummy:DragDummy, DummyOffsetX:number, DummyOffsetY:number\n    let minX:number, minY:number, maxX:number, maxY:number\n    let Pannable:string|HTMLElement|SVGElement|undefined\n    let PanSensorWidth:number, PanSensorHeight:number, PanSpeed:number\n    let onDragStart:Function, onDragMove:Function, onDragEnd:Function, onDragCancel:Function\n\n    Extras = Options.Extras\n\n    switch (true) {\n      case (Options.relativeTo == null):\n        relativeTo = 'parent'; break\n      case (Options.relativeTo === 'parent'):\n      case (Options.relativeTo === 'body'):\n      case ValueIsNonEmptyString(Options.relativeTo):\n      case (Options.relativeTo instanceof HTMLElement):\n      case (Options.relativeTo instanceof SVGElement):\n//    case (Options.relativeTo instanceof MathMLElement):\n        relativeTo = Options.relativeTo as PositionReference; break\n      default: throwError(\n        'InvalidArgument: invalid position reference given'\n      )\n    }\n\n    onlyFrom  = allowedNonEmptyString ('\"onlyFrom\" CSS selector',Options.onlyFrom)\n    neverFrom = allowedNonEmptyString('\"neverFrom\" CSS selector',Options.neverFrom)\n\n    switch (true) {\n      case (Options.Dummy == null):\n        Dummy = undefined; break\n      case (Options.Dummy === 'standard'):\n      case (Options.Dummy === 'none'):\n      case ValueIsNonEmptyString(Options.Dummy):\n      case (Options.Dummy instanceof HTMLElement):\n      case (Options.Dummy instanceof SVGElement):\n//    case (Options.Dummy instanceof MathMLElement):\n      case ValueIsFunction(Options.Dummy):\n        Dummy = Options.Dummy as DragDummy; break\n      default: throwError(\n        'InvalidArgument: invalid drag dummy specification given'\n      )\n    }\n\n    DummyOffsetX = allowedFiniteNumber('dummy x offset',Options.DummyOffsetX)\n    DummyOffsetY = allowedFiniteNumber('dummy y offset',Options.DummyOffsetY)\n\n    minX = allowedFiniteNumber('min. x position',Options.minX)\n      if (minX == null) { minX = -Infinity }\n    minY = allowedFiniteNumber('min. y position',Options.minY)\n      if (minY == null) { minY = -Infinity }\n    maxX = allowedFiniteNumber('max. x position',Options.maxX)\n      if (maxX == null) { maxX = Infinity }\n    maxY = allowedFiniteNumber('max. y position',Options.maxY)\n      if (maxY == null) { maxY = Infinity }\n\n    switch (true) {\n      case (Options.Pannable == null):\n        Pannable = undefined; break\n      case ValueIsNonEmptyString(Options.Pannable):\n      case (Options.Pannable instanceof HTMLElement):\n      case (Options.Pannable instanceof SVGElement):\n//    case (Options.Pannable instanceof MathMLElement):\n        Pannable = Options.Pannable; break\n      default: throwError(\n        'InvalidArgument: invalid \"Pannable\" specification given'\n      )\n    }\n\n    PanSensorWidth  = allowedOrdinal ('panning sensor width',Options.PanSensorWidth)\n      if (PanSensorWidth  == null) { PanSensorWidth = 20 }\n    PanSensorHeight = allowedOrdinal('panning sensor height',Options.PanSensorHeight)\n      if (PanSensorHeight == null) { PanSensorHeight = 20 }\n    PanSpeed        = allowedOrdinal        ('panning speed',Options.PanSpeed)\n      if (PanSpeed == null) { PanSpeed = 10 }\n\n    if (ValueIsPosition(Options.onDragStart)) {\n      let { x,y } = Options.onDragStart as Position\n      onDragStart = () => ({x,y})\n    } else {\n      onDragStart = allowedFunction('\"onDragStart\" handler', Options.onDragStart)\n    }\n\n    onDragMove = allowedFunction('\"onDragMove\" handler', Options.onDragMove)\n    onDragEnd  = allowedFunction('\"onDragEnd\" handler',  Options.onDragEnd)\n\n    return {\n      Extras, relativeTo, onlyFrom,neverFrom, Dummy, DummyOffsetX,DummyOffsetY,\n      minX,minY, maxX,maxY,\n      Pannable, PanSensorWidth,PanSensorHeight, PanSpeed,\n// @ts-ignore we cannot validate given functions any further\n      onDragStart, onDragMove, onDragEnd, onDragCancel\n    }\n  }\n\n/**** use:asDraggable={options} ****/\n\n  export function asDraggable (\n    Element:HTMLElement|SVGElement, Options:DraggableOptions\n  ) {\n    let isDragged:boolean\n    let currentDraggableOptions:DraggableOptions\n\n    let PositionReference:Element         // element with user coordinate system\n    let ReferenceDeltaX:number, ReferenceDeltaY:number  // mouse -> user coord.s\n    let PositioningWasDelayed:boolean // workaround for prob. with \"drag\" events\n    let DragImage:Element | undefined\n    let initialPosition:Position                    // given in user coordinates\n    let lastPosition:   Position                                         // dto.\n\n    isDragged = false\n\n    currentDraggableOptions = parsedDraggableOptions(Options)\n\n  /**** startDragging ****/\n\n    function startDragging (originalEvent:DragEvent) {\n      let Options = currentDraggableOptions\n\n      if (fromForbiddenElement(Element,Options,originalEvent)) {\n        originalEvent.stopPropagation()\n        originalEvent.preventDefault()\n        return false\n      }\n\n      PositionReference = PositionReferenceFor(Element,Options)\n\n      let relativePosition = Conversion.fromDocumentTo(\n        'local', { left:originalEvent.pageX, top:originalEvent.pageY }, PositionReference\n      )                                         // relative to reference element\n\n      ReferenceDeltaX = ReferenceDeltaY = 0; initialPosition = { x:0,y:0 }\n      if (Options.onDragStart == null) {\n        initialPosition = { x:0,y:0 }               // given in user coordinates\n      } else {\n        try {\n          let StartPosition = (Options.onDragStart as Function)(Options.Extras)\n          if (ValueIsPlainObject(StartPosition)) {\n            let x = allowedFiniteNumber('x start position',StartPosition.x)\n            let y = allowedFiniteNumber('y start position',StartPosition.y)\n\n            ReferenceDeltaX = x - relativePosition.left\n            ReferenceDeltaY = y - relativePosition.top\n\n            x = constrained(x, Options.minX,Options.maxX)\n            y = constrained(y, Options.minY,Options.maxY)\n\n            initialPosition = { x,y }               // given in user coordinates\n          }\n        } catch (Signal) {\n          console.error('\"onDragStart\" handler failed',Signal)\n        }\n      }\n\n      lastPosition = initialPosition\n\n      PositioningWasDelayed = false                    // initializes workaround\n\n      if (Options.Dummy == null) {\n        Options.Dummy = 'none'      // this is the default for \"use.asDraggable\"\n      }\n\n      DragImage = DragImageFor(Element,Options)\n      if ((DragImage != null) && (originalEvent.dataTransfer != null)) {\n        let OffsetX = Options.DummyOffsetX as number\n        let OffsetY = Options.DummyOffsetY as number\n\n        if ((OffsetX == null) || (OffsetY == null)) {\n          let PositionInDraggable = Conversion.fromDocumentTo(\n            'local', { left:originalEvent.pageX, top:originalEvent.pageY }, Element\n          )\n\n          if (OffsetX == null) { OffsetX = PositionInDraggable.left }\n          if (OffsetY == null) { OffsetY = PositionInDraggable.top }\n        }\n\n        switch (true) {\n          case (Options.Dummy === 'none'):\n            originalEvent.dataTransfer.setDragImage(DragImage,0,0)\n            setTimeout(() => { // remove element after browser took its snapshot\n              document.body.removeChild(DragImage as HTMLElement)\n            },0)\n            break\n          case ValueIsString(Options.Dummy):\n            originalEvent.dataTransfer.setDragImage(DragImage, OffsetX,OffsetY)\n            setTimeout(() => { // remove element after browser took its snapshot\n              document.body.removeChild(\n                (DragImage as HTMLElement).parentElement as HTMLElement\n              )\n            },0)\n            break\n          default:\n            originalEvent.dataTransfer.setDragImage(DragImage, OffsetX,OffsetY)\n        }\n      }\n\n      if (originalEvent.dataTransfer != null) {\n        originalEvent.dataTransfer.effectAllowed = 'none'\n      }\n\n      isDragged = true\n      setTimeout(() => Element.classList.add('dragged'), 0)\n\n      originalEvent.stopPropagation()\n    }\n\n  /**** continueDragging ****/\n\n    function continueDragging (originalEvent:DragEvent) {\n      if (! isDragged) { return false }\n\n      let Options = currentDraggableOptions\n\n      if (\n        (originalEvent.screenX === 0) && (originalEvent.screenY === 0) &&\n        ! PositioningWasDelayed\n      ) {\n        PositioningWasDelayed = true // last \"drag\" event contains wrong coord.s\n      } else {\n        PositioningWasDelayed = false\n\n        performPanningFor(\n          'draggable',\n          Element, Options, originalEvent.pageX,originalEvent.pageY\n        )\n\n        let relativePosition = Conversion.fromDocumentTo(\n          'local', { left:originalEvent.pageX, top:originalEvent.pageY }, PositionReference\n        )                                       // relative to reference element\n\n        let x  = relativePosition.left + ReferenceDeltaX  // in user coordinates\n        let y  = relativePosition.top  + ReferenceDeltaY\n\n        x = constrained(x, Options.minX,Options.maxX)\n        y = constrained(y, Options.minY,Options.maxY)\n\n        let dx = x - lastPosition.x         // calculated AFTER constraining x,y\n        let dy = y - lastPosition.y                                      // dto.\n\n        lastPosition = { x,y }\n\n        invokeHandler('onDragMove', Options, x,y, dx,dy, Options.Extras)\n      }\n\n      originalEvent.stopPropagation()\n    }\n\n  /**** finishDragging ****/\n\n    function finishDragging (originalEvent:DragEvent) {\n      if (! isDragged) { return false }\n\n//    continueDragging(originalEvent)           // NO! positions might be wrong!\n\n      let Options = currentDraggableOptions\n\n      if (Options.onDragEnd != null) {\n        let x = constrained(lastPosition.x, Options.minX,Options.maxX)\n        let y = constrained(lastPosition.y, Options.minY,Options.maxY)\n\n        let dx = x - lastPosition.x\n        let dy = y - lastPosition.y\n\n        invokeHandler('onDragEnd', Options, x,y, dx,dy, Options.Extras)\n      }\n\n      isDragged = false\n      Element.classList.remove('dragged')\n\n      originalEvent.stopPropagation()\n    }\n\n  /**** updateDraggableOptions ****/\n\n    function updateDraggableOptions (Options:any):void {\n      Options = parsedDraggableOptions(Options)\n\n      if (\n        (currentDraggableOptions.Extras == null) && (Options.Extras != null)\n      ) {\n        currentDraggableOptions.Extras = Options.Extras\n      }           // Extras may be set with delay, but remain constant afterwards\n\n      currentDraggableOptions.Dummy = (\n        Options.Dummy || currentDraggableOptions.Dummy\n      )\n\n      currentDraggableOptions.minX = Options.minX\n      currentDraggableOptions.minY = Options.minY\n      currentDraggableOptions.maxX = Options.maxX\n      currentDraggableOptions.maxY = Options.maxY\n\n      currentDraggableOptions.Pannable        = Options.Pannable\n      currentDraggableOptions.PanSensorWidth  = Options.PanSensorWidth\n      currentDraggableOptions.PanSensorHeight = Options.PanSensorHeight\n      currentDraggableOptions.PanSpeed        = Options.PanSpeed\n\n      currentDraggableOptions.onDragStart = (\n        Options.onDragStart || currentDraggableOptions.onDragStart\n      )           // may be used to update initial position for subsequent drags\n    }\n\n    Element.setAttribute('draggable','true')\n\n// @ts-ignore we know that the passed event is a DragEvent\n    Element.addEventListener('dragstart', startDragging)\n// @ts-ignore we know that the passed event is a DragEvent\n    Element.addEventListener('drag',      continueDragging)\n// @ts-ignore we know that the passed event is a DragEvent\n    Element.addEventListener('dragend',   finishDragging)\n\n    return { update:updateDraggableOptions }\n  }\n\n/**** fromForbiddenElement ****/\n\n  function fromForbiddenElement (\n    Element:HTMLElement|SVGElement, Options:DraggableOptions,\n    originalEvent:DragEvent\n  ):boolean {\n    if ((Options.onlyFrom != null) || (Options.neverFrom != null)) {\n      let x = originalEvent.clientX\n      let y = originalEvent.clientY\n\n      let touchedElement = document.elementFromPoint(x,y) as HTMLElement\n\n//    elementFromPoint considers elements with \"pointer-events\" <> \"none\" only\n//    but sometimes, \"pointer-events:none\" is needed for proper operation\n\n      touchedElement = innerElementOf(touchedElement, x,y)\n\n      if (Options.onlyFrom != null) {\n        let fromElement = touchedElement.closest(Options.onlyFrom as string)\n        if ((Element !== fromElement) && ! Element.contains(fromElement)) {\n          return true\n        }\n      }\n\n      if (Options.neverFrom != null) {\n        let fromElement = touchedElement.closest(Options.neverFrom as string)\n        if ((Element === fromElement) || Element.contains(fromElement)) {\n          return true\n        }\n      }\n    }\n\n    return false\n  }\n\n/**** innerElementOf ****/\n\n  function innerElementOf (Candidate:HTMLElement, x:number,y:number):HTMLElement {\n    let innerElements = Candidate.children\n    for (let i = 0, l = innerElements.length; i < l; i++) {\n      let innerElement = innerElements[i] as HTMLElement\n\n      let Position = Conversion.fromLocalTo(\n        'viewport', { left:0, top:0 }, innerElement\n      )\n      if ((x < Position.left) || (y < Position.top)) { continue }\n\n      if (x > Position.left+innerElement.offsetWidth-1) { continue }\n      if (y > Position.top+innerElement.offsetHeight-1) { continue }\n\n      return innerElementOf(innerElement, x,y)\n    }\n\n    return Candidate               // this is the innermost element at (x,y)\n  }\n\n/**** extended Drag-and-Drop Support ****/\n\n  type extendedDragAndDropSupport = {\n    currentDroppableExtras:any,        // extras for currently dragged droppable\n    currentDropZoneExtras:any,         // extras for currently hovered drop zone\n    currentDropZoneElement:Element|undefined,                 // dto. as Element\n\n    DroppableWasDropped:boolean,        // indicates a successful drop operation\n    currentDropZonePosition:Position|undefined, // position relative to DropZone\n    currentDropOperation:DropOperation|undefined,       // actual drop operation\n    currentTypeTransferred:string|undefined,  // actual type of transferred data\n    currentDataTransferred:any,                       // actual data transferred\n  }\n\n/**** Support for Holding and Panning ****/\n\n  type SupportForHoldingAndPanning = {\n    HoldPosition?:Position,               // current position to compare against\n    HoldTimer?:any,\n    HoldWasTriggeredForElement?:HTMLElement | SVGElement,\n\n    DropZonePanning?:boolean\n  }                                           // because we trigger it once only\n\n//-------------------------------------------------------------------------------\n//--               use:asDroppable={options} - \"drag\" and \"drop\"               --\n//-------------------------------------------------------------------------------\n\n  export const DropOperations = [ 'copy', 'move', 'link' ]\n  export type  DropOperation  = typeof DropOperations[number]\n\n  export type DataOfferSet = { [Type:string]:string }\n\n  type DroppableOptions = DraggableOptions & {\n    Operations?:string,// consisting of 'copy', 'move', 'link' (blank-separated)\n    DataToOffer?:DataOfferSet,\n    onDropZoneEnter?: (x:number,y:number, DropZoneExtras:any, DroppableExtras:any) => void,\n    onDropZoneHover?: (x:number,y:number, DropZoneExtras:any, DroppableExtras:any) => void,\n    onDropZoneLeave?: (DropZoneExtras:any, DroppableExtras:any) => void,\n    onDropped?:       (x:number,y:number, Operation:DropOperation,\n                        TypeTransferred:string, DataTransferred:any,\n                        DropZoneExtras:any, DroppableExtras:any) => void,\n  }\n\n/**** parsedDroppableOptions ****/\n\n  function parsedDroppableOptions (Options:any):DroppableOptions {\n    Options = allowedPlainObject('drop options',Options) || {}\n\n    let Operations:string, DataToOffer:DataOfferSet\n    let onDropZoneEnter:Function, onDropZoneHover:Function, onDropZoneLeave:Function\n    let onDropped:Function\n\n    Operations  = parsedOperations('list of allowed operations',Options.Operations,'copy')\n    DataToOffer = Object.assign(\n      {}, allowedPlainObject('data to be offered',Options.DataToOffer)\n    )\n    if ('none' in DataToOffer) throwError(\n      'InvalidArgument: \"none\" is not a valid data type'\n    )\n\n    onDropZoneEnter = allowedFunction('\"onDropZoneEnter\" handler',Options.onDropZoneEnter)\n    onDropZoneHover = allowedFunction('\"onDropZoneHover\" handler',Options.onDropZoneHover)\n    onDropZoneLeave = allowedFunction('\"onDropZoneLeave\" handler',Options.onDropZoneLeave)\n    onDropped       = allowedFunction('\"onDropped\" handler',      Options.onDropped)\n\n    return {\n      Operations, DataToOffer,\n// @ts-ignore we cannot validate given functions any further\n      onDropZoneEnter, onDropZoneHover, onDropZoneLeave, onDropped\n    }\n  }\n\n/**** use:asDroppable={options} ****/\n\n  export function asDroppable (\n    Element:HTMLElement|SVGElement, Options:DroppableOptions\n  ) {\n    let isDragged:boolean\n    let currentDraggableOptions:DraggableOptions\n    let currentDroppableOptions:DroppableOptions\n\n    let PositionReference:Element         // element with user coordinate system\n    let ReferenceDeltaX:number, ReferenceDeltaY:number  // mouse -> user coord.s\n    let PositioningWasDelayed:boolean // workaround for prob. with \"drag\" events\n    let DragImage:Element | undefined\n    let initialPosition:Position                    // given in user coordinates\n    let lastPosition:   Position                                         // dto.\n\n    let lastDropZoneElement:HTMLElement|SVGElement|undefined\n    let lastDropZoneExtras:any\n\n    isDragged = false\n\n    currentDraggableOptions = parsedDraggableOptions(Options)\n    currentDroppableOptions = parsedDroppableOptions(Options)\n\n  /**** startDragging ****/\n\n    function startDragging (originalEvent:DragEvent) {\n      let Options = Object.assign(\n        {}, currentDraggableOptions, currentDroppableOptions\n      )\n\n      if (fromForbiddenElement(Element,Options,originalEvent)) {\n        originalEvent.stopPropagation()\n        originalEvent.preventDefault()\n        return false\n      }\n\n      PositionReference = PositionReferenceFor(Element,Options)\n\n      let relativePosition = Conversion.fromDocumentTo(\n        'local', { left:originalEvent.pageX, top:originalEvent.pageY }, PositionReference\n      )                                         // relative to reference element\n\n      ReferenceDeltaX = ReferenceDeltaY = 0; initialPosition = { x:0,y:0 }\n      if (Options.onDragStart == null) {\n        initialPosition = { x:0,y:0 }               // given in user coordinates\n      } else {\n        try {\n          let StartPosition = (Options.onDragStart as Function)(Options.Extras)\n          if (ValueIsPlainObject(StartPosition)) {\n            let x = allowedFiniteNumber('x start position',StartPosition.x)\n            let y = allowedFiniteNumber('y start position',StartPosition.y)\n\n            ReferenceDeltaX = x - relativePosition.left\n            ReferenceDeltaY = y - relativePosition.top\n\n            x = constrained(x, Options.minX,Options.maxX)\n            y = constrained(y, Options.minY,Options.maxY)\n\n            initialPosition = { x,y }               // given in user coordinates\n          }\n        } catch (Signal) {\n          console.error('\"onDragStart\" handler failed',Signal)\n        }\n      }\n\n      lastPosition        = initialPosition\n      lastDropZoneElement = undefined\n      lastDropZoneExtras  = undefined\n\n      PositioningWasDelayed = false                    // initializes workaround\n\n      if (Options.Dummy == null) {\n        Options.Dummy = 'standard'  // this is the default for \"use.asDroppable\"\n      }\n\n      DragImage = DragImageFor(Element,Options)\n      if ((DragImage != null) && (originalEvent.dataTransfer != null)) {\n        let OffsetX = Options.DummyOffsetX as number\n        let OffsetY = Options.DummyOffsetY as number\n\n        if ((OffsetX == null) || (OffsetY == null)) {\n          let PositionInDraggable = Conversion.fromDocumentTo(\n            'local', { left:originalEvent.pageX, top:originalEvent.pageY }, Element\n          )\n\n          if (OffsetX == null) { OffsetX = PositionInDraggable.left }\n          if (OffsetY == null) { OffsetY = PositionInDraggable.top }\n        }\n\n        switch (true) {\n          case (Options.Dummy === 'none'):\n            originalEvent.dataTransfer.setDragImage(DragImage,0,0)\n            setTimeout(() => { // remove element after browser took its snapshot\n              document.body.removeChild(DragImage as HTMLElement)\n            },0)\n            break\n          case ValueIsString(Options.Dummy):\n            originalEvent.dataTransfer.setDragImage(DragImage, OffsetX,OffsetY)\n            setTimeout(() => { // remove element after browser took its snapshot\n              document.body.removeChild(\n                (DragImage as HTMLElement).parentElement as HTMLElement\n              )\n            },0)\n            break\n          default:\n            originalEvent.dataTransfer.setDragImage(DragImage, OffsetX,OffsetY)\n        }\n      }\n\n      if (originalEvent.dataTransfer != null) {\n        let allowedEffects = allowedEffectsFrom(Options.Operations as string)\n        originalEvent.dataTransfer.effectAllowed = allowedEffects\n\n        if (ObjectIsNotEmpty(Options.DataToOffer)) {\n          for (let Type in Options.DataToOffer) {\n            if (Options.DataToOffer.hasOwnProperty(Type)) {\n              originalEvent.dataTransfer.setData(\n                Type, Options.DataToOffer[Type]\n              )\n            }\n          }\n        }\n      }\n\n      Context.currentDroppableExtras  = Options.Extras\n      Context.currentDropZoneExtras   = undefined\n      Context.currentDropZonePosition = undefined\n      Context.currentDropZoneElement  = undefined\n\n      Context.DroppableWasDropped     = false\n      Context.currentDropOperation    = undefined\n      Context.currentTypeTransferred  = undefined\n      Context.currentDataTransferred  = undefined\n\n      isDragged = true\n      setTimeout(() => Element.classList.add('dragged'), 0)\n\n      originalEvent.stopPropagation()\n    }\n\n  /**** continueDragging ****/\n\n    function continueDragging (originalEvent:DragEvent) {\n      if (! isDragged) { return false }\n\n      let Options = Object.assign(\n        {}, currentDraggableOptions, currentDroppableOptions\n      )\n\n      if (\n        (originalEvent.screenX === 0) && (originalEvent.screenY === 0) &&\n        ! PositioningWasDelayed\n      ) {\n        PositioningWasDelayed = true // last \"drag\" event contains wrong coord.s\n      } else {\n        PositioningWasDelayed = false\n\n        performPanningFor(\n          'draggable',\n          Element, Options, originalEvent.pageX,originalEvent.pageY\n        )\n\n        let relativePosition = Conversion.fromDocumentTo(\n          'local', { left:originalEvent.pageX, top:originalEvent.pageY }, PositionReference\n        )                                       // relative to reference element\n\n        let x  = relativePosition.left + ReferenceDeltaX  // in user coordinates\n        let y  = relativePosition.top  + ReferenceDeltaY\n\n        x = constrained(x, Options.minX,Options.maxX)\n        y = constrained(y, Options.minY,Options.maxY)\n\n        let dx = x - lastPosition.x         // calculated AFTER constraining x,y\n        let dy = y - lastPosition.y                                      // dto.\n\n        lastPosition = { x,y }\n\n        invokeHandler('onDragMove', Options, x,y, dx,dy, Options.Extras)\n      }\n\n      if (Context.currentDropZoneElement === lastDropZoneElement) {\n        if (Context.currentDropZoneElement != null) {\n          invokeHandler(\n            'onDropZoneHover', Options,\n            (Context.currentDropZonePosition as Position).x,(Context.currentDropZonePosition as Position).y,\n            Context.currentDropZoneExtras, Options.Extras\n          )\n        }\n      } else {\n        if (Context.currentDropZoneElement == null) {\n          Element.classList.remove('droppable')\n          invokeHandler('onDropZoneLeave', Options, lastDropZoneExtras, Options.Extras)\n        } else {\n          Element.classList.add('droppable')\n          invokeHandler(\n            'onDropZoneEnter', Options,\n            (Context.currentDropZonePosition as Position).x,(Context.currentDropZonePosition as Position).y,\n            lastDropZoneExtras, Options.Extras\n          )\n        }\n\n        lastDropZoneElement = Context.currentDropZoneElement as HTMLElement\n        lastDropZoneExtras  = Context.currentDropZoneExtras\n      }\n\n      originalEvent.stopPropagation()\n    }\n\n  /**** finishDragging ****/\n\n    function finishDragging (originalEvent:DragEvent) {\n      if (! isDragged) { return false }\n\n//    continueDragging(originalEvent)           // NO! positions might be wrong!\n\n      let Options = Object.assign(\n        {}, currentDraggableOptions, currentDroppableOptions\n      )\n\n      if (Context.DroppableWasDropped) {\n        invokeHandler(\n          'onDropped', Options,\n          (Context.currentDropZonePosition as Position).x,(Context.currentDropZonePosition as Position).y,\n          Context.currentDropOperation, Context.currentTypeTransferred, Context.currentDataTransferred,\n          Context.currentDropZoneExtras, Options.Extras\n        )\n\n        Context.currentDropZoneExtras   = undefined\n        Context.currentDropZonePosition = undefined\n        Context.currentDropZoneElement  = undefined\n\n        Context.DroppableWasDropped     = false\n        Context.currentDropOperation    = undefined\n        Context.currentTypeTransferred  = undefined\n        Context.currentDataTransferred  = undefined\n      }\n\n      if (Options.onDragEnd != null) {\n        let x = constrained(lastPosition.x, Options.minX,Options.maxX)\n        let y = constrained(lastPosition.y, Options.minY,Options.maxY)\n\n        let dx = x - lastPosition.x\n        let dy = y - lastPosition.y\n\n        invokeHandler('onDragEnd', Options, x,y, dx,dy, Options.Extras)\n      }\n\n      Context.currentDroppableExtras = undefined\n\n      isDragged = false\n      Element.classList.remove('dragged','droppable')\n\n      originalEvent.stopPropagation()\n    }\n\n  /**** updateDraggableOptions ****/\n\n    function updateDraggableOptions (Options:any):void {\n      Options = parsedDraggableOptions(Options)\n\n      if (\n        (currentDraggableOptions.Extras == null) && (Options.Extras != null)\n      ) {\n        currentDraggableOptions.Extras = Options.Extras\n      }           // Extras may be set with delay, but remain constant afterwards\n\n      currentDraggableOptions.Dummy = (\n        Options.Dummy || currentDraggableOptions.Dummy\n      )\n\n      currentDraggableOptions.minX = Options.minX\n      currentDraggableOptions.minY = Options.minY\n      currentDraggableOptions.maxX = Options.maxX\n      currentDraggableOptions.maxY = Options.maxY\n\n      currentDraggableOptions.Pannable        = Options.Pannable\n      currentDraggableOptions.PanSensorWidth  = Options.PanSensorWidth\n      currentDraggableOptions.PanSensorHeight = Options.PanSensorHeight\n      currentDraggableOptions.PanSpeed        = Options.PanSpeed\n\n      currentDraggableOptions.onDragStart = (\n        Options.onDragStart || currentDraggableOptions.onDragStart\n      )           // may be used to update initial position for subsequent drags\n    }\n\n  /**** updateDroppableOptions ****/\n\n    function updateDroppableOptions (Options:any):void {\n      Options = parsedDroppableOptions(Options)\n\n      currentDroppableOptions.Operations  = Options.Operations\n      currentDroppableOptions.DataToOffer = Options.DataToOffer\n    }\n\n    Element.setAttribute('draggable','true')\n\n// @ts-ignore we know that the passed event is a DragEvent\n    Element.addEventListener('dragstart', startDragging)\n// @ts-ignore we know that the passed event is a DragEvent\n    Element.addEventListener('drag',      continueDragging)\n// @ts-ignore we know that the passed event is a DragEvent\n    Element.addEventListener('dragend',   finishDragging)\n\n    return {\n      update:(Options:any) => {\n        updateDraggableOptions(Options)\n        updateDroppableOptions(Options)\n      }\n    }\n  }\n\n//-------------------------------------------------------------------------------\n//--                 use:asDropZone={options} - for drop zones                 --\n//-------------------------------------------------------------------------------\n\n  export type TypeAcceptanceSet = { [Type:string]:string }\n                   // values consist of 'copy', 'move', 'link' (blank-separated)\n  type DropZoneOptions = {\n    Extras?:any,\n    TypesToAccept?:TypeAcceptanceSet,\n    HoldDelay?:number,\n    Pannable?:string|'this'|HTMLElement|SVGElement,\n    PanSensorWidth?:number, PanSensorHeight?:number, PanSpeed?:number,\n    onDroppableEnter?:(x:number,y:number, Operation:DropOperation, offeredTypeList:string[],\n                        DroppableExtras:any, DropZoneExtras:any) => boolean|undefined,\n    onDroppableMove?: (x:number,y:number, Operation:DropOperation, offeredTypeList:string[],\n                        DroppableExtras:any, DropZoneExtras:any) => boolean|undefined,\n    onDroppableHold?: (x:number,y:number, DroppableExtras:any, DropZoneExtras:any) => void,\n    onDroppableLeave?:(DroppableExtras:any, DropZoneExtras:any) => void,\n    onDrop?:          (x:number,y:number, Operation:DropOperation, DataOffered:any,\n                        DroppableExtras:any, DropZoneExtras:any) => string | undefined,\n  }\n\n/**** parsedDropZoneOptions ****/\n\n  function parsedDropZoneOptions (Options:any):DropZoneOptions {\n    Options = allowedPlainObject('drop zone options',Options) || {}\n\n    let Extras:any, TypesToAccept:TypeAcceptanceSet, HoldDelay:number\n    let Pannable:string|'this'|HTMLElement|SVGElement|undefined\n    let PanSensorWidth:number, PanSensorHeight:number, PanSpeed:number\n    let onDroppableEnter:Function, onDroppableMove:Function, onDroppableLeave:Function\n    let onDroppableHold:Function, onDroppableRelease:Function, onDrop:Function\n\n    Extras = Options.Extras\n\n    allowPlainObject('data types to be accepted',Options.TypesToAccept)\n    TypesToAccept = Object.create(null)\n      if ((Options.TypesToAccept != null) && ('none' in Options.TypesToAccept)) throwError(\n        'InvalidArgument: \"none\" is not a valid data type'\n      )\n\n      for (let Type in Options.TypesToAccept) {\n        if (Options.TypesToAccept.hasOwnProperty(Type)) {\n          TypesToAccept[Type] = parsedOperations(\n            'list of accepted operations for type ' + quoted(Type),\n            Options.TypesToAccept[Type]\n          )\n        }\n      }\n    HoldDelay = allowedIntegerInRange('min. time to hold',Options.HoldDelay, 0) as number\n\n    switch (true) {\n      case (Options.Pannable == null):\n        Pannable = undefined; break\n      case (Options.Pannable === 'this'):\n      case ValueIsNonEmptyString(Options.Pannable):\n      case (Options.Pannable instanceof HTMLElement):\n      case (Options.Pannable instanceof SVGElement):\n//    case (Options.Pannable instanceof MathMLElement):\n        Pannable = Options.Pannable; break\n      default: throwError(\n        'InvalidArgument: invalid \"Pannable\" specification given'\n      )\n    }\n\n    PanSensorWidth  = allowedOrdinal ('panning sensor width',Options.PanSensorWidth)\n      if (PanSensorWidth  == null) { PanSensorWidth = 20 }\n    PanSensorHeight = allowedOrdinal('panning sensor height',Options.PanSensorHeight)\n      if (PanSensorHeight == null) { PanSensorHeight = 20 }\n    PanSpeed        = allowedOrdinal        ('panning speed',Options.PanSpeed)\n      if (PanSpeed == null) { PanSpeed = 10 }\n\n    onDroppableEnter   = allowedFunction('\"onDroppableEnter\" handler',  Options.onDroppableEnter)\n    onDroppableMove    = allowedFunction('\"onDroppableMove\" handler',   Options.onDroppableMove)\n    onDroppableLeave   = allowedFunction('\"onDroppableLeave\" handler',  Options.onDroppableLeave)\n    onDroppableHold    = allowedFunction('\"onDroppableHold\" handler',   Options.onDroppableHold)\n    onDroppableRelease = allowedFunction('\"onDroppableRelease\" handler',Options.onDroppableRelease)\n    onDrop             = allowedFunction('\"onDrop\" handler',            Options.onDrop)\n\n    return {\n      Extras, TypesToAccept, HoldDelay,\n      Pannable, PanSensorWidth,PanSensorHeight, PanSpeed,\n// @ts-ignore we cannot validate given functions any further\n      onDroppableEnter, onDroppableMove, onDroppableLeave,\n// @ts-ignore we cannot validate given functions any further\n      onDroppableHold, onDroppableRelease, onDrop,\n    }\n  }\n\n/**** use:asDropZone={options} ****/\n\n  export function asDropZone (\n    Element:HTMLElement|SVGElement, Options:DropZoneOptions\n  ) {\n    let currentDropZoneOptions:DropZoneOptions\n\n    currentDropZoneOptions = parsedDropZoneOptions(Options)\n\n  /**** enteredByDroppable ****/\n\n    function enteredByDroppable (originalEvent:DragEvent) {\n      let Options = currentDropZoneOptions\n\n      performPanningFor(\n        'dropzone',\n        Element, Options, originalEvent.pageX,originalEvent.pageY\n      )\n\n      let DropZonePosition = asPosition(Conversion.fromDocumentTo(\n        'local', { left:originalEvent.pageX, top:originalEvent.pageY }, Element\n      ))                                         // relative to DropZone element\n\n      if (\n        ValueIsNumber(Options.HoldDelay) && (Options.HoldDelay as number > 0) &&\n        (Context.HoldWasTriggeredForElement !== Element)\n      ) { startHoldTimer(DropZonePosition) }\n\n      if (\n        (originalEvent.dataTransfer == null) ||\n        (originalEvent.dataTransfer.effectAllowed === 'none')\n      ) { return }\n\n      let wantedOperation:any = originalEvent.dataTransfer.dropEffect\n      if (wantedOperation === 'none') {            // workaround for browser bug\n        switch (originalEvent.dataTransfer.effectAllowed) {\n          case 'copy': case 'move': case 'link':\n            wantedOperation = originalEvent.dataTransfer.effectAllowed; break\n          default:\n            wantedOperation = undefined\n        }\n      }\n\n      let TypesToAccept   = Options.TypesToAccept as TypeAcceptanceSet\n      let offeredTypeList = originalEvent.dataTransfer.types.filter((Type) =>\n        (Type in TypesToAccept) &&\n        (TypesToAccept[Type] !== '')          // \"getData\" is not available here\n      ) // cannot use \"originalEvent.dataTransfer.dropEffect\" due to browser bug\n      if (offeredTypeList.length === 0) { return }\n\n      let accepted:boolean|undefined = ResultOfHandler(\n        'onDroppableEnter', Options,\n        DropZonePosition.x, DropZonePosition.y,\n        wantedOperation, offeredTypeList, Context.currentDroppableExtras, Options.Extras\n      )\n\n      if (accepted === false) {         // i.e. explicit \"false\" result required\n        return\n      } else {\n        Context.currentDropZoneExtras   = Options.Extras\n        Context.currentDropZoneElement  = Element\n        Context.currentDropZonePosition = DropZonePosition\n\n        Element.classList.add('hovered')\n\n        originalEvent.preventDefault()\n        originalEvent.stopPropagation()\n      }\n    }\n\n  /**** hoveredByDroppable ****/\n// warning: I've already seen leftByDroppable followed by hoveredByDropable!\n\n    function hoveredByDroppable (originalEvent:DragEvent) {\n      let Options = currentDropZoneOptions\n\n      performPanningFor(\n        'dropzone',\n        Element, Options, originalEvent.pageX,originalEvent.pageY\n      )\n\n      let DropZonePosition = asPosition(Conversion.fromDocumentTo(\n        'local', { left:originalEvent.pageX, top:originalEvent.pageY }, Element\n      ))                                         // relative to DropZone element\n\n      if (\n        ValueIsNumber(Options.HoldDelay) && (Options.HoldDelay as number > 0) &&\n        (Context.HoldWasTriggeredForElement !== Element)\n      ) {\n        if (Context.HoldPosition == null) {           // see above for reasoning\n          startHoldTimer(DropZonePosition)\n        } else {\n          continueHoldTimer(DropZonePosition)\n        }\n      }\n\n      if (\n        (originalEvent.dataTransfer == null) ||\n        (originalEvent.dataTransfer.effectAllowed === 'none') ||\n        (Context.currentDropZoneElement != null) && (Context.currentDropZoneElement !== Element)\n      ) {\n        Element.classList.remove('hovered')\n        return\n      }\n\n// in some browsers, it may be that (currentDropZone !== Element)!\n\n      let wantedOperation:any = originalEvent.dataTransfer.dropEffect\n      if (wantedOperation === 'none') {            // workaround for browser bug\n        switch (originalEvent.dataTransfer.effectAllowed) {\n          case 'copy': case 'move': case 'link':\n            wantedOperation = originalEvent.dataTransfer.effectAllowed; break\n          default:\n            wantedOperation = undefined\n        }\n      }\n\n      let TypesToAccept   = Options.TypesToAccept as TypeAcceptanceSet\n      let offeredTypeList = originalEvent.dataTransfer.types.filter((Type) =>\n        (Type in TypesToAccept) &&\n        (TypesToAccept[Type] !== '')          // \"getData\" is not available here\n      ) // cannot use \"originalEvent.dataTransfer.dropEffect\" due to browser bug\n      if (offeredTypeList.length === 0) {\n        if (Context.currentDropZoneElement === Element) {\n          Context.currentDropZoneExtras   = undefined\n          Context.currentDropZoneElement  = undefined\n          Context.currentDropZonePosition = undefined\n        }\n\n        Element.classList.remove('hovered')\n        return\n      }\n\n      Context.currentDropZonePosition = DropZonePosition\n\n      let accepted = ResultOfHandler(\n        'onDroppableMove', Options,\n        Context.currentDropZonePosition.x, Context.currentDropZonePosition.y,\n        wantedOperation, offeredTypeList, Context.currentDroppableExtras, Options.Extras\n      )\n\n      if (accepted === false) {         // i.e. explicit \"false\" result required\n        Context.currentDropZoneExtras   = undefined\n        Context.currentDropZoneElement  = undefined\n        Context.currentDropZonePosition = undefined\n\n        Element.classList.remove('hovered')\n      } else {              // warning: sometimes (currentDropZone !== Element)!\n        Context.currentDropZoneExtras   = Options.Extras\n        Context.currentDropZoneElement  = Element\n//      Context.currentDropZonePosition has already been set before\n\n        Element.classList.add('hovered')\n\n        originalEvent.preventDefault()            // never allow default action!\n//      originalEvent.stopPropagation()\n\n        return false          // special return value when drop seems acceptable\n      }\n    }\n\n  /**** leftByDroppable ****/\n\n    function leftByDroppable (originalEvent:DragEvent) {\n      Element.classList.remove('hovered')\n      Context.DropZonePanning = false\n\n      stopHoldTimer()\n\n      let Options = currentDropZoneOptions\n\n      if (Context.currentDropZoneElement === Element) {\n        if (Context.currentTypeTransferred == null) {   // see explanation below\n          Context.currentDropZoneExtras   = undefined\n          Context.currentDropZoneElement  = undefined\n\n          Context.DroppableWasDropped     = false\n          Context.currentDropZonePosition = undefined\n          Context.currentTypeTransferred  = undefined\n          Context.currentDataTransferred  = undefined\n\n          invokeHandler('onDroppableLeave', Options, Context.currentDroppableExtras, Options.Extras)\n        }                   // swallow \"dragleave\" right after successful \"drop\"\n\n        originalEvent.preventDefault()\n        originalEvent.stopPropagation()\n      }\n    }\n\n  /**** droppedByDroppable ****/\n\n    function droppedByDroppable (originalEvent:DragEvent) {\n      Element.classList.remove('hovered')\n      Context.DropZonePanning = false\n\n      stopHoldTimer()\n\n      if (\n        (originalEvent.dataTransfer == null) ||\n        (originalEvent.dataTransfer.effectAllowed === 'none') ||\n        (Context.currentDropZoneElement !== Element)\n      ) { return }\n\n//    originalEvent.preventDefault()\n      originalEvent.stopPropagation()\n\n      let Options = currentDropZoneOptions\n\n      let wantedOperation:any = originalEvent.dataTransfer.dropEffect\n      if (wantedOperation === 'none') {            // workaround for browser bug\n        switch (originalEvent.dataTransfer.effectAllowed) {\n          case 'copy': case 'move': case 'link':\n            wantedOperation = originalEvent.dataTransfer.effectAllowed; break\n          default:\n            wantedOperation = undefined\n        }\n      }\n\n      let TypesToAccept   = Options.TypesToAccept as TypeAcceptanceSet\n      let offeredTypeList = originalEvent.dataTransfer.types.filter((Type) =>\n        (Type in TypesToAccept) && (\n          (wantedOperation == null) ||\n          (TypesToAccept[Type].indexOf(wantedOperation) >= 0)\n        )\n      ) // cannot use \"originalEvent.dataTransfer.dropEffect\" due to browser bug\n      if (offeredTypeList.length === 0) {\n        Context.currentDropZoneExtras   = undefined\n        Context.currentDropZonePosition = undefined\n\n        Context.DroppableWasDropped     = false\n        Context.currentDropOperation    = undefined\n        Context.currentTypeTransferred  = undefined\n        Context.currentDataTransferred  = undefined\n\n        invokeHandler('onDroppableLeave', Options, Context.currentDroppableExtras, Options.Extras)\n\n        return\n      }\n\n      Context.currentDropZonePosition = asPosition(Conversion.fromDocumentTo(\n        'local', { left:originalEvent.pageX, top:originalEvent.pageY }, Element\n      ))                                         // relative to DropZone element\n\n      let offeredData:any = {}\n        offeredTypeList.forEach(\n// @ts-ignore originalEvent.dataTransfer definitely exists\n          (Type) => offeredData[Type] = originalEvent.dataTransfer.getData(Type)\n        )\n      let acceptedType = ResultOfHandler(\n        'onDrop', Options,\n        Context.currentDropZonePosition.x, Context.currentDropZonePosition.y,\n        wantedOperation, offeredData, Context.currentDroppableExtras, Options.Extras\n      )\n\n      switch (true) {\n        case (acceptedType == null):\n          Context.DroppableWasDropped    = true\n          Context.currentDropOperation   = wantedOperation\n          Context.currentTypeTransferred = undefined\n          Context.currentDataTransferred = undefined\n          break\n        case ValueIsOneOf(acceptedType,offeredTypeList):\n          Context.DroppableWasDropped    = true\n          Context.currentDropOperation   = wantedOperation\n          Context.currentTypeTransferred = acceptedType\n          Context.currentDataTransferred = offeredData[acceptedType]\n          break\n        default:               // handler should return false in case of failure\n          Context.DroppableWasDropped     = false\n          Context.currentDropZoneExtras   = undefined\n          Context.currentDropZonePosition = undefined\n          Context.currentDropOperation    = undefined\n          Context.currentTypeTransferred  = undefined\n          Context.currentDataTransferred  = undefined\n\n//        invokeHandler('onDroppableLeave', Options, currentDroppableExtras, Options.Extras)\n      }\n\n      Context.currentDropZoneElement = undefined\n    }\n\n  /**** startHoldTimer ****/\n\n    function startHoldTimer (DropZonePosition:Position):void {\n      Context.HoldPosition = DropZonePosition\n\n      if (Context.HoldTimer != null) {\n        clearTimeout(Context.HoldTimer)\n      }\n      Context.HoldTimer    = setTimeout(triggerHold, Options.HoldDelay)\n    }\n\n  /**** continueHoldTimer ****/\n\n    function continueHoldTimer (DropZonePosition:Position):void {\n      let Offset = (\n        ((Context.HoldPosition as Position).x-DropZonePosition.x)**2 +\n        ((Context.HoldPosition as Position).y-DropZonePosition.y)**2\n      )\n      if (Offset > 25) {\n        Context.HoldPosition = DropZonePosition\n\n        clearTimeout(Context.HoldTimer)\n        Context.HoldTimer = setTimeout(triggerHold, Options.HoldDelay)\n      }\n    }\n\n  /**** stopHoldTimer ****/\n\n    function stopHoldTimer () {\n      delete Context.HoldPosition\n\n      if (Context.HoldTimer != null) {\n        clearTimeout(Context.HoldTimer)\n        delete Context.HoldTimer\n      }\n\n      delete Context.HoldWasTriggeredForElement\n    }\n\n  /**** triggerHold ****/\n\n    function triggerHold () {\n      let DropZonePosition = (    // sometimes, there is no \"enteredByDroppable\"\n        Context.currentDropZonePosition || Context.HoldPosition\n      )\n\n      delete Context.HoldPosition\n      delete Context.HoldTimer\n\n      Context.HoldWasTriggeredForElement = Element\n\n      invokeHandler(\n        'onDroppableHold', Options,\n        (DropZonePosition as Position).x, (DropZonePosition as Position).y,\n        Context.currentDroppableExtras, Options.Extras\n      )\n    }\n\n  /**** updateDropZoneOptions ****/\n\n    function updateDropZoneOptions (Options:any):void {\n      Options = parsedDropZoneOptions(Options)\n\n      if (\n        (currentDropZoneOptions.Extras == null) && (Options.Extras != null)\n      ) {\n        currentDropZoneOptions.Extras = Options.Extras\n      }           // Extras may be set with delay, but remain constant afterwards\n\n      currentDropZoneOptions.TypesToAccept = Options.TypesToAccept\n\n      currentDropZoneOptions.HoldDelay = Options.HoldDelay\n\n      currentDropZoneOptions.Pannable        = Options.Pannable\n      currentDropZoneOptions.PanSensorWidth  = Options.PanSensorWidth\n      currentDropZoneOptions.PanSensorHeight = Options.PanSensorHeight\n      currentDropZoneOptions.PanSpeed        = Options.PanSpeed\n    }\n\n    Element.setAttribute('draggable','true')\n\n// @ts-ignore we know that the passed event is a DragEvent\n    Element.addEventListener('dragenter', enteredByDroppable)\n// @ts-ignore we know that the passed event is a DragEvent\n    Element.addEventListener('dragover',  hoveredByDroppable)\n// @ts-ignore we know that the passed event is a DragEvent\n    Element.addEventListener('dragleave', leftByDroppable)\n// @ts-ignore we know that the passed event is a DragEvent\n    Element.addEventListener('drop',      droppedByDroppable)\n\n    return { update:updateDropZoneOptions }\n  }\n\n/**** ValueIsPosition ****/\n\n  function ValueIsPosition (Candidate:any):boolean {\n    return (\n      ValueIsPlainObject(Candidate) &&\n      ValueIsFiniteNumber(Candidate.x) && ValueIsFiniteNumber(Candidate.y)\n    )\n  }\n\n/**** asPosition ****/\n\n  function asPosition (Value:any):Position {\n    return { x:Value.left, y:Value.top }\n  }\n\n/**** PositionReferenceFor ****/\n\n  function PositionReferenceFor (\n    Element:HTMLElement|SVGElement,\n    Options:DraggableOptions|DroppableOptions\n  ):Element {\n    let PositionReference:Element | undefined | null\n      switch (true) {\n        case (Options.relativeTo === 'parent'):\n          PositionReference = Element.parentElement\n          break\n        case (Options.relativeTo === 'body'):\n          PositionReference = document.body\n          break\n        case (Options.relativeTo instanceof HTMLElement):\n        case (Options.relativeTo instanceof SVGElement):\n  //    case (Options.relativeTo instanceof MathMLElement):\n          PositionReference = Options.relativeTo as Element\n          if (\n            (PositionReference != document.body) &&\n            ! document.body.contains(PositionReference)\n          ) throwError(\n            'InvalidArgument: the HTML element given as \"relativeTo\" option ' +\n            'is not part of this HTML document'\n          )\n          break\n        default:                                                 // CSS selector\n          PositionReference = Element.closest(Options.relativeTo as string)\n      }\n    return (PositionReference == null ? document.body : PositionReference)\n  }\n\n/**** DragImageFor ****/\n\n  function DragImageFor (\n    Element:HTMLElement|SVGElement,\n    Options:DraggableOptions|DroppableOptions\n  ):Element|undefined {\n    switch (true) {\n      case (Options.Dummy === 'standard'):\n        return undefined\n      case (Options.Dummy === 'none'):\n        let invisibleDragImage = document.createElement('div')\n          invisibleDragImage.setAttribute('style',\n            'display:block; position:absolute; width:1px; height:1px; ' +\n            'background:transparent; border:none; margin:0px; padding:0px; ' +\n            'cursor:auto'\n          )\n          document.body.appendChild(invisibleDragImage)\n        return invisibleDragImage\n      case ValueIsNonEmptyString(Options.Dummy):          // may flicker shortly\n        let auxiliaryElement = document.createElement('div')\n          auxiliaryElement.style.display  = 'block'\n          auxiliaryElement.style.position = 'absolute'\n          auxiliaryElement.style.left     = (document.body.scrollWidth + 100)+'px'\n\n          document.body.appendChild(auxiliaryElement)\n\n          auxiliaryElement.innerHTML = Options.Dummy as string\n        return auxiliaryElement.children[0]\n      case (Options.Dummy instanceof HTMLElement):\n      case (Options.Dummy instanceof SVGElement):\n//    case (Options.Dummy instanceof MathMLElement):\n        return Options.Dummy as Element\n      case ValueIsFunction(Options.Dummy):\n        let Candidate:HTMLElement | SVGElement | undefined = undefined\n        try {\n          Candidate = (Options.Dummy as Function)(Options.Extras, Element)\n        } catch (Signal) {\n          console.error('RuntimeError: creating draggable dummy failed',Signal)\n        }\n\n        if (Candidate != null) {\n          if ((Candidate instanceof HTMLElement) || (Candidate instanceof SVGElement)) {\n            return Candidate\n          } else {\n            console.error(\n              'InvalidArgument: the newly created draggable dummy is ' +\n              'neither an HTML nor an SVG element'\n            )\n          }\n        }\n    }\n  }\n\n  /**** performPanningFor ****/\n\n    function performPanningFor (\n      Type:'draggable'|'dropzone',\n      Element:HTMLElement | SVGElement, Options:DraggableOptions,\n      xOnPage:number,yOnPage:number\n    ):void {\n      if ((Type === 'draggable') && Context.DropZonePanning) { return }\n\n      if (\n        (Options.Pannable == null) ||\n        ((Options.PanSensorWidth === 0) && (Options.PanSensorHeight === 0)) ||\n        (Options.PanSpeed === 0)\n      ) { Context.DropZonePanning = false; return }\n\n      let pannableElement:Element|undefined|null\n        switch (true) {\n          case ValueIsNonEmptyString(Options.Pannable):\n            pannableElement = Element.parentElement\n            if (pannableElement != null) {\n              pannableElement = pannableElement.closest(Options.Pannable as string)\n            }\n            break\n          case (Options.Pannable === 'this') && (Type === 'dropzone'):\n            pannableElement = Element\n            break\n          case (Options.Pannable instanceof HTMLElement):\n          case (Options.Pannable instanceof SVGElement):\n//        case (Options.Pannable instanceof MathMLElement):\n            pannableElement = Options.Pannable as HTMLElement\n        }\n      if (pannableElement == null) { Context.DropZonePanning = false; return }\n\n      let { left:xInPannable, top:yInPannable } = Conversion.fromDocumentTo(\n        'local', { left:xOnPage, top:yOnPage }, pannableElement\n      )\n\n      if ((xInPannable >= 0) && (xInPannable < (Options.PanSensorWidth as number))) {\n        pannableElement.scrollLeft = Math.max(\n          0,pannableElement.scrollLeft - (Options.PanSpeed as number)\n        )\n      }\n\n      let PannableWidth = pannableElement.clientWidth           // w/o scrollbar\n      if (\n        (xInPannable >= PannableWidth-(Options.PanSensorWidth as number)) &&\n        (xInPannable < PannableWidth)\n      ) {\n        pannableElement.scrollLeft = Math.min(\n          pannableElement.scrollLeft + (Options.PanSpeed as number),\n          pannableElement.scrollWidth-PannableWidth\n        )\n      }\n\n      if ((yInPannable >= 0) && (yInPannable < (Options.PanSensorHeight as number))) {\n        pannableElement.scrollTop = Math.max(\n          0,pannableElement.scrollTop - (Options.PanSpeed as number)\n        )\n      }\n\n      let PannableHeight = pannableElement.clientHeight         // w/o scrollbar\n      if (\n        (yInPannable >= PannableHeight-(Options.PanSensorHeight as number)) &&\n        (yInPannable < PannableHeight)\n      ) {\n        pannableElement.scrollTop = Math.min(\n          pannableElement.scrollTop + (Options.PanSpeed as number),\n          pannableElement.scrollHeight-PannableHeight\n        )\n      }\n\n      Context.DropZonePanning = (Type === 'dropzone')\n    }\n\n/**** parsedOperations ****/\n\n  function parsedOperations (\n    Description:string, Argument:any, Default:string='copy move link'\n  ):string {\n    let Operations = allowedString(Description,Argument) || Default\n\n    switch (Operations.trim()) {\n      case 'all':  return 'copy move link'\n      case 'none': return ''\n    }\n\n    let OperationList = Operations.trim().replace(/\\s+/g,' ').split(' ')\n      allowListSatisfying(\n        Description,OperationList,\n        (Operation:string) => ValueIsOneOf(Operation,DropOperations)\n      )\n    return OperationList.reduce(\n      (Result:string, Operation:string) => (\n        Result.indexOf(Operation) < 0 ? Result + Operation + ' ': Result\n      ),' '\n    )\n  }\n\n/**** allowedEffectsFrom ****/\n\n  type allowedEffects = (\n    'none'|'copy'|'copyLink'|'copyMove'|'link'|'linkMove'|'move'|'all'\n  )\n\n  function allowedEffectsFrom (Operations:string):allowedEffects {\n    let EffectIndex = (                                       // Horner's method\n      (Operations.indexOf('move') < 0 ? 0 : 1) * 2 +\n      (Operations.indexOf('link') < 0 ? 0 : 1)\n    ) * 2 +\n    (Operations.indexOf('copy') < 0 ? 0 : 1)\n\n    return [\n      'none','copy','link','copyLink','move','copyMove','linkMove','all'\n    ][EffectIndex] as allowedEffects\n  }\n\n/**** invokeHandler ****/\n\n  function invokeHandler (Name:string, Options:any, ...Arguments:any):any {\n    if (Options[Name] != null) {\n      try {\n        return Options[Name].apply(null,Arguments)\n      } catch (Signal) {\n        console.error(quoted(Name) + ' handler failed',Signal)\n      }\n    }\n  }\n  const ResultOfHandler = invokeHandler\n\n\n"],
  "mappings": "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",
  "names": ["Element", "Options"]
}
